---
aliases:

---
20230828 1056
links:
title:
origin:
tags: #flashcards #todo 



这是一个用Markdown表格格式列出window对象主要子对象的表格:

|对象|说明|
|---|---|
|document|代表整个HTML文档,包含所有元素|
|location|包含当前页面URL信息,用于跳转|
|navigator|浏览器类型、版本等信息|
|history|操作浏览器历史记录,前进后退|
|screen|用户屏幕信息,如分辨率|
|frames|操作框架页面|
|external|外部窗口和新窗口操作|
|customElements|自定义元素定义和注册|
|performance|性能信息和测量|
|sessionStorage|会话级临时存储|
|localStorage|本地长期存储|

 setAttribute()方法用于动态设置元素属性。
语法:
```js
element.setAttribute(name, value);
```
参数:
- name:字符串,指定要设置的属性名
- value:字符串,指定属性值
使用示例:
```js
// 设置id属性
element.setAttribute('id', 'test');
// 设置class属性
element.setAttribute('class', 'box'); 
// 设置src属性
element.setAttribute('src', 'image.png');
// 设置自定义属性
element.setAttribute('data-id', '123');
```
setAttribute()方法与直接设置属性的区别:
- 直接设置属性只能设置常规属性,setAttribute()可以设置任意属性名
- 对于布尔属性,直接设置会忽略值,setAttribute()可以设置为true/false
此外,还有一个相关方法:
```js
element.removeAttribute(name);
```
用于删除一个属性。
所以setAttribute()和removeAttribute()可以更灵活地动态设置和删除元素的任意属性。

---
aliases:

---
20230829 1418
links:
title:
origin:
tags: #flashcards #todo 








#### 入口函数

 JS中的入口函数指的是页面或应用加载时首先执行的函数。
常见的JS入口函数有:
1. DOMContentLoaded事件
DOMContentLoaded事件表示DOM树已经完全加载和解析,但其他资源如图片、样式表还可能没有完全加载。
可以使用addEventListener绑定:
```js
document.addEventListener('DOMContentLoaded', function() {
  // 代码执行
});
```
2. window.onload事件 
window.onload事件表示页面所有资源如图片样式表都完全加载完毕时触发。
可以使用属性绑定:
```js 
window.onload = function() {
  // 代码执行
};
```
3. 外部JS文件加载完成
外部JS文件加载完成后,文件内部的代码会首先执行。
例如:
```html
<script src="main.js"></script>
```
```js
// main.js
console.log('外部JS加载完成');
```
4. IIFE立即执行函数表达式
使用IIFE可以实现自调用匿名函数的形式执行代码。
```js
(function() {
  console.log('IIFE执行');
})();
```
5. 其他框架或库的入口函数
比如Vue、React的入口函数就是初始化时执行的代码。
所以在JS中,DOMContentLoaded、window.onload、外部脚本和IIFE都是常见的JS入口函数形式。它们可以用于执行一些初始化操作或全局配置。


 事件委托是一种事件处理的方式,它通过事件冒泡来处理事件。
 
| 特点 | 实现方式 |
|-|-|
| 将事件处理程序添加到容器而不是每个子元素 | 将事件处理程序添加到父元素,例如`<ul>` |
| 节省内存和事件处理程序数量 | 只需要一个事件处理程序而不是每个子元素一个 |  
| 适用于动态生成的元素 | 可以处理未来添加的子元素的事件 |
| 提高响应速度 | 避免为每个子元素绑定事件而导致的性能问题 |
使用事件委托的步骤:

| 步骤 | 说明 |
|-|-|
| 1 | 找到合适的父容器元素 |
| 2 | 在父元素上绑定事件,如`click` |  
| 3 | 判断事件目标(event.target) |
| 4 | 根据目标元素执行不同逻辑 |
示例代码:
```js
const ul = document.querySelector('ul');
ul.addEventListener('click', function(e) {
  if(e.target.tagName === 'LI') {
    // 处理li点击事件
  }
});
```
通过事件委托可以有效减少事件处理程序的数量,提高响应速度,适用于动态DOM。




| 方法                     | 描述                                                        |
| ------------------------ | ----------------------------------------------------------- |
| getElementById()         | 根据元素的id属性获取单个DOM元素。                           |
| getElementsByClassName() | 根据元素的class属性获取匹配的DOM元素集合。                  |
| getElementsByTagName()   | 根据元素的标签名获取匹配的DOM元素集合。                     |
| querySelector()          | 根据CSS选择器获取匹配的第一个DOM元素。                      |
| querySelectorAll()       | 根据CSS选择器获取匹配的所有DOM元素。                        |
| getAttribute()           | 获取指定属性名的属性值。                                    |
| setAttribute()           | 设置指定属性名的属性值。                                    |
| removeAttribute()        | 移除指定属性名的属性。                                      |
| style                    | 获取或设置DOM元素的内联样式。                               |
| parentNode               | 获取DOM元素的父节点。                                       |
| childNodes               | 获取DOM元素的所有子节点（包括元素节点、文本节点等）。       |
| previousSibling          | 获取DOM元素的前一个兄弟节点。                               |
| nextSibling              | 获取DOM元素的后一个兄弟节点。                               |
| innerHTML                | 获取或设置DOM元素的内部HTML内容。                           |
| innerText                | 获取或设置DOM元素的内部文本内容（不包括HTML标签）。         |
| value                    | 获取或设置表单元素（如input、textarea）的值。               |
| classList                | 获取DOM元素的class列表，并提供添加、删除、切换class的方法。 |
| getElementByName                         |                                                             |
这些方法和属性可以用于获取和操作DOM元素。通过这些方法，可以根据元素的id、class、标签名、CSS选择器等不同的方式来获取DOM元素，并进行属性值的获取、设置、移除，样式的操作，以及节点的遍历等。

下表列出了JavaScript中常用的事件类型：

| 事件类型          | 描述                                                         |
| ----------------- | ------------------------------------------------------------ |
| click             | 当元素被单击时触发                                           |
| mouseover         | 当鼠标指针移动到元素上方时触发                               |
| mouseout          | 当鼠标指针移出元素时触发                                     |
| keydown           | 当键盘上的键被按下时触发                                     |
| keyup             | 当键盘上的键被释放时触发                                     |
| focus             | 当元素获得焦点时触发                                         |
| blur              | 当元素失去焦点时触发                                         |
| change            | 当表单元素的值发生改变时触发                                 |
| submit            | 当表单提交时触发                                             |
| load              | 当资源（如图片、脚本）加载完成时触发                          |
| unload            | 当页面或资源被卸载时触发                                     |
| scroll            | 当元素滚动时触发                                             |
| resize            | 当窗口或元素的大小发生改变时触发                             |
| contextmenu       | 当用户右键点击元素时触发                                     |
| touchstart        | 当触摸设备上开始触摸元素时触发                               |
| touchmove         | 当触摸设备上移动手指时触发                                   |
| touchend          | 当触摸设备上结束触摸元素时触发                               |
| transitionend     | 当CSS过渡动画结束时触发                                      |
| animationstart    | 当CSS动画开始时触发                                          |
| animationend      | 当CSS动画结束时触发                                          |
| dragstart         | 当元素被拖动开始时触发                                       |
| drag              | 当元素被拖动时触发                                           |
| dragend           | 当元素被拖动结束时触发                                       |
这些事件类型可以用于添加交互和响应的逻辑，根据具体需求选择合适的事件类型来监听和处理用户的操作行为。

在作为对象方法时，对应的命名通常是以 `on` 开头，后面跟着事件类型的名称，使用驼峰命名法。
例如，当将一个方法绑定到 `click` 事件时，通常会将该方法命名为 `onClick`。
下面是一些常见的以 `on` 开头的对象方法的命名示例：
- `onClick`：点击事件
- `onMouseOver`：鼠标移入事件
- `onMouseOut`：鼠标移出事件
- `onKeyDown`：键盘按下事件
- `onKeyUp`：键盘释放事件
- `onFocus`：获得焦点事件
- `onBlur`：失去焦点事件
- `onChange`：值改变事件
- `onSubmit`：表单提交事件
- `onLoad`：加载完成事件
- `onUnload`：卸载事件
- `onScroll`：滚动事件
通过使用这种命名约定，可以更清晰地表达对象方法与特定事件的关联，使代码更易于理解和维护。

在JavaScript中，可以使用以下方法来控制文本内容：
1. innerHTML 属性：用于获取或设置元素的 HTML 内容。可以使用 innerHTML 来替换或插入 HTML 标记和文本。<font color="#d831a8">(包含HTML标签)</font>
```javascript
   element.innerHTML = "新的文本内容";
   ```
2. textContent 属性：用于获取或设置元素的纯文本内容。它会自动转义特殊字符，确保文本以纯文本形式呈现。<font color="#d831a8">(不包含HTML标签)</font>
```javascript
   element.textContent = "新的文本内容";
   ```
3. innerText 属性：类似于 textContent 属性，用于获取或设置元素的纯文本内容。但 innerText 受 CSS 样式和可见性影响，不会返回隐藏元素的文本内容。
```javascript
   element.innerText = "新的文本内容";
   ```
4. createTextNode() 方法：用于创建纯文本节点，并将其作为子节点添加到其他元素中。
```javascript
   var textNode = document.createTextNode("文本内容");
   element.appendChild(textNode);
   ```
这些方法可以用于控制元素的文本内容。你可以根据具体需求选择适合的方法来获取、设置和操作元素的文本内容。


当通过JavaScript控制CSS时，以下是一些常见的实例：
1. 使用 style 属性修改元素的背景颜色：
```javascript
   var element = document.getElementById("myElement");
   element.style.backgroundColor = "red";
   ```
2. 使用 classList 属性添加或移除类名：
```javascript
   var element = document.getElementById("myElement");
   element.classList.add("highlight");    // 添加类名
   element.classList.remove("highlight"); // 移除类名
   ```
3. 使用 getComputedStyle() 方法获取元素的计算样式：
```javascript
   var element = document.getElementById("myElement");
   var computedStyle = window.getComputedStyle(element);
   var color = computedStyle.getPropertyValue("color");
   ```
4. 使用 setAttribute() 方法设置元素的行内样式：
```javascript
   var element = document.getElementById("myElement");
   element.setAttribute("style", "color: blue; font-size: 16px;");
   ```
这些示例演示了如何使用JavaScript来控制元素的CSS样式。你可以根据需要进行相应的修改和扩展，以满足特定的样式需求。

| 数据类型   | 遍历方法             | 描述                                                                                          |
| ---------- | -------------------- | ----------------------------------------------------------------------------------------------- |
| 数组       | for...of             | 遍历数组的每个元素，返回元素的值。                                                              |
| 字符串     | for...of             | 遍历字符串的每个字符，返回字符值。                                                              |
| Set        | for...of             | 遍历 Set 集合的每个元素，返回元素的值。                                                         |
| Map        | for...of 或 forEach   | 遍历 Map 集合的每个键值对，返回键和值。                                                        |
| 类数组对象 | for...of 或 forEach   | 遍历类数组对象（如 arguments、NodeList 等）的每个元素。                                         |
| 对象       | for...in             | 遍历对象的每个可枚举属性（包括原型链上的属性），返回属性名。                                    |
| 迭代器     | 迭代器的next()方法   | 遍历实现了迭代器接口的对象，通过调用 next() 方法依次返回对象的每个值，并返回一个表示是否完成的对象。 |
这些遍历方法可以用于不同类型的数据结构。根据数据类型的不同，选择合适的遍历方法来访问和操作数据。
- 对于数组、字符串、Set和Map等可迭代对象，可以使用 for...of 循环或 forEach 方法来遍历每个元素或键值对。
- 对于类数组对象，可以使用 for...of 循环或 forEach 方法来遍历每个元素。
- 对于普通对象，可以使用 for...in 循环遍历对象的每个可枚举属性。
- 对于实现了迭代器接口的对象，可以使用迭代器的 next() 方法来遍历对象的每个值。
通过选择适当的遍历方法，可以灵活地处理不同类型的数据，并对其进行相应的操作和处理。

下面是使用不同遍历方法的一些示例：
1. 遍历数组：
```javascript
   var arr = [1, 2, 3, 4, 5];
   for (var value of arr) {
     console.log(value);
   }
   ```
2. 遍历字符串：
```javascript
   var str = "Hello";
   for (var char of str) {
     console.log(char);
   }
   ```
3. 遍历Set集合：
```javascript
   var set = new Set([1, 2, 3]);
   for (var value of set) {
     console.log(value);
   }
   ```
4. 遍历Map集合：
```javascript
   var map = new Map([["name", "John"], ["age", 30]]);
   for (var [key, value] of map) {
     console.log(key + ": " + value);
   }
   ```
5. 遍历类数组对象：
```javascript
   var nodeList = document.querySelectorAll("p");
   for (var element of nodeList) {
     console.log(element.textContent);
   }
   ```
6. 遍历普通对象的可枚举属性：
```javascript
   var obj = { name: "John", age: 30 };
   for (var key in obj) {
     console.log(key + ": " + obj[key]);
   }
   ```
7. 遍历实现了迭代器接口的对象：
```javascript
   var iterator = {
     values: [1, 2, 3],
     next() {
       return this.values.length > 0 ? { value: this.values.shift(), done: false } : { done: true };
     }
   };
   var result;
   while ((result = iterator.next(), !result.done)) {
     console.log(result.value);
   }
   ```
这些示例演示了不同数据类型的遍历方法的使用。你可以根据需要选择适当的遍历方法，并根据具体场景对数据进行操作和处理。

```js
var div = document.getElementById("myDiv");
var styles = {
  backgroundColor: "red",
  color: "white",
  fontSize: "16px"
};

for (var property in styles) {
  div.style[property] = styles[property];
}

```


可以封装一个函数来实现将样式对象应用到元素的功能。以下是一个示例：
```javascript
function applyStylesToElement(element, styles) {
  for (var property in styles) {
    element.style[property] = styles[property];
  }
}
// 测试代码
var div = document.createElement("div");
div.textContent = "Hello, World!";
document.body.appendChild(div);
var styles = {
  backgroundColor: "red",
  color: "white",
  fontSize: "16px"
};
applyStylesToElement(div, styles);
// 测试结果
// div 元素将应用样式：背景颜色为红色，文字颜色为白色，字体大小为16像素。
```
在上面的示例中，封装了一个名为 `applyStylesToElement` 的函数，它接受两个参数：`element`（要应用样式的元素）和 `styles`（样式对象）。
在函数内部，使用 `for...in` 循环遍历样式对象的属性，并将每个属性和对应的值应用到元素的样式中。
接下来，通过测试代码创建了一个 `<div>` 元素，并将其添加到文档中。然后，定义了一个样式对象 `styles`，包含了要应用的样式。
最后，调用 `applyStylesToElement` 函数，将样式对象应用到 `<div>` 元素上。
测试结果是，`<div>` 元素将应用样式：背景颜色为红色，文字颜色为白色，字体大小为16像素。
你可以在你的代码中使用 `applyStylesToElement` 函数，将样式对象应用到需要的元素上，并根据需要自定义样式对象和元素。

当使用 `this` 关键字时，它引用的是当前执行上下文中的当前对象。具体来说，它可以指向不同的对象，取决于如何调用函数或方法。
下面通过测试用例来说明 `this` 关键字的不同用法和上下文：
```javascript
// 示例对象
var person = {
  name: "John",
  age: 30,
  introduce: function() {
    console.log("My name is " + this.name + " and I am " + this.age + " years old.");
  },
  greet: function(greeting) {
    console.log(greeting + ", " + this.name + "!");
  }
};
// 测试用例1：使用对象的方法调用
person.introduce();
// 输出：My name is John and I am 30 years old.
// 测试用例2：使用函数的普通调用
function introduce() {
  console.log("My name is " + this.name);
}
introduce();
// 输出：My name is undefined
// 测试用例3：使用 apply() 方法调用
introduce.apply(person);
// 输出：My name is John
// 测试用例4：使用 bind() 方法创建绑定函数
var boundIntroduce = introduce.bind(person);
boundIntroduce();
// 输出：My name is John
// 测试用例5：使用构造函数调用
function Person(name) {
  this.name = name;
}
var john = new Person("John");
console.log(john.name);
// 输出：John
```
在上面的示例中，我们定义了一个 `person` 对象，它包含了 `introduce` 和 `greet` 两个方法。
- 在测试用例1中，使用对象的方法调用 `person.introduce()`，此时 `this` 关键字指向 `person` 对象，能够正确访问对象的属性。
- 在测试用例2中，使用函数的普通调用 `introduce()`，此时 `this` 关键字指向全局对象（在浏览器环境中是 `window`），无法访问对象的属性。
- 在测试用例3中，使用 `apply()` 方法将 `person` 对象作为上下文传递给普通函数 `introduce()`，此时 `this` 关键字指向 `person` 对象。
- 在测试用例4中，使用 `bind()` 方法创建一个新的绑定函数 `boundIntroduce`，将 `person` 对象作为上下文，当调用 `boundIntroduce()` 时， `this` 关键字指向 `person` 对象。
- 在测试用例5中，使用构造函数 `Person` 创建一个新的对象 `john`，此时 `this` 关键字指向新创建的对象，能够访问对象的属性。
这些测试用例展示了不同上下文下 `this` 关键字的使用方式和行为。根据不同的调用方式和上下文，`this` 关键字的值会发生改变，需要注意上下文的影响。

### 公共函数
公共函数 `public.js` 是一个通用的 JavaScript 文件，用于存放和管理多个公共函数，可以在其他 JavaScript 文件中引用和使用这些函数。
首先，确保将 `public.js` 文件引入到你的 HTML 文件中，例如：
```html
<script src="public.js"></script>
```
接下来，你可以在其他 JavaScript 文件中使用 `public.js` 中定义的公共函数。以下是使用公共函数的示例：
```javascript
// 在其他 JavaScript 文件中引用公共函数
// 示例1: 使用 public.js 中的函数
// 调用 public.js 中的函数
var result1 = publicFunction1();
console.log(result1);
// 示例2: 使用 public.js 中的另一个函数
// 调用 public.js 中的另一个函数
var result2 = publicFunction2();
console.log(result2);
// ...
```
在示例中，我们使用 `public.js` 中的两个公共函数 `publicFunction1()` 和 `publicFunction2()`。
通过在其他 JavaScript 文件中引用 `public.js`，我们可以直接调用这些公共函数，并根据需要将结果存储在变量中，或者在控制台上进行打印输出等。
使用公共函数可以提高代码的重用性和可维护性，避免重复编写相同的代码逻辑。你可以根据需要在 `public.js` 中定义和管理各种公共函数，然后在其他文件中引用和使用它们。

`onmouseenter` 和 `onmouseleave` 是两个 JavaScript 事件，用于在鼠标进入和离开元素时触发相应的事件处理程序。
- `onmouseenter` 事件在鼠标进入元素时触发，当鼠标指针穿过元素边界时触发一次，不会在元素内部移动时重复触发。
- `onmouseleave` 事件在鼠标离开元素时触发，当鼠标指针离开元素边界时触发一次，不会在元素内部移动时重复触发。
以下是使用这两个事件的示例：
```html
<div id="myElement" onmouseenter="handleMouseEnter()" onmouseleave="handleMouseLeave()">
  Hover over me
</div>
<script>
function handleMouseEnter() {
  console.log("Mouse entered the element");
}
function handleMouseLeave() {
  console.log("Mouse left the element");
}
</script>
```
在上面的示例中，我们使用 `onmouseenter` 和 `onmouseleave` 属性将事件处理程序分别绑定到 `<div>` 元素的进入和离开事件。
当鼠标进入 `<div>` 元素时，会触发 `handleMouseEnter()` 函数，它会将 "Mouse entered the element" 打印到控制台。
当鼠标离开 `<div>` 元素时，会触发 `handleMouseLeave()` 函数，它会将 "Mouse left the element" 打印到控制台。
你可以根据需要在这两个事件处理程序中编写自定义逻辑，以响应鼠标进入和离开元素的动作。

### 表单元素标签属性

  还有type,id, className, classList 

| 标签属性    | 描述                                            |
| ----------- | ----------------------------------------------- |
| name        | 表单元素的名称                                  |
| value       | 表单元素的值                                    |
| disabled    | 表示表单元素是否禁用                            |
| readonly    | 表示表单元素是否只读                            |
| required    | 表示表单元素是否必填                            |
| placeholder | 表示表单元素的占位符文本                        |
| autofocus   | 表示表单元素是否自动获取焦点                    |
| autocomplete| 表示表单元素是否启用自动填充                      |
| checked     | 表示选择框（如复选框、单选框）是否被选中         |
| multiple    | 表示选择框（如下拉列表、文件上传）是否允许多选   |
| min         | 表示输入框（如数字输入框）的最小值               |
| max         | 表示输入框（如数字输入框）的最大值               |
| step        | 表示输入框（如数字输入框）的递增或递减步长       |
| pattern     | 表示输入框（如文本输入框）的匹配模式             |
| form        | 表示表单元素所属的表单                          |
这些是常见的表单元素标签属性，用于控制表单元素的行为和特性。你可以根据具体需求使用这些属性来定制表单的功能和验证要求。

```js
btn.onclick = function(){
  box.classList.remove("big")
}
```

```js
// 获取元素
var element = document.getElementById("myElement");

// 从元素的类列表中删除特定的类
element.classList.remove("myClass","myClass2");
element.classList.add("myClass","myClass2");//增加哪些类

```

### 表单元素的事件类型

| 事件类型    | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| submit      | 当表单提交时触发                                             |
| reset       | 当重置按钮被点击时触发                                       |
| input       | 当表单元素的值发生改变时触发                                 |
| change      | 当表单元素的值发生改变并失去焦点时触发                       |
| focus       | 当表单元素获得焦点时触发                                     |
| blur        | 当表单元素失去焦点时触发                                     |
| keydown     | 当表单元素的键盘上的键被按下时触发                           |
| keyup       | 当表单元素的键盘上的键被释放时触发                           |
| keypress    | 当表单元素的键盘上的键被按下并释放时触发                     |
| click       | 当鼠标单击表单元素时触发                                     |
| dblclick    | 当鼠标双击表单元素时触发                                     |
| mouseover   | 当鼠标指针移入表单元素上方时触发                             |
| mouseout    | 当鼠标指针移出表单元素时触发                                 |
| mouseenter  | 当鼠标指针穿过表单元素边界进入元素时触发，不会在内部移动时重复触发 |
| mouseleave  | 当鼠标指针离开表单元素边界时触发，不会在内部移动时重复触发   |
| select      | 当选择框（如下拉列表）中的选项被选中时触发                   |
| contextmenu | 当右键点击表单元素时触发                                     |
这些事件类型可以用于表单元素，用于监听和处理用户与表单元素的交互行为。你可以根据具体需求选择适当的事件类型，并编写相应的事件处理程序来实现相应的功能和逻辑。

以下是一些测试用例示例，用于测试表单元素的不同事件类型：
```html
<input type="text" id="myInput" />
<script>
  var inputElement = document.getElementById("myInput");
  // 测试用例1：input 事件
  inputElement.addEventListener("input", function() {
    console.log("Input event triggered");
  });
  // 测试用例2：change 事件
  inputElement.addEventListener("change", function() {
    console.log("Change event triggered");
  });
  // 测试用例3：focus 事件
  inputElement.addEventListener("focus", function() {
    console.log("Focus event triggered");
  });
  // 测试用例4：blur 事件
  inputElement.addEventListener("blur", function() {
    console.log("Blur event triggered");
  });
  // 测试用例5：keydown 事件
  inputElement.addEventListener("keydown", function(event) {
    console.log("Keydown event triggered - Key: " + event.key);
  });
  // 测试用例6：click 事件
  inputElement.addEventListener("click", function() {
    console.log("Click event triggered");
  });
</script>
```
在上面的示例中，我们创建了一个文本输入框 `<input>`，并使用不同的事件类型来监听各种交互行为。
- 在测试用例1中，当输入框的值发生变化时，会触发 `input` 事件，并输出 "Input event triggered"。
- 在测试用例2中，当输入框的值发生变化并且失去焦点时，会触发 `change` 事件，并输出 "Change event triggered"。
- 在测试用例3中，当输入框获得焦点时，会触发 `focus` 事件，并输出 "Focus event triggered"。
- 在测试用例4中，当输入框失去焦点时，会触发 `blur` 事件，并输出 "Blur event triggered"。
- 在测试用例5中，当在输入框按下键盘上的任意键时，会触发 `keydown` 事件，并输出按下的键的信息。
- 在测试用例6中，当点击输入框时，会触发 `click` 事件，并输出 "Click event triggered"。
你可以根据需要添加更多的测试用例，并根据实际情况检查事件是否被触发和输出的结果是否符合预期。

```js
<style>
.active {
  background-color: yellow;
}
</style>

<ul>
  <li class="active">Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>

<script>
// 获取所有 <li> 元素
var lis = document.querySelectorAll("li");

// 为每个 <li> 元素添加鼠标移入事件监听器
lis.forEach(function(li) {
  li.addEventListener("mouseover", function() {
  // 移除其他 <li> 元素的 active 类
  lis.forEach(function(li) {
    li.classList.remove("active");
  });
  
  // 为当前 <li> 元素添加 active 类
  this.classList.add("active");
  });
});
</script>


```

####  `mouseover` 和 `mouseenter`
`mouseover` 和 `mouseenter` 是两个鼠标事件，它们在触发时有一些区别。
- `mouseover` 事件会在鼠标指针进入元素或元素的子元素时触发，即使鼠标在元素内部移动也会触发该事件。
- `mouseenter` 事件则只在鼠标指针穿过元素边界进入元素时触发一次，不会在元素内部移动时重复触发。
以下是一个示例来说明这两个事件的区别：
```html
<div id="myElement">
  <p>Move your mouse here</p>
</div>
<script>
var element = document.getElementById("myElement");
element.addEventListener("mouseover", function() {
  console.log("mouseover event triggered");
});
element.addEventListener("mouseenter", function() {
  console.log("mouseenter event triggered");
});
</script>
```
在上面的示例中，我们有一个 `<div>` 元素，当鼠标在元素内部移动时，我们分别监听了 `mouseover` 和 `mouseenter` 事件。
当鼠标进入 `<div>` 元素或其子元素时，`mouseover` 事件会触发，并且在鼠标在元素内部移动时会重复触发。
而 `mouseenter` 事件则只在鼠标穿过 `<div>` 元素边界进入元素时触发一次，不会重复触发。
因此，如果你希望在鼠标进入元素时只触发一次事件，而不受鼠标在元素内部的移动影响，可以使用 `mouseenter` 事件。如果需要在鼠标进入元素和在元素内部移动时都触发事件，可以使用 `mouseover` 事件。




`element.addEventListener("mouseenter", function() { ... })` 和 `element.onmouseenter = function() { ... }` 都可以用于监听 `mouseenter` 事件，但它们在语法和使用上有一些区别。
使用 `addEventListener` 方法来添加事件监听器的优点是可以同时添加多个事件监听器，而不会覆盖之前添加的监听器。
另外，使用 `addEventListener` 方法还可以使用 `removeEventListener` 方法来移除事件监听器。
而使用 `onmouseenter` 属性赋值一个函数的方式，只能添加一个事件监听器，如果需要添加多个监听器，后面的监听器会覆盖之前的监听器。
另外，使用 `onmouseenter` 无法直接移除监听器，需要将其设置为 `null` 来取消事件监听。
以下是一个示例，演示了使用这两种方法来监听 `mouseenter` 事件：
```html
<div id="myElement">
  Move your mouse here
</div>
<script>
var element = document.getElementById("myElement");
// 使用 addEventListener 方法添加事件监听器
element.addEventListener("mouseenter", function() {
  console.log("Event listener 1 - mouseenter event");
});
// 使用 onmouseenter 属性添加事件监听器
element.onmouseenter = function() {
  console.log("Event listener 2 - mouseenter event");
};
</script>
```
在上面的示例中，我们为 `<div>` 元素添加了两个 `mouseenter` 事件的监听器。
当鼠标进入 `<div>` 元素时，两个监听器都会被触发，分别输出相应的消息到控制台。

```js
<div id="myElement">
  Move your mouse here
</div>

<script>
var element = document.getElementById("myElement");

// 使用 addEventListener 方法添加多个事件监听器
element.addEventListener("mouseenter", function() {
  console.log("Event listener 1 - mouseenter event");
});

element.addEventListener("mouseenter", function() {
  console.log("Event listener 2 - mouseenter event");
});

element.addEventListener("mouseenter", function() {
  console.log("Event listener 3 - mouseenter event");
});
</script>

```

在JavaScript中，有一些常见的编程思想和概念，可以用于解决特定的问题或优化代码。以下是一些常见的JavaScript思想和相应的测试用例示例：
1. 排他思想（Exclusive Thinking）：在处理多个选项或状态时，只允许其中一个选项或状态处于活动状态，而其他选项或状态必须处于非活动状态。
   - 测试用例：一个简单的排他思想的应用是通过点击切换类名来实现按钮的激活和非激活状态。
2. 开关思想（Toggle Thinking）：通过切换状态或属性的值来实现开关的功能，可以用于实现切换显示/隐藏、开启/关闭等功能。
   - 测试用例：一个简单的开关思想的示例是通过按钮点击来切换一个元素的显示和隐藏状态。
3. 委托思想（Delegation Thinking）：将事件处理委托给父元素，通过事件冒泡机制捕获和处理子元素的事件，以减少事件处理程序的数量。
   - 测试用例：在一个包含多个子元素的列表中，通过委托思想将点击事件处理委托给父元素，以处理子元素的点击事件。
4. 异步思想（Asynchronous Thinking）：将长时间运行的任务（如网络请求、文件读取等）放入异步操作中，以避免阻塞主线程，提高程序的响应性能。
   - 测试用例：使用异步思想来处理 AJAX 请求，确保异步请求不会阻塞页面的加载和用户交互。
这些是一些常见的JavaScript思想和相应的测试用例示例。你可以根据实际需求和场景，选择适当的思想来解决问题和优化代码。


以下是几个常见的JavaScript思想的代码示例，包括测试用例和预期结果：
1. 排他思想的代码示例：
```html
<button class="option" onclick="toggleActive(this)">Option 1</button>
<button class="option" onclick="toggleActive(this)">Option 2</button>
<button class="option" onclick="toggleActive(this)">Option 3</button>
<script>
function toggleActive(button) {
  // 移除所有选项的活动状态
  var options = document.getElementsByClassName("option");
  for (var i = 0; i < options.length; i++) {
    options[i].classList.remove("active");
  }
  // 将点击的选项设置为活动状态
  button.classList.add("active");
}
</script>
```
在这个示例中，点击每个按钮时，会将该按钮设置为活动状态（添加 `active` 类），同时移除其他按钮的活动状态。预期结果是只有一个按钮处于活动状态。
2. 开关思想的代码示例：
```html
<button onclick="toggleElement()">Toggle Element</button>
<div id="toggleDiv" style="display: none;">This is a toggleable element.</div>
<script>
function toggleElement() {
  var element = document.getElementById("toggleDiv");
  if (element.style.display === "none") {
    element.style.display = "block";
  } else {
    element.style.display = "none";
  }
}
</script>
```
在这个示例中，点击按钮时，会切换一个元素的显示和隐藏状态。预期结果是每次点击按钮时，元素会在显示和隐藏之间切换。
3. 委托思想的代码示例：
```html
<ul id="list">
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>
<script>
var list = document.getElementById("list");
list.addEventListener("click", function(event) {
  if (event.target.tagName === "LI") {
    console.log("Clicked on item: " + event.target.textContent);
  }
});
</script>
```
在这个示例中，点击列表中的任何一个 `<li>` 元素时，会通过委托思想将点击事件处理委托给父元素 `<ul>`，然后输出点击的元素文本内容。预期结果是在控制台上显示相应的点击信息。
这些示例演示了几个常见的JavaScript思想的代码和测试用例，你可以在你的代码中应用这些思想，并根据实际需求和场景进行相应的调整和扩展。
在 JavaScript 中，`tagName` 属性返回的是 HTML 元素的标签名，它是大写的。

所以在 `event.target.tagName === "LI"` 中，我们使用大写的 "LI" 来匹配 `<li>` 元素的标签名。

请注意，HTML 中的标签名是不区分大小写的，但在 JavaScript 中，`tagName` 属性返回的标签名是大写形式。因此，我们需要使用大写的 "LI" 来进行比较，以确保正确匹配 `<li>` 元素。

#### 子绝父相
"子绝父相" 是一种 CSS 布局技术，用于将子元素相对于父元素进行定位。通过将父元素设置为相对定位（position: relative），然后将子元素设置为绝对定位（position: absolute），可以实现子元素相对于父元素进行定位的效果。
以下是一个使用 "子绝父相" 布局的示例：
```html
<style>
  .parent {
    position: relative;
    width: 200px;
    height: 200px;
    background-color: lightblue;
  }
  
  .child {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100px;
    height: 100px;
    background-color: yellow;
  }
</style>
<div class="parent">
  <div class="child">Child Element</div>
</div>
```

子元素使用了 `top: 50%` 和 `left: 50%`，以及 `transform: translate(-50%, -50%)` 来将其相对于父元素水平居中和垂直居中。
通过这种方式，我们实现了子元素相对于父元素的定位效果，即使父元素的尺寸发生变化，子元素仍然保持在父元素的中心位置。
这就是 "子绝父相" 布局的一种应用，通过相对定位和绝对定位的结合，实现了灵活的布局效果。

`transform: translate(-50%, -50%);` 是一个 CSS 变换属性，用于通过平移（translate）来移动元素。
在这种情况下，`-50%` 的值表示将元素的自身宽度和高度的一半作为偏移量，从而实现将元素水平和垂直居中的效果。
具体来说，`translate(-50%, -50%)` 的作用是：
- 水平方向上，将元素的自身宽度的一半向左移动。
- 垂直方向上，将元素的自身高度的一半向上移动。
这样，通过这个变换，元素会相对于其父元素的中心位置进行定位。
注意：使用 `transform` 属性时，元素的 `position` 属性一般应为 `absolute` 或 `fixed`，以确保变换效果正确应用。
示例代码：
```html
<style>
  .parent {
    position: relative;
    width: 200px;
    height: 200px;
    background-color: lightblue;
  }
  
  .child {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100px;
    height: 100px;
    background-color: yellow;
  }
</style>
<div class="parent">
  <div class="child">Child Element</div>
</div>
```
在上面的示例中，我们使用 `.parent` 类来创建一个相对定位的父元素，然后使用 `.child` 类来创建一个绝对定位的子元素。
子元素使用 `top: 50%`、`left: 50%` 来将其定位在父元素的中心位置，然后使用 `transform: translate(-50%, -50%)` 来进行平移，使其在水平和垂直方向上居中。
通过这种方式，子元素会相对于父元素进行居中定位，无论父元素的尺寸如何变化，子元素都会保持在父元素的中心位置。

以下是经过格式化的代码：
```javascript
var spans = document.querySelectorAll(".box span");
for (var i = 0; i < spans.length; i++) {
  spans[i].onmouseenter = function() {
    // 角标的处理
    for (var j = 0; j < spans.length; j++) {
      spans[j].classList.remove("cur");
    }
    this.classList.add("cur");
  };
}
```
这段代码的作用是为具有 `.box` 类的父元素中的每个 `<span>` 元素添加鼠标进入事件监听器。当鼠标进入某个 `<span>` 元素时，会为该元素添加 `cur` 类，并移除其他 `<span>` 元素的 `cur` 类。
对于实现这种功能，除了上述代码中使用的方式，还可以使用以下两种方式：
1. 使用事件委托：将事件监听器绑定在父元素上，通过事件冒泡的方式来处理子元素的鼠标进入事件。这样可以减少事件监听器的数量，提高性能和代码可维护性。
2. 使用第三方库：使用像 jQuery、React 或 Vue 这样的第三方库，它们提供了更简洁和高级的事件处理机制，可以更方便地实现类似功能。
对比这些实现方式的优劣：
- 原始方式：适用于简单的场景，代码量较少，但随着元素数量的增加，事件监听器的数量也会增加，可能会影响性能和代码的可维护性。
- 事件委托：适用于有大量子元素的情况，只需绑定一个事件监听器，减少了监听器的数量，提高了性能和代码的可维护性。
- 第三方库：适用于复杂的场景，这些库提供了更高级的事件处理机制，可以更方便地处理事件，提供了更多的功能和灵活性。
选择合适的实现方式取决于具体的需求和场景。对于简单的情况，原始方式可能足够；对于更复杂的情况，使用事件委托或第三方库可能更合适。

使用事件委托的代码示例：
```javascript
var parentElement = document.querySelector(".box");
parentElement.addEventListener("mouseenter", function(event) {
  var target = event.target;
  if (target.tagName === "SPAN") {
    var spans = parentElement.querySelectorAll("span");
    for (var i = 0; i < spans.length; i++) {
      spans[i].classList.remove("cur");
    }
    target.classList.add("cur");
  }
});
```
在这个示例中，我们将事件监听器绑定到具有 `.box` 类的父元素上。当鼠标进入父元素时，通过 `event.target` 获取目标元素，然后检查目标元素是否为 `<span>` 元素。如果是，则移除其他 `<span>` 元素的 `cur` 类，并为目标元素添加 `cur` 类。
测试用例示例：
```html
<div class="box">
  <span>Option 1</span>
  <span>Option 2</span>
  <span>Option 3</span>
</div>
```
在这个测试用例中，我们有一个包含三个 `<span>` 元素的父元素，当鼠标进入其中一个 `<span>` 元素时，它应该获得 `cur` 类，并移除其他 `<span>` 元素的 `cur` 类。
使用第三方库（如 jQuery）的代码示例：
```html
<div class="box">
  <span>Option 1</span>
  <span>Option 2</span>
  <span>Option 3</span>
</div>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script>
$(".box").on("mouseenter", "span", function() {
  $(".box span").removeClass("cur");
  $(this).addClass("cur");
});
</script>
```
在这个示例中，我们使用 jQuery 库来实现事件委托的功能。通过使用 `on` 方法，我们将事件监听器绑定到具有 `.box` 类的父元素上，并指定监听的子元素为 `<span>` 元素。当鼠标进入子元素时，移除其他 `<span>` 元素的 `cur` 类，并为目标元素添加 `cur` 类。
这两个示例都提供了类似的功能，但使用了不同的实现方式。你可以根据自己的需求和喜好，选择适合的实现方式。

以下是在 React 和 Vue 中实现事件委托的代码示例。
React 示例：
```jsx
import React from 'react';
class ParentComponent extends React.Component {
  handleMouseEnter(event) {
    if (event.target.tagName === "SPAN") {
      const spans = event.currentTarget.querySelectorAll("span");
      spans.forEach(span => span.classList.remove("cur"));
      event.target.classList.add("cur");
    }
  }
  render() {
    return (
      <div className="box" onMouseEnter={this.handleMouseEnter}>
        <span>Option 1</span>
        <span>Option 2</span>
        <span>Option 3</span>
      </div>
    );
  }
}
export default ParentComponent;
```
Vue 示例：
```vue
<template>
  <div class="box" @mouseenter="handleMouseEnter">
    <span>Option 1</span>
    <span>Option 2</span>
    <span>Option 3</span>
  </div>
</template>
<script>
export default {
  methods: {
    handleMouseEnter(event) {
      if (event.target.tagName === "SPAN") {
        const spans = event.currentTarget.querySelectorAll("span");
        spans.forEach(span => span.classList.remove("cur"));
        event.target.classList.add("cur");
      }
    }
  }
}
</script>
```
这些示例在 React 和 Vue 中实现了事件委托的功能。当鼠标进入父元素时，通过事件对象的 `target` 属性获取目标元素，然后检查目标元素是否为 `<span>` 元素。如果是，则移除其他 `<span>` 元素的 `cur` 类，并为目标元素添加 `cur` 类。
这里使用了类组件方式实现的 React 示例，以及单文件组件方式实现的 Vue 示例。你可以根据你的项目需求和喜好，选择适合的实现方式。

在JavaScript中，可以使用以下方法来获取DOM节点的父元素、子元素和兄弟元素：
1. 获取父元素：
   - `parentNode`：获取节点的直接父节点。
2. 获取子元素：
   - `childNodes`：获取节点的所有子节点，包括文本节点和元素节点。
   - `children`：获取节点的所有子元素节点（不包括文本节点）。
3. 获取兄弟元素：
   - `previousSibling`：获取节点的前一个兄弟节点。
   - `nextSibling`：获取节点的后一个兄弟节点。
   - `previousElementSibling`：获取节点的前一个兄弟元素节点。
   - `nextElementSibling`：获取节点的后一个兄弟元素节点。
以下是一个示例代码，演示如何使用这些方法来获取父元素、子元素和兄弟元素：
```javascript
var parentElement = myElement.parentNode; // 获取父元素
var childNodes = myElement.childNodes; // 获取所有子节点
var childrenElements = myElement.children; // 获取所有子元素节点
var previousSibling = myElement.previousSibling; // 获取前一个兄弟节点
var nextSibling = myElement.nextSibling; // 获取后一个兄弟节点
var previousElementSibling = myElement.previousElementSibling; // 获取前一个兄弟元素节点
var nextElementSibling = myElement.nextElementSibling; // 获取后一个兄弟元素节点
```
请注意，获取的兄弟元素可能是文本节点或其他类型的节点，因此在访问和操作这些节点时，请确保使用正确的节点类型。
下面是一个代码示例，展示了如何使用JavaScript代码获取元素和节点：
```javascript
// 获取元素
var elementById = document.getElementById('myElementId'); // 通过id获取元素
var elementsByClassName = document.getElementsByClassName('myClassName'); // 通过class获取元素
var elementsByTagName = document.getElementsByTagName('div'); // 通过标签名获取元素
var firstMatch = document.querySelector('.mySelector'); // 通过CSS选择器获取匹配的第一个元素
var allMatches = document.querySelectorAll('.mySelector'); // 通过CSS选择器获取匹配的所有元素
// 获取节点
var parentNode = myNode.parentNode; // 获取父节点
var childNodes = myNode.childNodes; // 获取所有子节点
var childrenElements = myNode.children; // 获取所有子元素节点
var previousSibling = myNode.previousSibling; // 获取前一个兄弟节点
var nextSibling = myNode.nextSibling; // 获取后一个兄弟节点
var previousElementSibling = myNode.previousElementSibling; // 获取前一个兄弟元素节点
var nextElementSibling = myNode.nextElementSibling; // 获取后一个兄弟元素节点
```
请注意，以上示例中的`myElementId`、`myClassName`、`mySelector`和`myNode`仅供示例，实际使用时需要根据实际情况进行替换。这些方法和属性在不同的浏览器环境中也有一些细微的差异，请根据具体情况进行测试和兼容处理。

 


