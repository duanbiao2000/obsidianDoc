Certainly! Here's an example of how you can use the `async/await` syntax with promises in JavaScript:
```javascript
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const data = { name: 'John', age: 30 };
      resolve(data);
      // reject('Error fetching data');
    }, 2000);
  });
}
async function fetchAsyncData() {
  try {
    const data = await fetchData();
    console.log('Data:', data);
  } catch (error) {
    console.error('Error:', error);
  }
}
fetchAsyncData();
```
In this updated example, the `fetchData` function remains the same, returning a promise that resolves with some data after a 2-second delay.

The `fetchAsyncData` function is now declared as an `async` function. Within this function, we use the `await` keyword to pause the execution until the promise returned by `fetchData()` is resolved or rejected. The resolved data can be assigned to a variable (`data` in this case), and any errors can be caught using a `try-catch` block.
By calling `fetchAsyncData`, we can now use `await` to wait for the asynchronous operation to complete and handle the resolved data or catch any errors using the `try-catch` block.
Uncommenting the `reject` line inside the `fetchData` promise constructor will simulate a rejection, and the error will be caught in the `catch` block.
<mark class="hltr-pink">Using `async/await` can make asynchronous code appear more synchronous and easier to read, especially when dealing with multiple asynchronous operations or complex control flows.</mark>

