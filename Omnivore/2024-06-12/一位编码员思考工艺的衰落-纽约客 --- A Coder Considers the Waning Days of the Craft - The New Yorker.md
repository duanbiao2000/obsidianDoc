---
id: 849184a7-06f2-4ed6-a38c-96495d170a95
---

# 一位编码员思考工艺的衰落|纽约客 --- A Coder Considers the Waning Days of the Craft | The New Yorker
#Omnivore

[Read on Omnivore](https://omnivore.app/me/a-coder-considers-the-waning-days-of-the-craft-the-new-yorker-1900ac3639c)
[Read Original](https://www.newyorker.com/magazine/2023/11/20/a-coder-considers-the-waning-days-of-the-craft)

## Highlights

> <mark class="omni omni-yellow">themselves. We were to think of these advances as a tide coming in, nipping at our bare feet.</mark> [⤴️](https://omnivore.app/me/a-coder-considers-the-waning-days-of-the-craft-the-new-yorker-1900ac3639c#92d4d666-9105-408f-93ba-cacca39da43c)  ^92d4d666


---
# 一位编码员思考工艺的衰落|纽约客 --- A Coder Considers the Waning Days of the Craft | The New Yorker

I have always taken it for granted that, just as my parents made sure that I could read and write, I would make sure that my kids could program computers. It is among the newer arts but also among the most essential, and ever more so by the day, encompassing everything from filmmaking to physics. Fluency with code would round out my children’s literacy—and keep them employable. But as I write this my wife is pregnant with our first child, due in about three weeks. I code professionally, but, by the time that child can type, coding as a valuable skill might have faded from the world.  
我总是想当然地认为，就像我的父母确保我能读会写一样，我也会确保我的孩子能编程。它是一种较新的艺术，但也是最重要的艺术之一，而且越来越重要，涵盖了从电影制作到物理学的一切。流利的代码将使我的孩子们的文化水平更加完善，并使他们能够就业。但当我写这篇文章时，我的妻子正怀着我们的第一个孩子，大约三周后。我是专业的编程人员，但是，当孩子们可以打字的时候，编程作为一种有价值的技能可能已经从世界上消失了。

I first began to believe this on a Friday morning this past summer, while working on a small hobby project. A few months back, my friend Ben and I had resolved to create a _Times_\-style crossword puzzle entirely by computer. In 2018, we’d made a Saturday puzzle with the help of software and were surprised by how little we contributed—just applying our taste here and there. Now we would attempt to build a crossword-making program that didn’t require a human touch.  
我第一次开始相信这一点是在去年夏天的一个星期五早上，当时我正在做一个小的业余爱好项目。几个月前，我和我的朋友本决定完全用电脑制作一个《纽约时报》式的纵横字谜。在2018年，我们在软件的帮助下制作了一个星期六拼图，并惊讶于我们的贡献如此之少-只是在这里和那里应用我们的品味。现在，我们将尝试建立一个不需要人工干预的填字游戏程序。

When we’ve taken on projects like this in the past, they’ve had both a hardware component and a software component, with Ben’s strengths running toward the former. We once made a neon sign that would glow when the subway was approaching the stop near our apartments. Ben bent the glass and wired up the transformer’s circuit board. I wrote code to process the transit data. Ben has some professional coding experience of his own, but it was brief, shallow, and now about twenty years out of date; the serious coding was left to me. For the new crossword project, though, Ben had introduced a third party. He’d signed up for a ChatGPT Plus subscription and was using GPT-4 as a coding assistant.  
当我们过去承担这样的项目时，他们既有硬件组件，也有软件组件，Ben的优势在于前者。我们曾经做过一个氖灯，当地铁接近我们公寓附近的车站时，它会发光。本把玻璃弄弯，接上了Transformer的电路板。我写了代码来处理过境数据。本也有一些专业的编程经验，但那是短暂的、肤浅的，而且已经过时了20年。严肃的编程工作留给了我，不过，为了新的填字游戏项目，本介绍了第三方。他注册了ChatGPT Plus订阅，并使用GPT-4作为编码助手。

Something strange started happening. Ben and I would talk about a bit of software we wanted for the project. Then, a shockingly short time later, Ben would deliver it himself. At one point, we wanted a command that would print a hundred random lines from a dictionary file. I thought about the problem for a few minutes, and, when thinking failed, tried Googling. I made some false starts using what I could gather, and while I did my thing—programming—Ben told GPT-4 what he wanted and got code that ran perfectly.  
奇怪的事情发生了。Ben和我会谈论我们想要的项目软件。然后，在一段令人震惊的短时间后，本将亲自交付。有一次，我们想要一个命令，可以从字典文件中随机打印一百行。我思考了几分钟这个问题，当思考失败时，尝试谷歌搜索。我用我能收集到的东西做了一些错误的开始，当我做我的事情-编程-Ben告诉GPT-4他想要什么，得到了完美运行的代码。

Fine: commands like those are notoriously fussy, and everybody looks them up anyway. It’s not real programming. A few days later, Ben talked about how it would be nice to have an iPhone app to rate words from the dictionary. But he had no idea what a pain it is to make an iPhone app. I’d tried a few times and never got beyond something that half worked. I found Apple’s programming environment forbidding. You had to learn not just a new language but a new program for editing and running code; you had to learn a zoo of “U.I. components” and all the complicated ways of stitching them together; and, finally, you had to figure out how to package the app. The mountain of new things to learn never seemed worth it. The next morning, I woke up to an app in my in-box that did exactly what Ben had said he wanted. It worked perfectly, and even had a cute design. Ben said that he’d made it in a few hours. GPT-4 had done most of the heavy lifting.  
好吧：像这样的命令是出了名的繁琐，而且每个人都在查找它们。这不是真实的编程。几天后，本谈到，如果有一个iPhone应用程序来给字典中的单词打分，那该多好。但他不知道做一个iPhone应用程序是多么痛苦，我试过几次，从来没有超过一半的工作。我发现苹果的编程环境令人生畏。你不仅要学习一门新的语言，还要学习一个新的编辑和运行代码的程序;你必须学习一个“UI”动物园。最后，你必须弄清楚如何打包应用程序。堆积如山的新东西似乎不值得学习。第二天早上，我醒来时发现我的收件箱里有一个应用程序，它完全符合本的要求。它工作得很好，甚至有一个可爱的设计。本说他几个小时就到了GPT-4完成了大部分繁重的工作。

By now, most people have had experiences with A.I. Not everyone has been impressed. Ben recently said, “I didn’t start really respecting it until I started having it write code for me.” I suspect that non-programmers who are skeptical by nature, and who have seen ChatGPT turn out wooden prose or bogus facts, are still underestimating what’s happening.  
到目前为止，大多数人都有过人工智能的经历。并不是所有人都对此印象深刻。Ben最近说，“直到我开始让它为我写代码，我才开始真正尊重它。我怀疑那些天生持怀疑态度的非程序员，以及那些看到ChatGPT写出呆板的散文或虚假事实的人，仍然低估了正在发生的事情。

Bodies of knowledge and skills that have traditionally taken lifetimes to master are being swallowed at a gulp. Coding has always felt to me like an endlessly deep and rich domain. Now I find myself wanting to write a eulogy for it. I keep thinking of Lee Sedol. Sedol was one of the world’s best Go players, and a national hero in South Korea, but is now best known for losing, in 2016, to a computer program called AlphaGo. Sedol had walked into the competition believing that he would easily defeat the A.I. By the end of the days-long match, he was proud of having eked out a single game. As it became clear that he was going to lose, Sedol said, in a press conference, “I want to apologize for being so powerless.” He retired three years later. Sedol seemed weighed down by a question that has started to feel familiar, and urgent: What will become of this thing I’ve given so much of my life to?  
传统上需要花费一生时间才能掌握的知识和技能体系正在被一口吞下。编程对我来说就像是一个无尽的深度和丰富的领域。现在我发现自己想为它写一篇悼词。我一直在想李世石。李世石是世界上最好的围棋选手之一，也是韩国的民族英雄，但现在最出名的是在2016年输给了一个名为AlphaGo的计算机程序。李世石参加比赛的时候，就认为自己可以轻松击败人工智能。在长达几天的比赛结束时，他为勉强赢了一场比赛而感到自豪。当很明显他会输的时候，李世石在新闻发布会上说：“我想为自己的无能为力道歉。”三年，致仕。李世石似乎被一个开始让人感到熟悉和紧迫的问题压得喘不过气来：这个我付出了这么多生命的东西会变成什么样子？

My first enchantment with computers came when I was about six years old, in Montreal in the early nineties, playing Mortal Kombat with my oldest brother. He told me about some “fatalities”—gruesome, witty ways of killing your opponent. Neither of us knew how to inflict them. He dialled up an FTP server (where files were stored) in an MS-DOS terminal and typed obscure commands. Soon, he had printed out a page of codes—instructions for every fatality in the game. We went back to the basement and exploded each other’s heads.

I thought that my brother was a hacker. Like many programmers, I dreamed of breaking into and controlling remote systems. The point wasn’t to cause mayhem—it was to find hidden places and learn hidden things. “My crime is that of curiosity,” goes “The Hacker’s Manifesto,” written in 1986 by Loyd Blankenship. My favorite scene from the 1995 movie “Hackers” is when Dade Murphy, a newcomer, proves himself at an underground club. Someone starts pulling a rainbow of computer books out of a backpack, and Dade recognizes each one from the cover: the green book on international Unix environments; the red one on N.S.A.-trusted networks; the one with the pink-shirted guy on I.B.M. PCs. Dade puts his expertise to use when he turns on the sprinkler system at school, and helps right the ballast of an oil tanker—all by tap-tapping away at a keyboard. The lesson was that knowledge is power.

But how do you actually learn to hack? My family had settled in New Jersey by the time I was in fifth grade, and when I was in high school I went to the Borders bookstore in the Short Hills mall and bought “Beginning Visual C++,” by Ivor Horton. It ran to twelve hundred pages—my first grimoire. Like many tutorials, it was easy at first and then, suddenly, it wasn’t. Medieval students called the moment at which casual learners fail the _pons asinorum_, or “bridge of asses.” The term was inspired by Proposition 5 of Euclid’s Elements I, the first truly difficult idea in the book. Those who crossed the bridge would go on to master geometry; those who didn’t would remain dabblers. Section 4.3 of “Beginning Visual C++,” on “Dynamic Memory Allocation,” was my bridge of asses. I did not cross.

But neither did I drop the subject. I remember the moment things began to turn. I was on a long-haul flight, and I’d brought along a boxy black laptop and a CD-_ROM_ with the Borland C++ compiler. A compiler translates code you write into code that the machine can run; I had been struggling for days to get this one to work. By convention, every coder’s first program does nothing but generate the words “Hello, world.” When I tried to run my version, I just got angry error messages. Whenever I fixed one problem, another cropped up. I had read the “Harry Potter” books and felt as if I were in possession of a broom but had not yet learned the incantation to make it fly. Knowing what might be possible if I did, I kept at it with single-minded devotion. What I learned was that programming is not really about knowledge or skill but simply about patience, or maybe obsession. Programmers are people who can endure an endless parade of tedious obstacles. Imagine explaining to a simpleton how to assemble furniture over the phone, with no pictures, in a language you barely speak. Imagine, too, that the only response you ever get is that you’ve suggested an absurdity and the whole thing has gone awry. All the sweeter, then, when you manage to get something assembled. I have a distinct memory of lying on my stomach in the airplane aisle, and then hitting Enter one last time. I sat up. The computer, for once, had done what I’d told it to do. The words “Hello, world” appeared above my cursor, now in the computer’s own voice. It seemed as if an intelligence had woken up and introduced itself to me.

Most of us never became the kind of hackers depicted in “Hackers.” To “hack,” in the parlance of a programmer, is just to tinker—to express ingenuity through code. I never formally studied programming; I just kept messing around, making computers do helpful or delightful little things. In my freshman year of college, I knew that I’d be on the road during the third round of the 2006 Masters Tournament, when Tiger Woods was moving up the field, and I wanted to know what was happening in real time. So I made a program that scraped the leaderboard on pgatour.com and sent me a text message anytime he birdied or bogeyed. Later, after reading “Ulysses” in an English class, I wrote a program that pulled random sentences from the book, counted their syllables, and assembled haikus—a more primitive regurgitation of language than you’d get from a chatbot these days, but nonetheless capable, I thought, of real poetry:

> I’ll flay him alive  
> Uncertainly he waited  
> Heavy of the past

I began taking coding seriously. I offered to do programming for a friend’s startup. The world of computing, I came to learn, is vast but organized almost geologically, as if deposited in layers. From the Web browser down to the transistor, each sub-area or system is built atop some other, older sub-area or system, the layers dense but legible. The more one digs, the more one develops what the race-car driver Jackie Stewart called “mechanical sympathy,” a sense for the machine’s strengths and limits, of what one could make it do.

At my friend’s company, I felt my mechanical sympathy developing. In my sophomore year, I was watching “Jeopardy!” with a friend when he suggested that I make a playable version of the show. I thought about it for a few hours before deciding, with much disappointment, that it was beyond me. But when the idea came up again, in my junior year, I could see a way through it. I now had a better sense of what one could do with the machine. I spent the next fourteen hours building the game. Within weeks, playing “Jimbo Jeopardy!” had become a regular activity among my friends. The experience was profound. I could understand why people poured their lives into craft: there is nothing quite like watching someone enjoy a thing you’ve made.

In the midst of all this, I had gone full “Paper Chase” and begun ignoring my grades. I worked voraciously, just not on my coursework. One night, I took over a half-dozen machines in a basement computer lab to run a program in parallel. I laid printouts full of numbers across the floor, thinking through a pathfinding algorithm. The cost was that I experienced for real that recurring nightmare in which you show up for a final exam knowing nothing of the material. (Mine was in Real Analysis, in the math department.) In 2009, during the most severe financial crisis in decades, I graduated with a 2.9 G.P.A.

And yet I got my first full-time job easily. I had work experience as a programmer; nobody asked about my grades. For the young coder, these were boom times. Companies were getting into bidding wars over top programmers. Solicitations for experienced programmers were so aggressive that they complained about “recruiter spam.” The popularity of university computer-science programs was starting to explode. (My degree was in economics.) Coding “boot camps” sprang up that could credibly claim to turn beginners into high-salaried programmers in less than a year. At one of my first job interviews, in my early twenties, the C.E.O. asked how much I thought I deserved to get paid. I dared to name a number that faintly embarrassed me. He drew up a contract on the spot, offering ten per cent more. The skills of a “software engineer” were vaunted. At one company where I worked, someone got in trouble for using HipChat, a predecessor to Slack, to ask one of my colleagues a question. “Never HipChat an engineer directly,” he was told. We were too important for that.

This was an era of near-zero interest rates and extraordinary tech-sector growth. Certain norms were established. Companies like Google taught the industry that coders were to have free espresso and catered hot food, world-class health care and parental leave, on-site gyms and bike rooms, a casual dress code, and “twenty-per-cent time,” meaning that they could devote one day a week to working on whatever they pleased. Their skills were considered so crucial and delicate that a kind of superstition developed around the work. For instance, it was considered foolish to estimate how long a coding task might take, since at any moment the programmer might turn over a rock and discover a tangle of bugs. Deadlines were anathema. If the pressure to deliver ever got too intense, a coder needed only to speak the word “burnout” to buy a few months.

From the beginning, I had the sense that there was something wrongheaded in all this. Was what we did really so precious? How long could the boom last? In my teens, I had done a little Web design, and, at the time, that work had been in demand and highly esteemed. You could earn thousands of dollars for a project that took a weekend. But along came tools like Squarespace, which allowed pizzeria owners and freelance artists to make their own Web sites just by clicking around. For professional coders, a tranche of high-paying, relatively low-effort work disappeared.

[![“I should have known he has absolutely no morals—Ive seen how he loads a dishwasher.”](https://proxy-prod.omnivore-image-cache.app/0x0,skQEY_HY3axxHXhdiLFoWxJA_CsAwlALCR7qi9FI5LCE/https://media.newyorker.com/cartoons/654bf24a9d37df3d9f9cd355/master/w_1600%2Cc_limit/231120_a27287.jpg)](https://www.newyorker.com/cartoon/a27287)

“I should have known he has absolutely no morals—I’ve seen how he loads a dishwasher.”

Cartoon by Hartley Lin

The response from the programmer community to these developments was just, Yeah, you have to keep levelling up your skills. Learn difficult, obscure things. Software engineers, as a species, love automation. Inevitably, the best of them build tools that make other kinds of work obsolete. This very instinct explained why we were so well taken care of: code had immense leverage. One piece of software could affect the work of millions of people. Naturally, this sometimes displaced programmers ==themselves. We were to think of these advances as a tide coming in, nipping at our bare feet.== So long as we kept learning we would stay dry. Sound advice—until there’s a tsunami.

When we were first allowed to use A.I. chatbots at work, for programming assistance, I studiously avoided them. I expected that my colleagues would, too. But soon I started seeing the telltale colors of an A.I. chat session—the zebra pattern of call-and-response—on programmers’ screens as I walked to my desk. A common refrain was that these tools made you more productive; in some cases, they helped you solve problems ten times faster.

I wasn’t sure I wanted that. I enjoy the act of programming and I like to feel useful. The tools I’m familiar with, like the text editor I use to format and to browse code, serve both ends. They enhance my practice of the craft—and, though they allow me to deliver work faster, I still feel that I deserve the credit. But A.I., as it was being described, seemed different. It provided a _lot_ of help. I worried that it would rob me of both the joy of working on puzzles and the satisfaction of being the one who solved them. I could be infinitely productive, and all I’d have to show for it would be the products themselves.

The actual work product of most programmers is rarely exciting. In fact, it tends to be almost comically humdrum. A few months ago, I came home from the office and told my wife about what a great day I’d had wrestling a particularly fun problem. I was working on a program that generated a table, and someone had wanted to add a header that spanned more than one column—something that the custom layout engine we’d written didn’t support. The work was urgent: these tables were being used in important documents, wanted by important people. So I sequestered myself in a room for the better part of the afternoon. There were lots of lovely sub-problems: How should I allow users of the layout engine to convey that they want a column-spanning header? What should _their_ code look like? And there were fiddly details that, if ignored, would cause bugs. For instance, what if one of the columns that the header was supposed to span got dropped because it didn’t have any data? I knew it was a good day because I had to pull out pen and pad—I was drawing out possible scenarios, checking and double-checking my logic.

But taking a bird’s-eye view of what happened that day? A table got a new header. It’s hard to imagine anything more mundane. For me, the pleasure was entirely in the process, not the product. And what would become of the process if it required nothing more than a three-minute ChatGPT session? Yes, our jobs as programmers involve many things besides literally writing code, such as coaching junior hires and designing systems at a high level. But coding has always been the root of it. Throughout my career, I have been interviewed and selected precisely for my ability to solve fiddly little programming puzzles. Suddenly, this ability was less important.

I had gathered as much from Ben, who kept telling me about the spectacular successes he’d been having with GPT-4\. It turned out that it was not only good at the fiddly stuff but also had the qualities of a senior engineer: from a deep well of knowledge, it could suggest ways of approaching a problem. For one project, Ben had wired a small speaker and a red L.E.D. light bulb into the frame of a portrait of King Charles, the light standing in for the gem in his crown; the idea was that when you entered a message on an accompanying Web site the speaker would play a tune and the light would flash out the message in Morse code. (This was a gift for an eccentric British expat.) Programming the device to fetch new messages eluded Ben; it seemed to require specialized knowledge not just of the microcontroller he was using but of Firebase, the back-end server technology that stored the messages. Ben asked me for advice, and I mumbled a few possibilities; in truth, I wasn’t sure that what he wanted would be possible. Then he asked GPT-4\. It told Ben that Firebase had a capability that would make the project much simpler. Here it was—and here was some code to use that would be compatible with the microcontroller.

Afraid to use GPT-4 myself—and feeling somewhat unclean about the prospect of paying OpenAI twenty dollars a month for it—I nonetheless started probing its capabilities, via Ben. We’d sit down to work on our crossword project, and I’d say, “Why don’t you try prompting it this way?” He’d offer me the keyboard. “No, you drive,” I’d say. Together, we developed a sense of what the A.I. could do. Ben, who had more experience with it than I did, seemed able to get more out of it in a stroke. As he later put it, his own neural network had begun to align with GPT-4’s. I would have said that he had achieved mechanical sympathy. Once, in a feat I found particularly astonishing, he had the A.I. build him a Snake game, like the one on old Nokia phones. But then, after a brief exchange with GPT-4, he got it to modify the game so that when you lost it would show you how far you strayed from the most efficient route. It took the bot about ten seconds to achieve this. It was a task that, frankly, I was not sure I could do myself.

In chess, which for decades now has been dominated by A.I., a player’s only hope is pairing up with a bot. Such half-human, half-A.I. teams, known as centaurs, might still be able to beat the best humans and the best A.I. engines working alone. Programming has not yet gone the way of chess. But the centaurs have arrived. GPT-4 on its own is, for the moment, a worse programmer than I am. Ben is much worse. But Ben plus GPT-4 is a dangerous thing.

It wasn’t long before I caved. I was making a little search tool at work and wanted to highlight the parts of the user’s query that matched the results. But I was splitting up the query by words in a way that made things much more complicated. I found myself short on patience. I started thinking about GPT-4\. Perhaps instead of spending an afternoon programming I could spend some time “prompting,” or having a conversation with an A.I.

In a 1978 essay titled “On the Foolishness of ‘Natural Language Programming,’ ” the computer scientist Edsger W. Dijkstra argued that if you were to instruct computers not in a specialized language like C++ or Python but in your native tongue you’d be rejecting the very precision that made computers useful. Formal programming languages, he wrote, are “an amazingly effective tool for ruling out all sorts of nonsense that, when we use our native tongues, are almost impossible to avoid.” Dijkstra’s argument became a truism in programming circles. When the essay made the rounds on Reddit in 2014, a top commenter wrote, “I’m not sure which of the following is scariest. Just how trivially obvious this idea is” or the fact that “many still do not know it.”

When I first used GPT-4, I could see what Dijkstra was talking about. You can’t just say to the A.I., “Solve my problem.” That day may come, but for now it is more like an instrument you must learn to play. You have to specify what you want carefully, as though talking to a beginner. In the search-highlighting problem, I found myself asking GPT-4 to do too much at once, watching it fail, and then starting over. Each time, my prompts became less ambitious. By the end of the conversation, I wasn’t talking about search or highlighting; I had broken the problem into specific, abstract, unambiguous sub-problems that, together, would give me what I wanted.  
当我第一次使用GPT-4时，我可以看到Dijkstra在说什么。你不能对人工智能说“解决我的问题。”这一天可能会到来，但现在它更像是一种你必须学会演奏的乐器。你必须仔细说明你想要什么，就像和初学者说话一样。在搜索突出显示的问题中，我发现自己要求GPT-4一次做太多的事情，看着它失败，然后重新开始。每一次，我的提示都变得不那么雄心勃勃。在谈话的最后，我不是在谈论搜索或突出显示;我已经把问题分解成具体的、抽象的、明确的子问题，这些子问题合在一起，就能给予我想要的东西。

Having found the A.I.’s level, I felt almost instantly that my working life had been transformed. Everywhere I looked I could see GPT-4-size holes; I understood, finally, why the screens around the office were always filled with chat sessions—and how Ben had become so productive. I opened myself up to trying it more often.  
找到人工智能后当我达到这个水平的时候，我几乎立刻就感觉到我的工作生活已经改变了。无论我往哪里看，都能看到GPT-4大小的洞;我终于明白了，为什么办公室周围的屏幕总是充满了聊天会话，以及本是如何变得如此高效的。我敞开心扉，更频繁地尝试它。

I returned to the crossword project. Our puzzle generator printed its output in an ugly text format, with lines like `"s""c""a""r""*""k""u""n""i""s""*" "a""r""e""a"`. I wanted to turn output like that into a pretty Web page that allowed me to explore the words in the grid, showing scoring information at a glance. But I knew the task would be tricky: each letter had to be tagged with the words it belonged to, both the across and the down. This was a detailed problem, one that could easily consume the better part of an evening. With the baby on the way, I was short on free evenings. So I began a conversation with GPT-4\. Some back-and-forth was required; at one point, I had to read a few lines of code myself to understand what it was doing. But I did little of the kind of thinking I once believed to be constitutive of coding. I didn’t think about numbers, patterns, or loops; I didn’t use my mind to simulate the activity of the computer. As another coder, Geoffrey Litt, wrote after a similar experience, “I never engaged my detailed programmer brain.” So what _did_ I do?  
我又回到了填字游戏项目。我们的谜题生成器以一种丑陋的文本格式打印其输出，像 `"s""c""a""r""*""k""u""n""i""s""*" "a""r""e""a"` 这样的行。我想把这样的输出变成一个漂亮的网页，让我可以浏览网格中的单词，一目了然地显示得分信息。但我知道这项任务将是棘手的：每个字母都必须标记它所属的单词，包括横向和向下。这是一个细节问题，一个可以很容易地消耗一个晚上的大部分时间。孩子快出生了，我晚上没时间了。于是我开始与GPT-4进行对话。需要一些来回;有一次，我不得不自己读几行代码来理解它在做什么。但我几乎没有进行我曾经认为是编码的基本组成部分的那种思考。我没有考虑数字、模式或循环;我没有用我的头脑来模拟计算机的活动。 另一位程序员杰弗里·利特（Geoffrey Litt）在经历了类似的经历后写道：“我从来没有用过我详细的程序员大脑。”我做了什么？

Perhaps what pushed Lee Sedol to retire from the game of Go was the sense that the game had been forever cheapened. When I got into programming, it was because computers felt like a form of magic. The machine gave you powers but required you to study its arcane secrets—to learn a spell language. This took a particular cast of mind. I felt selected. I devoted myself to tedium, to careful thinking, and to the accumulation of obscure knowledge. Then, one day, it became possible to achieve many of the same ends without the thinking and without the knowledge. Looked at in a certain light, this can make quite a lot of one’s working life seem like a waste of time.  
也许促使李世石退出围棋比赛的原因是，围棋已经永远被贬低了。当我开始编程时，这是因为计算机感觉像是一种魔法。这台机器给了你力量，但要求你研究它的《双城之战》秘密--学习一种咒语。这需要一个特殊的心态。我觉得自己被选中了。我把自己投入到单调乏味的工作中，投入到仔细的思考中，投入到晦涩难懂的知识的积累中。然后，有一天，不需要思考，不需要知识，就可以达到许多相同的目的。从某种角度来看，这可能会使一个人的很多工作看起来像是浪费时间。

But whenever I think about Sedol I think about chess. After machines conquered that game, some thirty years ago, the fear was that there would be no reason to play it anymore. Yet chess has never been more popular—A.I. has enlivened the game. A friend of mine picked it up recently. At all hours, he has access to an A.I. coach that can feed him chess problems just at the edge of his ability and can tell him, after he’s lost a game, exactly where he went wrong. Meanwhile, at the highest levels, grandmasters study moves the computer proposes as if reading tablets from the gods. Learning chess has never been easier; studying its deepest secrets has never been more exciting.  
但是每当我想到李世石我就会想到国际象棋。大约30年前，机器征服了这个游戏之后，人们担心没有理由再玩它了。然而，国际象棋从未如此受欢迎--人工智能。让比赛更有活力我的一个朋友最近买了它。他随时都能接触到人工智能教练可以在他能力的边缘给他提供国际象棋问题，并且可以在他输了一场比赛后告诉他，他到底错在哪里。与此同时，在最高级别，大师们研究移动计算机建议，如果阅读片从神。学习国际象棋从未如此简单;研究其最深的秘密从未如此令人兴奋。

Computing is not yet overcome. GPT-4 is impressive, but a layperson can’t wield it the way a programmer can. I still feel secure in my profession. In fact, I feel somewhat more secure than before. As software gets easier to make, it’ll proliferate; programmers will be tasked with its design, its configuration, and its maintenance. And though I’ve always found the fiddly parts of programming the most calming, and the most essential, I’m not especially good at them. I’ve failed many classic coding interview tests of the kind you find at Big Tech companies. The thing I’m relatively good at is knowing what’s worth building, what users like, how to communicate both technically and humanely. A friend of mine has called this A.I. moment “the revenge of the so-so programmer.” As coding per se begins to matter less, maybe softer skills will shine.  
计算机还没有被克服。GPT-4令人印象深刻，但外行人无法像程序员那样使用它。我对我的职业仍然感到安全。事实上，我觉得比以前更安全了。随着软件变得越来越容易制作，它将激增;程序员将承担设计，配置和维护的任务。虽然我一直觉得编程中那些繁琐的部分是最让人平静的，也是最重要的，但我并不特别擅长它们。我失败了许多经典的编程面试测试，你可以在大型科技公司找到这种测试。我相对擅长的是知道什么值得构建，用户喜欢什么，如何在技术和人性上进行沟通。我的一个朋友称之为人工智能这就是“程序员的复仇”。随着编码本身开始变得不那么重要，也许软技能会大放异彩。

That still leaves open the matter of what to teach my unborn child. I suspect that, as my child comes of age, we will think of “the programmer” the way we now look back on “the computer,” when that phrase referred to a person who did calculations by hand. Programming by typing C++ or Python yourself might eventually seem as ridiculous as issuing instructions in binary onto a punch card. Dijkstra would be appalled, but getting computers to do precisely what you want might become a matter of asking politely.  
这仍然留下了什么教我未出生的孩子的问题。我怀疑，当我的孩子长大后，我们会像现在看待“计算机”一样看待“程序员”，当这个短语指的是一个用手做计算的人时。通过自己输入C++或Python进行编程，最终可能会像在穿孔卡上发布二进制指令一样荒谬。Dijkstra可能会感到震惊，但让计算机精确地做你想做的事情可能会变成一个礼貌的问题。

So maybe the thing to teach isn’t a skill but a spirit. I sometimes think of what I might have been doing had I been born in a different time. The coders of the agrarian days probably futzed with waterwheels and crop varietals; in the Newtonian era, they might have been obsessed with glass, and dyes, and timekeeping. I was reading an oral history of neural networks recently, and it struck me how many of the people interviewed—people born in and around the nineteen-thirties—had played with radios when they were little. Maybe the next cohort will spend their late nights in the guts of the A.I.s their parents once regarded as black boxes. I shouldn’t worry that the era of coding is winding down. Hacking is forever. ♦  
所以也许要教的不是技能而是精神。我有时会想，如果我出生在另一个时代，我可能会做些什么。农业时代的程序员可能会对水车和作物品种感到困惑;在牛顿时代，他们可能会痴迷于玻璃，染料和计时。最近我在阅读一本关于神经网络的口述历史，我突然意识到，在接受采访的人中，有多少人出生于20世纪30年代左右，他们小时候都玩过收音机。也许下一批人会在他们的父母曾经认为是黑匣子的人工智能的内脏里度过他们的深夜。我不应该担心编码的时代正在结束。黑客是永恒的。♦

