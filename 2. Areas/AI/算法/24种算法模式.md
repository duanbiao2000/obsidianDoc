---
aliases: 
source: 
author: 
<<<<<<< HEAD
date_created: 2024-07-16 20:06
type: 
priority: false
=======
createdAt: "20240622140240"
categories: 
status: false
updateAt: 2024-07-16 20:06
>>>>>>> 93a933e (refactor(dailyNotes): update metadata structure for daily notes)
---

## 算法

1. **排序算法**：
   - **冒泡排序（Bubble Sort）**：通过重复遍历列表，比较相邻元素并交换位置。
   - **选择排序（Selection Sort）**：每次遍历列表，找到最小（或最大）元素并放到正确的位置。
   - **插入排序（Insertion Sort）**：将元素插入到已排序部分的正确位置。
   - **快速排序（Quick Sort）**：通过选择一个“基准”元素，将列表分为两部分，递归排序。
   - **归并排序（Merge Sort）**：将列表分成两半，递归排序，然后合并。

2. **搜索算法**：
   - **线性搜索（Linear Search）**：从头到尾遍历列表，直到找到目标元素。
   - **二分搜索（Binary Search）**：在有序列表中，每次比较中间元素，缩小搜索范围。

3. **动态规划（Dynamic Programming）**：
   - **定义**：将问题分解为更小的子问题，并将子问题的解存储起来，避免重复计算。
   - **应用**：斐波那契数列、最短路径问题、背包问题等。

### 排序算法（冒泡排序）

```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

arr = [64, 34, 25, 12, 22, 11, 90]
bubble_sort(arr)
print(arr)  # 输出: [11, 12, 22, 25, 34, 64, 90]
```

### 搜索算法

搜索算法用于在数据结构中查找特定的元素或状态。在树和图中，搜索算法尤为重要。常见的搜索算法包括：

- **深度优先搜索（DFS）**：从根节点开始，沿着一条路径尽可能深入，直到无法继续，然后回溯并尝试其他路径。
- **广度优先搜索（BFS）**：从根节点开始，先访问所有相邻的节点，然后再访问这些节点的邻居，以此类推。

#### 二分搜索

```python
def binary_search(arr, target):
    low, high = 0, len(arr) - 1

    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1

arr = [1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
target = 10
index = binary_search(arr, target)
print(index)  # 输出: 6
```

 树（Tree）、图（Graph）是两种常见的数据结构，它们在计算机科学和算法设计中扮演着重要角色。搜索算法和动态规划是解决特定问题时常用的技术。下面我将简要介绍这些概念。

### [[动态规划（Dynamic Programming）]]


### 贪心算法

贪心算法（greedy algorithm）是一种常见的解决优化问题的算法，其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选择，即贪心地做出局部最优的决策，以期获得全局最优解。贪心算法简洁且高效，在许多实际问题中有着广泛的应用。

贪心算法和动态规划都常用于解决优化问题。它们之间存在一些相似之处，比如都依赖最优子结构性质，但工作原理不同。

- 动态规划会根据之前阶段的所有决策来考虑当前决策，并使用过去子问题的解来构建当前子问题的解。
- 贪心算法不会考虑过去的决策，而是一路向前地进行贪心选择，不断缩小问题范围，直至问题被解决。
![image.png](https://cdn.jsdelivr.net/gh/duanbiao2000/BlogGallery@main/picture/20240722131133.png)
一般情况下，贪心算法的适用情况分以下两种。

1. **可以保证找到最优解**：贪心算法在这种情况下往往是最优选择，因为它往往比回溯、动态规划更高效。
2. **可以找到近似最优解**：贪心算法在这种情况下也是可用的。对于很多复杂问题来说，寻找全局最优解非常困难，能以较高效率找到次优解也是非常不错的。
#### 15.1.4   贪心算法典型例题[¶](https://www.hello-algo.com/chapter_greedy/greedy_algorithm/#1514 "Permanent link")

贪心算法常常应用在满足贪心选择性质和最优子结构的优化问题中，以下列举了一些典型的贪心算法问题。

- **硬币找零问题**：在某些硬币组合下，贪心算法总是可以得到最优解。
- **区间调度问题**：假设你有一些任务，每个任务在一段时间内进行，你的目标是完成尽可能多的任务。如果每次都选择结束时间最早的任务，那么贪心算法就可以得到最优解。
- **分数背包问题**：给定一组物品和一个载重量，你的目标是选择一组物品，使得总重量不超过载重量，且总价值最大。如果每次都选择性价比最高（价值 / 重量）的物品，那么贪心算法在一些情况下可以得到最优解。
- **股票买卖问题**：给定一组股票的历史价格，你可以进行多次买卖，但如果你已经持有股票，那么在卖出之前不能再买，目标是获取最大利润。
- **霍夫曼编码**：霍夫曼编码是一种用于无损数据压缩的贪心算法。通过构建霍夫曼树，每次选择出现频率最低的两个节点合并，最后得到的霍夫曼树的带权路径长度（编码长度）最小。
- **Dijkstra 算法**：它是一种解决给定源顶点到其余各顶点的最短路径问题的贪心算法。
### [[分治算法]]

### [[回溯算法]]

### 学习资源

- **在线教程**：如GeeksforGeeks、W3Schools、菜鸟教程等。
- **书籍**：《算法导论》（Introduction to Algorithms）, 《数据结构与算法分析》等。
- **在线课程**：Coursera、edX、Udacity等平台上的相关课程。
### [[算法问题]]
