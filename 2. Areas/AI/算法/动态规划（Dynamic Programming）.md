### 动态规划（Dynamic Programming）

动态规划是一种将问题分解为更小的子问题，并将子问题的解存储起来以避免重复计算的方法。它适用于具有重叠子问题和最优子结构特性的问题。动态规划在解决诸如最短路径、[[最长公共子序列]]、背包问题等方面非常有效。
**记忆化搜索是一种“从顶至底”的方法**：我们从原问题（根节点）开始，递归地将较大子问题分解为较小子问题，直至解已知的最小子问题（叶节点）。之后，通过回溯逐层收集子问题的解，构建出原问题的解。

与之相反，**动态规划是一种“从底至顶”的方法**：从最小子问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解。

由于动态规划不包含回溯过程，因此只需使用循环迭代实现，无须使用递归。
```python
def climbing_stairs_dp(n: int) -> int:
    """爬楼梯：动态规划"""
    if n == 1 or n == 2:
        return n
    # 初始化 dp 表，用于存储子问题的解
    dp = [0] * (n + 1)
    # 初始状态：预设最小子问题的解
    dp[1], dp[2] = 1, 2
    # 状态转移：从较小子问题逐步求解较大子问题
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]
```

> [!NOTE]
> - 动态规划问题有三大特性：重叠子问题、最优子结构、无后效性。
> 1. 重叠子问题：动态规划问题具有重叠子问题，如果问题可以分解为较小的子问题，并且这些子问题共享或重叠。这意味着如果解决了一个子问题，它的解决方案可以多次重用，这可以提高算法的性能。
> 2. 最优子结构：动态规划问题具有最优子结构，如果问题可以分解为较小的子问题，并且可以从子问题的最优解构造出整个问题的解决方案。这意味着子问题的解决方案是整个问题的解决方案的一部分。
> 3. 无后效性：动态规划问题没有后效性，如果子问题的解决方案不依赖于子问题的解决顺序。这意味着子问题的解决方案对其他子问题的解决方案是独立的。


### 应用示例

- **搜索算法在树中的应用**：在二叉搜索树（BST）中查找一个值，或者在决策树中寻找最优路径。
- **搜索算法在图中的应用**：在社交网络中找到两个用户之间的最短路径，或者在地图上规划最短路线。
- **动态规划在树中的应用**：计算二叉树的最大深度，或者在二叉树中找到从根节点到叶节点的最大路径和。
- **动态规划在图中的应用**：解决旅行商问题（TSP），即找到访问所有城市并返回起点的最短路径。

## TSP

动态规划通常用于解决复杂问题的子问题，旅行商问题（TSP）是图论中的一个经典问题，它是一个组合优化问题，寻找的是遍历所有城市并返回起点的最短路径。动态规划解决TSP问题的一般方法是使用状态压缩的动态规划。

下面是一个简化版的动态规划解决TSP问题的Python代码实现。在这个例子中，我们假设城市数量较小，可以使用状态压缩的动态规划方法。这种方法在状态空间爆炸时非常有效，但它通常不用于解决大规模TSP问题。

这个例子使用了动态规划中的状态压缩技巧，通过位的组合表示状态，其中每一位代表是否访问了对应的城市。

```python
def tsp_dp(graph):
    N = len(graph)
    # 初始化dp数组，用0填充
    dp = [[0 for _ in range(1 << N)] for _ in range(N)]
    # 最终创建了一个二维数组，其中外部列表有N个元素，每个元素都是一个内部列表，内部列表中所有元素都是0。
    # 设置起始点
    dp[0][1] = 0  # 从点0开始，没有经过任何城市
    
    # 遍历所有状态
    for state in range(1 << N):
        for u in range(N):
            if not state & (1 << u):  # 如果状态state没有包含城市u
                next_state = state | (1 << u)
                for v in range(N):
                    if u != v and not state & (1 << v):
                        dp[v][next_state] = max(dp[v][next_state], dp[u][state] + graph[u][v])
    
    # 找到最小成本
    min_cost = min(dp[i][(1 << N) - 1] for i in range(N))
    
    # 回溯找到最短路径
    path = [0]  # 起点是0
    state = (1 << N) - 1
    while state:
        for u in range(N):
            if u == path[-1] and dp[u][state] + graph[u][path[-2]] == dp[path[-1]][state]:
                path.append(u)
                state = state & ~(1 << u)
                break
    
    return min_cost, path

# 示例图，使用邻接矩阵表示
graph = [
    [0, 2, 9, 10],
    [1, 0, 6, 4],
    [15, 7, 0, 8],
    [6, 3, 12, 0]
]

# 计算最短路径
min_cost, path = tsp_dp(graph)
print(f"Minimum cost: {min_cost}")
print(f"Path: {path}")
```

在这个代码中，我们使用一个二维数组`dp`来存储从某个城市到某个状态的最短路径长度。状态`state`是一个二进制数，每一位代表一个城市是否被访问过。对于每个城市`u`和每个状态`state`，我们尝试添加城市`u`到路径中，并更新下一个状态`next_state`。

注意，这个实现假设相邻城市之间的距离非负。在实际应用中，如果存在负权重边，可能需要使用不同的算法，比如Bellman-Ford算法。此外，这个实现的时间复杂度是指数级的，对于大量的城市，可能需要使用更加有效的近似算法或启发式算法。

## 切片

在您提供的代码片段中，`graph`是一个表示城市之间距离的邻接矩阵。邻接矩阵是一种常见的方式来表示加权图，其中图中的每个节点（在这个案例中是城市）被放置在矩阵的行和列中，而矩阵中的元素表示连接两个节点的边的权重。以下是对您提供的邻接矩阵的详细解释：

```python
graph = [
    [0, 2, 9, 10],
    [1, 0, 6, 4],
    [15, 7, 0, 8],
    [6, 3, 12, 0]
]
```

- 这个矩阵是一个4x4的矩阵，表示有4个城市。
- 矩阵的行和列分别对应城市0、城市1、城市2和城市3。
- 矩阵中的每个元素`graph[i][j]`表示城市`i`到城市`j`之间的距离。
- 如果没有直接的路径连接两个城市，那么对应的元素值是0（如`graph[0][0]`，`graph[1][1]`，`graph[2][2]`，`graph[3][3]`）。
- 如果有直接的路径连接两个城市，那么对应的元素值是两个城市之间的距离。

具体来说：

- `graph[0][0] = 0` 表示城市0到城市0的距离是0。
- `graph[0][1] = 2` 表示城市0到城市1的距离是2。
- `graph[0][2] = 9` 表示城市0到城市2的距离是9。
- `graph[0][3] = 10` 表示城市0到城市3的距离是10。
- `graph[1][0] = 1` 表示城市1到城市0的距离是1。
- `graph[1][1] = 0` 表示城市1到城市1的距离是0。
- 以此类推，对于其他元素。

这种邻接矩阵的表示对于计算图算法（如最短路径算法）非常有用，因为我们可以直接通过索引访问任意两个城市之间的距离。