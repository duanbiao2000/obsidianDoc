### 动态规划（Dynamic Programming）

动态规划是一种将问题分解为更小的子问题，并将子问题的解存储起来以避免重复计算的方法。它适用于具有重叠子问题和最优子结构特性的问题。动态规划在解决诸如最短路径、最长公共子序列、背包问题等方面非常有效。
**记忆化搜索是一种“从顶至底”的方法**：我们从原问题（根节点）开始，递归地将较大子问题分解为较小子问题，直至解已知的最小子问题（叶节点）。之后，通过回溯逐层收集子问题的解，构建出原问题的解。

与之相反，**动态规划是一种“从底至顶”的方法**：从最小子问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解。

由于动态规划不包含回溯过程，因此只需使用循环迭代实现，无须使用递归。
```python
def climbing_stairs_dp(n: int) -> int:
    """爬楼梯：动态规划"""
    if n == 1 or n == 2:
        return n
    # 初始化 dp 表，用于存储子问题的解
    dp = [0] * (n + 1)
    # 初始状态：预设最小子问题的解
    dp[1], dp[2] = 1, 2
    # 状态转移：从较小子问题逐步求解较大子问题
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[n]
```

> [!NOTE]
> - 动态规划问题有三大特性：重叠子问题、最优子结构、无后效性。
> 1. 重叠子问题：动态规划问题具有重叠子问题，如果问题可以分解为较小的子问题，并且这些子问题共享或重叠。这意味着如果解决了一个子问题，它的解决方案可以多次重用，这可以提高算法的性能。
> 2. 最优子结构：动态规划问题具有最优子结构，如果问题可以分解为较小的子问题，并且可以从子问题的最优解构造出整个问题的解决方案。这意味着子问题的解决方案是整个问题的解决方案的一部分。
> 3. 无后效性：动态规划问题没有后效性，如果子问题的解决方案不依赖于子问题的解决顺序。这意味着子问题的解决方案对其他子问题的解决方案是独立的。


### 应用示例

- **搜索算法在树中的应用**：在二叉搜索树（BST）中查找一个值，或者在决策树中寻找最优路径。
- **搜索算法在图中的应用**：在社交网络中找到两个用户之间的最短路径，或者在地图上规划最短路线。
- **动态规划在树中的应用**：计算二叉树的最大深度，或者在二叉树中找到从根节点到叶节点的最大路径和。
- **动态规划在图中的应用**：解决旅行商问题（TSP），即找到访问所有城市并返回起点的最短路径。