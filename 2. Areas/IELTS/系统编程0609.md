## 敏捷宣言 Agile Manifesto


> [!info]
> 敏捷开发是一种以人为核心、迭代、循序渐进的软件开发方法论。它强调在整个开发过程中的适应性和灵活性。敏捷开发的核心观念和原则主要来源于2001年的《敏捷宣言》（Agile Manifesto），该宣言定义了四个核心价值观和十二条原则。
> 
> ### 四个核心价值观：
> 1. **个体和互动** 高于 流程和工具
> 2. **可工作的软件** 高于 详尽的文档
> 3. **客户合作** 高于 合同谈判
> 4. **响应变化** 高于 遵循计划
> 
> ### 十二条原则：
> 1. 我们最优先的任务是通过尽早和持续地交付有价值的软件来满足客户的需求。
> 2. 欢迎在开发过程中变更需求，即使在开发后期也应如此。敏捷过程利用变更为客户的竞争优势。
> 3. 经常交付可工作的软件，更倾向于较短的交付周期。
> 4. 项目过程中应持续地与客户合作，以确保客户对软件方向的满意度。
> 5. 向项目团队成员提供所需的环境和支持，让他们能够以最有效的方式完成工作。
> 6. 信息传递最有效的方式是面对面的交流。
> 7. 可工作的软件是进度的主要度量标准。
> 8. 敏捷过程提倡可持续的开发速度。赞助者、开发者和用户应该能够保持一个恒定的速度。
> 9. 持续关注技术卓越和良好设计可以增强敏捷性。
> 10. 简洁——通过尽可能少的工作量做到最大化的工作未完成度。
> 11. 最佳的架构、需求和设计来自于自组织的团队。
> 12. 团队定期反思如何更有效率，然后相应地调整和完善其行为。




57. SOAP（Simple Object Access Protocol）：简单对象访问协议是一种基于XML的消息交换协议，广泛用于分布式计算和Web服务开发中。
58. AMQP（Advanced Message Queuing Protocol）：高级消息队列协议是一种网络协议，用于在分布式系统中传递异步通知和消息。
59. Agile（Agile Software Development）：敏捷开发是一种软件开发方法，它强调迭代、自组织和快速响应变化的价值观。
60. BDD（Behavior Driven Development）：行为驱动开发是一种敏捷开发方法论，以最终用户行为为目标，通过定义和验证标准化的用户场景来推动软件开发流程。
61. CI/CD（Continuous Integration and Continuous Delivery）：持续集成和持续交付是一种软件交付方法，借助自动化和DevOps实践，使得软件的发布速度和质量得到提高。
62. DRY（Don't Repeat Yourself）：不要重复自己原则是一种编程原则，它倡导在程序设计中尽量避免重复劳动和重复代码，以提高程序的可维护性和灵活性。
63. TDD（Test Driven Development）：测试驱动开发是一种敏捷开发方法，要求所有功能实现必须经过自动化测试的验证，在编写代码前先编写针对需求的自动化单元测试，然后编写适当的代码来满足测试条件。
64. UML（Unified Modeling Language）：统一建模语言是一种用于软件系统分析和设计的标准化图形化表示法。
66. ==Agile Manifesto（The Agile Manifesto）：敏捷宣言是一份由17位软件开发领域的专家共同起草的文件，旨在提出敏捷开发的核心观念和原则。==
67. Code Review（Code Review）：代码审查是指对开发者编写的源代码进行检查和审核的过程，以确保代码质量和符合相关的标准。
68. Continuous Integration（Continuous Integration）：持续集成是一种软件开发实践，借助自动化构建、单元测试和集成测试等工具，使得开发人员频繁地将代码集成到共享的代码库中，并对构建过程进行自动化测试，以便及时发现和解决问题。

81. Continuous Delivery（Continuous Delivery）：持续交付是一种软件开发流程，旨在在代码修改后通过自动化流程实现快速、可靠的发布高质量的软件。
82. Continuous Deployment（Continuous Deployment）：持续部署是一种软件开发流程，其目标是将软件修改自动部署到生产环境中，而无需任何人工干预。
83. Continuous Testing（Continuous Testing）：持续测试是指基于自动化测试的方法，在整个软件开发周期中不断地对程序代码进行测试和验证，并及时反馈测试结果和问题，以便开发人员进行及时修复。
84. DevOps（Development Operations）：开发运维是一种软件开发管理方法，它强调协同和沟通，通过实践方法与工具互相融合，以提高软件开发的效率和质量。

55. Mutation Testing（Mutation Testing）：变异测试是一种软件测试技术，其目的是通过人为修改源代码中的错误来检测自动化测试是否准确和完整。
56. Pair Programming（Pair Programming）：配对编程是一种敏捷软件开发方法，它要求两个开发者在一个计算机上共同开发代码，并及时进行交流和协作。
57. Refactoring（Code Refactoring）：重构是指在不改变程序行为的前提下，改善源代码结构、提高代码复用性和可维护性的一系列操作。
58. Scrum（Scrum Framework）：Scrum是一种敏捷软件开发框架，它强调协作和迭代开发，借助于“产品待办清单”、“冲刺”等实践方法来规范软件开发流程。
59. Sprint（Sprint）：冲刺是Scrum框架中一个迭代周期，一般为1-4周，其中团队要完成一组需求而不会被干扰。
60. Test Driven Development (TDD)（Test Driven Development (TDD)）：测试驱动开发是一种敏捷开发方式，先写测试代码然后再写代码的开发方式，旨在通过测试驱动的方式解决软件开发中的问题。
61. ATDD（Acceptance Test Driven Development）：验收测试驱动开发是一种敏捷开发方法，它强调从客户需求开始，将验收测试作为推动应用程序分析、设计和开发过程的主要手段。
62. BZZZP（Bugs, Zone, Zen, Prime）：Bug，Zone，Zen和Prime是一个社群，用于改善代码质量和提高工作效率。
63. FDD（Feature Driven Development）：特征驱动开发是一种面向对象的软件开发方法，该方法以实现用户可见特征为目标，通过实现这些特征来指导软
64. CPU缓存（CPU Cache）：计算机中的一种存储器，用于缓存处理器最近使用的数据、指令等内容，以提高计算机的性能。
65. 栈（Stack）：在计算机内存中一种先进后出的数据结构，用于存储函数调用、返回地址和局部变量等信息。
83. 内核模块（Kernel Module）：内核中一个动态加载的可执行代码片段，用于增强操作系统的功能或支持新的硬件设备。
84. 中断控制器（Interrupt Controller）：一种硬件电路，用于协调处理器和其他设备之间的中断信号。
85. CPU寄存器（CPU Register）：处理器内部的高速存储器，用于暂时存储数据和指令。
86. GNU工具链（GNU Toolchain）：由GNU开发的一组自由软件工具，包括编译器、调试器、汇编器等等。
87. 二进制文件（Binary File）：编译器编译源代码后生成的可执行文件，其中包含二进制代码、数据和信息。
88. ELF格式（ELF Format）：Executable and Linking Format，是一种常见的二进制文件格式，用于可执行文件、库和调试信息的存储。
89. 虚拟内存（Virtual Memory）：计算机系统使用硬盘作为虚拟内存的扩展，提高系统的性能和稳定性。
90. 闪存（Flash Memory）：一种非易失存储器，经常用于存储设备固件、嵌入式系统等东西。
91. 锁（Lock）：一种同步机制，可用于线程之间共享临界区域的互斥访问。
92. 时间戳（Timestamp）：在计算机系统中记录时间的一种方法，通常是从1970年1月1日起经过的秒数。
93. 事件驱动（Event Driven）：一种计算机程序设计模式，其中程序响应外部事件，而不是通过顺序执行代码来控制程序流程。
94. 队列（Queue）：在计算机内存中一种先进先出的数据结构，用于保存输入/输出请求、消息等。
95. 条件变量（Condition Variable）：一种线程同步机制，用于使线程等待某些特定条件的发生。
96. 原子操作（Atomic Operation）：不可分割的操作，保证并发环境中对共享资源的正确访问。
97. 可重入（Reentrant）：指一段代码可以由多个线程或进程同时调用，并保持结果的正确性。
98. 系统调用（System Call）：操作系统提供的一组接口，用于管理系统资源和执行特定操作。
99. 系统日志（System Log）：记录计算机系统事件的一种机制，用于诊断和监视系统问题。
100. 内存泄漏（Memory Leak）：在程序中没有正确释放分配的内存空间，导致程序占用更多的内存。
101. 编码器（Encoder）：将数据从一种格式转换为另一种格式的程序或设备。例如音频编码器可以将声音转换成数字信号。
102. Kernel Module: A dynamically loaded executable code segment in the kernel used to enhance operating system functionality or support new hardware devices.
56. Interrupt Controller: A hardware circuit used to coordinate interrupt signals between the processor and other devices.

57. CPU Register: A high-speed storage device inside the processor used for temporarily storing data and instructions.

58. GNU Toolchain: A set of free software tools developed by GNU, including compilers, debuggers, assemblers, and so on.

59. Binary File: An executable file generated by compiling source code, containing binary code, data, and information.

60. ELF Format: Executable and Linking Format is a common binary file format used for storing executable files, libraries, and debugging information.

61. Virtual Memory: Computer systems use hard disk as an extension of virtual memory, improving system performance and stability.

62. Flash Memory: A non-volatile memory frequently used for storing device firmware, embedded systems, and so on.

63. Lock: A synchronization mechanism used for mutual exclusion access to critical regions shared among threads.

64. Timestamp: A method of recording time in computer systems, usually the number of seconds elapsed since January 1, 1970.

65. Event Driven: A computer program design pattern where the program responds to external events, rather than controlling program flow through sequential execution of code.

66. Queue: A first-in, first-out data structure in computer memory used to save input/output requests, messages, and so on.

67. Condition Variable: A thread synchronization mechanism used to make threads wait for certain specific conditions to occur.

68. Atomic Operation: An indivisible operation that ensures correct access to shared resources in a concurrent environment.

69. Reentrant: Refers to code that can be invoked by multiple threads or processes at the same time while maintaining result correctness.

70. System Call: A set of interfaces provided by the operating system used to manage system resources and perform specific operations.

71. System Log: A mechanism that records computer system events, used for diagnosing and monitoring system issues.

72. Memory Leak: An error in a program where allocated memory space is not properly released, resulting in the program occupying more memory.

73. Encoder: A program or device used to convert data from one format to another. For example, an audio encoder can convert sound into digital signals.
121. 解码器（Decoder）：将经过编码后的数据解压缩并还原成原始数据的程序或设备。
122. 进程间通信（Interprocess Communication）：不同进程之间传递信息和共享资源的机制。
123. 线程同步（Thread Synchronization）：用于协调多个线程访问共享资源的机制。
124. 关联数组（Associative Array）：指一种键值对的数据结构，每个关键字都唯一地对应一个值。
125. 模拟器（Simulator）：可以模拟计算机硬件或软件行为的程序。
126. 终端（Terminal）：计算机操作员与计算机交互的设备，也可以是一个远程登录会话。
127. 动态链接库（Dynamic Link Library）：一种可被多个程序同时使用的代码库，通常是在运行时被载入。
128. 协议栈（Protocol Stack）：计算机网络协议的一系列实现，用于在计算机或网络之间传输数据。
129. 数据库管理系统（Database Management System）：管理数据库的软件系统。
130. 内存映射文件（Memory-Mapped File）：允许程序直接使用磁盘文件作为内存地址空间的一部分。
131. 性能分析（Profiling）：用于测量和优化程序运行效率的过程。
132. Debug工具（Debugger）：用于调试程序的工具，帮助程序员发现和解决错误。
133. 自旋锁（Spin Lock）：一种线程同步机制，用于在多个线程中保护共享资源。
134. 共享内存（Shared Memory）：一种进程间通信机制，允许不同进程之间共享同一块内存。

38. 操作系统虚拟化（OS Virtualization）：一种虚拟化技术，允许多个操作系统共享同一个物理计算机资源。
39. 死锁（Deadlock）：并发程序中一种常见的问题，当两个或更多进程无法继续执行时出现。这是由于每个进程都在等待其他进程释放互斥锁。
40. 设备驱动程序（Device Driver）：用于管理计算机系统硬件设备的软件程序。
41. 文件描述符（File Descriptor）：一个整数值，用于标识打开文件、套接字或其他I/O资源。
42. 簇片（Cluster）：也称为块，是文件系统使用的最小数据单位，通常为2KB到8KB之间。
43. 虚拟文件系统（Virtual File System）：将不同的文件系统统一抽象成一个文件层次结构，并提供一组通用API以进行文件管理。
44. 调试输出（Debugging Output）：用于在调试过程中输出状态信息、错误消息和调试信息的函数调用或语句。
45. 音频编解码（Audio Codec）：将音频信号转换为数字格式并对其进行压缩和解压缩的程序或设备。
46. 分页机制（Paging Mechanism）：一种内存管理技术，将物理内存划分成固定大小的页面，并使用页表将虚拟内存映射到物理内存。
47. 多线程（Multithreading）：一种并发编程技术，允许多个线程同时执行。这可以提高程序性能、响应速度和资源利用率。
48. 代码注入（Code Injection）：向正在运行的进程添加、修改或删除指令的过程。通常用于调试或恶意软件攻击。
49. 抢占调度（Preemptive Scheduling）：一种进程调度策略，在进程执行到某个时间点时，操作系统可以强制把CPU分配给其他优先级更高的进程。
50. 消息队列（Message Queue）：用于在进程之间传输数据和信息的机制。消息队列通常是一个特定的内核对象类型。
51. 进程状态（Process State）：表示进程当前活动的状态，例如运行、等待I/O、睡眠、就绪等。
52. 虚拟设备（Virtual Device）：一种不需要物理硬件的软件设备，可以实现类似于真实设备的功能。
53. 线程库（Thread Library）：提供一组API函数，帮助程序员开发多线程应用程序。
54. 位域（Bit Field）：使用较少的位数来存储和访问数据的技术。它将多个字段打包成单个字节或单词中的位，可以节省内存空间。
55. 堆内存（Heap Memory）：用于动态分配内存的区域。堆内存通常是程序可用的最大内存区域之一。
56. 外部排序（External Sorting）：用于在磁盘文件上对大量数据进行排序的算法和技术。
57. 内部排序（Internal Sorting）：用于在计算机内存中对数据进行排序的算法和技术。
58. 调试符号表（Debug Symbols）：编译器生成的符号表，用于帮助调试器追踪变量和函数调用时的上下文信息。
59. I/O复用（I/O Multiplexing）：一种并发编程技术，允许在单个线程中同时处理多个I/O事件。
60. 缓冲区溢出（Buffer Overflow）：一种安全漏洞，当程序向缓冲区写入过多的数据或无效数据时，可能会覆盖内存中的其他重要数据或代码。
61. 匿名管道（Anonymous Pipe）：用于进程间通信的一种数据传输方式。
62. 断点（Breakpoint）：调试器支持的一种设置，程序在执行到该点时暂停，以便程序员查看变量、内存或函数调用的状态。
63. 整数溢出（Integer Overflow）：与缓冲区溢出类似的安全漏洞，当算术操作导致计算机无法表示的整数时会发生。
64. 地址空间（Address Space）：进程使用的虚拟地址集合。地址空间包含代码、数据、栈等内存段。
65. 睡眠状态（Sleep State）：计算机的一种电源管理功能，使计算机进入较低功率模式来节省能源和延长电池寿命。
66. 故障处理器（Fault Handler）：用于管理系统中硬件或软件错误和异常的程序或模块。
67. 线程控制块（Thread Control Block）：用于管理线程状态和上下文信息的数据元素或记录。
68. 时间片轮转（Round Robin）：一种常见的进程调度算法，每个进程被分配一个时间片，在每个时间片结束时切换到下一个就绪进程。
69. 简单网络管理协议（SNMP）：一种用于网络管理的标准协议，允许管理员监控网络上设备和应用程序的性能和健康状况。
70. 系统时间（System Clock）：计算机系统使用的内部时钟，用于跟踪当前时间和日期。系统时钟通常受到晶体振荡器或电池支持。
71. 双向链表（Doubly Linked List）：一种数据结构，将元素组织成一个相互链接的链表，每个元素包含指向前一个元素和后一个元素的指针。
72. 操作系统绑定（Operating System Abstraction Layer）：提供一组API函数，简化程序员编写与具体操作系统相关的代码。这使得程序可以跨不同的操作系统平台运行而无需修改代码。
73. 字节顺序（Byte Order）：计算机处理多字节数据时的字节排列方式。主机字节顺序是大端模式或小端模式，取决于最高有效位（MSB）在哪个字节中。
74. 地址解析协议（ARP）：在TCP/IP网络中用于将IP地址映射到物理MAC地址的协议。ARP通常缓存和更新结果以加快下次查询。
75. 进程地址空间（Process Address Space）：进程在其执行期间可访问的虚拟内存区域集合。进程地址空间通常包含代码段、数据段、堆和栈。
76. 实时操作系统（Real-Time Operating System）：专门设计用于对硬实时性要求高的应用程序进行优化的操作系统。
77. 磁盘缓存（Disk Cache）：用于临时存储磁盘数据的内存区域，可以提高读写性能和响应速度。
78. 文件描述符表（File Descriptor Table）：一个进程使用的表格，其中列出了该进程已打开或创建的文件、套接字等I/O 资源。每个项都与一个唯一整数值（文件描述符）相关联。
79. 系统调用接口（System Call Interface）：允许进程通过标准化的API函数向操作系统请求服务的接口。系统调用使进程可以访问底层资源，例如文件、网络和内存等。



55. Decoder: A program or device that decompresses and restores the original data from the encoded data.
56. Interprocess Communication: A mechanism for passing information and sharing resources between different processes.
57. Thread Synchronization: A mechanism for coordinating multiple threads to access shared resources.
58. Associative Array: A data structure of key-value pairs, where each key uniquely corresponds to a value.
59. Simulator: A program that can simulate the behavior of computer hardware or software.
60. Terminal: A device that allows the computer operator to interact with the computer, or a remote login session.
61. Dynamic Link Library: A code library that can be used by multiple programs at the same time, usually loaded at runtime.
62. Protocol Stack: A series of implementations of computer network protocols, used to transmit data between computers or networks.
63. Database Management System: A software system that manages databases.
64. Memory-Mapped File: A mechanism that allows a program to directly use a disk file as part of its memory address space.
65. Profiling: A process of measuring and optimizing the performance of a program.
66. Debugger: A tool for debugging programs, helping programmers to find and fix errors.
67. Spin Lock: A type of thread synchronization mechanism, used to protect shared resources among multiple threads.
68. Shared Memory: A type of interprocess communication mechanism, allowing different processes to share the same block of memory.

38. OS Virtualization: A type of virtualization technology that allows multiple operating systems to share the same physical computer resources.
39. Deadlock: A common problem in concurrent programs, when two or more processes cannot continue to execute because each process is waiting for the other process to release a mutex lock.
40. Device Driver: A software program that manages computer system hardware devices.
41. File Descriptor: An integer value that identifies an open file, socket or other I/O resource.
42. Cluster: Also known as a block, it is the smallest unit of data used by the file system, usually between 2KB and 8KB.
43. Virtual File System: An abstraction that unifies different file systems into a single file hierarchy, and provides a set of common API for file management.
44. Debugging Output: A function call or statement that outputs status information, error messages and debug information during the debugging process.
45. Audio Codec: A program or device that converts audio signals into digital formats and compresses and decompresses them.
46. Paging Mechanism: A type of memory management technique that divides physical memory into fixed-size pages, and uses page tables to map virtual memory to physical memory.
47. Multithreading: A type of concurrent programming technique that allows multiple threads to execute simultaneously. This can improve program performance, responsiveness and resource utilization.
48. Code Injection: The process of adding, modifying or deleting instructions in a running process. It is usually used for debugging or malicious software attacks.
49. Preemptive Scheduling: A type of process scheduling policy that allows the operating system to forcibly allocate CPU to another higher-priority process at some point during the execution of a process.
50. Message Queue: A mechanism for transferring data and information between processes. Message queues are usually a specific type of kernel object.
51. Process State: The state that indicates the current activity of a process, such as running, waiting for I/O, sleeping, ready, etc.
52. Virtual Device: A type of software device that does not require physical hardware and can implement functions similar to real devices.
53. Thread Library: A set of API functions that help programmers develop multithreaded applications.
54. Bit Field: A technique that uses fewer bits to store and access data. It packs multiple fields into single bytes or words as bits, saving memory space.
55. Heap Memory: An area used for dynamic memory allocation. Heap memory is usually one of the largest memory areas available to a program.
56. External Sorting: Algorithms and techniques for sorting large amounts of data on disk files.
57. Internal Sorting: Algorithms and techniques for sorting data in computer memory.
58. Debug Symbols: Symbol tables generated by compilers to help debuggers track context information when variables and function calls are made.
59. I/O Multiplexing: A type of concurrent programming technique that allows multiple I/O events to be handled simultaneously in a single thread.
60. Buffer Overflow: A type of security vulnerability that occurs when a program writes too much data or invalid data to a buffer, possibly overwriting other important data or code in memory.
61. Anonymous Pipe: A type of data transfer method used for interprocess communication.
62. Breakpoint: A setting supported by debuggers that pauses the program when it reaches that point, allowing programmers to view the status of variables, memory or function calls.
63. Integer Overflow: A similar security vulnerability to buffer overflow, which occurs when an arithmetic operation results in an integer that the computer cannot represent.
64. Address Space: The set of virtual addresses that a process can access during its execution. The address space typically contains code, data, heap and stack segments.
65. Sleep State: A type of power management feature that puts the computer into a lower power mode to save energy and extend battery life.
66. Fault Handler: A program or module that manages hardware or software errors and exceptions in the system.
67. Thread Control Block: A data element or record that manages thread state and context information.
68. Round Robin: A common type of process scheduling algorithm that assigns each process a time slice, and switches to the next ready process at the end of each time slice.
69. Simple Network Management Protocol (SNMP): A standard protocol for network management, allowing administrators to monitor the performance and health of devices and applications on the network.
70. System Clock: The internal clock used by the computer system to keep track of the current time and date. The system clock is usually driven by a crystal oscillator or battery-backed.
71. Doubly Linked List: A type of data structure that organizes elements into a linked list, where each element contains pointers to the previous and next elements.
72. Operating System Abstraction Layer: A set of API functions that simplify programmers' writing of code that is specific to a particular operating system. This allows programs to run across different operating system platforms without modifying code.
73. Byte Order: The way bytes are arranged when the computer processes multi-byte data. The host byte order is either big-endian or little-endian, depending on which byte contains the most significant bit (MSB).
74. Address Resolution Protocol (ARP): A protocol used in TCP/IP networks to map IP addresses to physical MAC addresses. ARP usually caches and updates results to speed up subsequent queries.
75. Process Address Space: The set of virtual memory regions that a process can access during its execution. The process address space typically contains code, data, heap and stack segments.
76. Real-Time Operating System (RTOS): An operating system specially designed for applications that have high hard real-time requirements.
77. Disk Cache: A memory area used to temporarily store disk data, which can improve read/write performance and response speed.
78. File Descriptor Table: A table used by a process that lists the files, sockets and other I/O resources that the process has opened or created. Each entry is associated with a unique integer value (file descriptor).
79. System Call Interface: An interface that allows processes to request services from the operating system through standardized API functions. System calls allow processes to access low-level resources, such as files, network and memory.









