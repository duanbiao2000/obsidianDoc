---
aliases: 
categories: 
important: false
tags:
  - Mindset
---


**核心目标：** 理解 LeetCode 题目的常见解题模式（套路），以便更快地识别问题类型并应用合适的算法。

1.  **数组/字符串相关模式:**
    *   **双指针 (Two Pointers):** 用两个“手指”（指针）在数组或字符串上移动，通常一个快一个慢，或者一头一尾，来查找、比较或定位。
    *   **滑动窗口 (Sliding Window):** 维护一个“窗口”在数据上移动，窗口大小可变或固定，用来处理连续子序列的问题（如找最短/最长/符合条件的子串/子数组）。
    *   **前缀和 (Prefix Sum):** 提前计算好从头开始到每个位置的累加和，这样就能瞬间（O(1)）算出任意区间的和。
    *   **哈希表 (Hash Table):** 利用其快速查找（近 O(1)）的特性，来统计频率、判断元素是否存在、建立映射关系等。

2.  **链表模式:**
    *   **链表操作:** 核心是处理 `next` 指针，进行节点的增、删、改、查，以及处理环、合并、反转等。
    *   **反转链表:** 改变 `next` 指针的指向，使链表顺序颠倒，是很多链表题的基础。

3.  **栈模式 (Stack):**
    *   **基本栈操作:** 利用其“后进先出”（LIFO）的特性，解决括号匹配、表达式求值、逆序处理等问题。
    *   **单调栈:** 栈内元素保持单调（递增或递减），用于解决“下一个更大/更小元素”、矩形面积等问题。

4.  **递归与回溯模式 (Recursion & Backtracking):**
    *   **递归:** 函数自己调用自己，将大问题分解为结构相同的子问题来解决（如树的遍历）。
    *   **回溯:** “走不通就退回来”，系统性地搜索问题的所有可能解，常用于排列、组合、子集、棋盘等问题。

5.  **树模式 (Tree):**
    *   **树的遍历:** 按特定顺序（前序、中序、后序、层序）访问树的所有节点，是树相关问题基础。
    *   **二叉搜索树 (BST):** 利用其左<根<右的特性，高效地查找、插入、删除元素。
    *   **树的构造:** 根据遍历序列（如前序+中序）还原树的结构。

6.  **堆模式 (Heap / Priority Queue):**
    *   **堆操作:** 维护一个优先队列，快速找到最大/最小元素（Top K 问题），或用于需要动态排序的场景。

7.  **动态规划模式 (Dynamic Programming - DP):**
    *   **核心思想:** 将复杂问题分解为更小的重叠子问题，通过记录子问题的解（通常用数组或哈希表，即 `dp` 表）来避免重复计算，从而找到最优解。适用于求最值、计数、可行性等问题（如爬楼梯、背包问题、最长子序列）。

8.  **图模式 (Graph):**
    *   **图的遍历 (DFS/BFS):** 深度优先搜索（DFS，像走迷宫一条路走到黑再回溯）和广度优先搜索（BFS，像水波纹一层层扩散，常用于找最短路径）。
    *   **拓扑排序:** 用于有向无环图（DAG），确定任务的执行顺序（如课程安排）。

9.  **贪心算法模式 (Greedy):**
    *   **核心思想:** 每一步都做出当前看起来最好的选择，期望最终得到全局最优解。不一定总能得到最优解，但对某些问题有效（如分发饼干、跳跃游戏）。

10. **位操作模式 (Bit Manipulation):**
    *   **核心思想:** 直接在二进制位上进行运算（与、或、异或、移位等），通常非常高效，用于处理整数相关、状态压缩等特定问题。

11. **二分查找模式 (Binary Search):**
    *   **核心思想:** 在**有序**数据中，每次将搜索范围缩小一半，极大地提高查找效率（O(log n)）。适用于查找特定值、满足条件的边界等。

12. **其他模式:**
    *   **模拟 (Simulation):** 按照题目描述的逻辑和过程，直接用代码实现。
    *   **排序 (Sorting):** 利用排序算法或自定义比较函数来解决问题。
    *   **数学 (Math):** 运用数学知识、公式或技巧。
    *   **设计 (Design):** 实现特定的数据结构或满足特定接口要求（如 LRU Cache）。

