
## **B+树的特征v**

B+树有以下几个重要的特征：

*   **自平衡 (Self-Balancing)**: B+树在插入或删除操作时会自动调整树的结构，确保树的高度保持在一个较小的范围内，从而保证查找、插入和删除的效率。
*   **有序 (Ordered)**: B+树中的每个节点都按照关键字的顺序排列，这使得查找和范围查询变得更加高效。
*   **多重索引 (Multi-Level Indexing)**: B+树中的每个节点都包含一个索引，这个索引指向下一个节点中的关键字。这使得查找和范围查询更加高效。
*   **叶子节点 (Leaf Nodes)**: B+树中的所有叶子节点都包含完整的关键字和数据，这使得查找和范围查询更加高效。
*   **非叶子节点 (Non-Leaf Nodes)**: B+树中的非叶子节点只包含索引和指向下一个节点的指针，这使得查找和范围查询更加高效。

这些特征使得B+树成为一个非常高效的数据结构，特别是在大型数据库和文件系统中。

## 分段锁
[Java 中 ConcurrentHashMap 1.7 和 1.8 之间有哪些区别？ - Java 热门面试题 200 道 - 面试鸭 - 程序员求职面试刷题神器](https://www.mianshiya.com/bank/1860871861809897474/question/1780933294813114369)
**分段锁**（Segment Lock）是ConcurrentHashMap 1.7版本中使用的锁机制。它将HashMap分成多个**段**（Segment），每个段是独立的，可以并发访问不同的段。每个段都有一个锁，通过继承ReentrantLock类来进行加锁。这样可以提高并发度，最大限度地减少锁的竞争。

在JDK 1.7中，ConcurrentHashMap的数据结构是**数组+链表**，每个段都是一个HashMap实例。段的数量默认是16个，最大限度地减少了锁的竞争。

例如，如果有16个线程要访问ConcurrentHashMap，理论上每个线程可以访问一个段，而不需要竞争锁。

**基于CAS的扩容**是ConcurrentHashMap 1.8版本中使用的扩容机制。它使用**比较并交换**（CAS）操作来扩容HashMap。

当HashMap需要扩容时，会通过CAS操作来尝试分配新的空间。具体步骤如下：

1. 计算新空间的大小和索引。
2. 使用CAS操作尝试分配新空间，如果成功，则返回true。
3. 如果CAS操作失败，则说明有其他线程正在扩容，需要等待。
4. 等待后再次尝试分配新空间。

这种基于CAS的扩容机制可以避免锁的竞争，提高并发度。

在JDK 1.8中，ConcurrentHashMap的扩容过程如下：

1. 当HashMap需要扩容时，会通过CAS操作尝试分配新的空间。
2. 如果CAS操作成功，则返回true，继续扩容。
3. 如果CAS操作失败，则返回false，需要等待。
4. 等待后再次尝试分配新空间。

这种基于CAS的扩容机制可以提高并发度，减少锁的竞争。

**LongAdder**是Java中一个用于高并发环境下的计数器类，它的思想是通过**分解**和**累加**来实现高并发度的计数。

LongAdder的思想是将计数器分解成多个小的计数器，每个小计数器都有自己的值，当多个线程同时更新计数器时，每个线程只更新自己的小计数器，而不是直接更新总计数器。这样可以避免锁的竞争，提高并发度。

LongAdder的工作原理如下：

1. 将计数器分解成多个小的计数器，每个小计数器都有自己的值。
2. 当多个线程同时更新计数器时，每个线程只更新自己的小计数器。
3. 每个线程更新自己的小计数器后，会将自己的值累加到总计数器中。
4. 当所有线程都更新完自己的小计数器后，总计数器的值就是最终的计数值。

LongAdder的思想可以应用于多个场景，例如：

* 高并发环境下的计数器
* 多线程环境下的计数器
* 需要高并发度的计数器

LongAdder的优势包括：

* 高并发度
* 减少锁的竞争
* 提高系统的吞吐量

LongAdder的缺点包括：

* 增加了内存的使用量
* 增加了计算的复杂度

## 泊松分布

**泊松分布与红黑树的关系**

泊松分布是概率论中的一种分布，用于描述在单位时间内发生的事件的数量。泊松分布的参数是平均值λ（lambda），它代表单位时间内发生事件的平均次数。

在 HashMap 的源码中，泊松分布被用于计算链表长度和红黑树的阈值。具体来说，泊松分布的参数λ被设置为0.75，这代表了哈希桶的平均填充率。

**泊松分布的计算**

泊松分布的概率密度函数是：

P(k) = (e^(-λ) \* (λ^k)) / k!

其中，k是事件的数量，e是自然对数的底数。

在 HashMap 的源码中，泊松分布的参数λ被设置为0.75。因此，泊松分布的概率密度函数可以计算为：

P(k) = (e^(-0.75) \* (0.75^k)) / k!

**泊松分布与红黑树的关系**

泊松分布被用于计算链表长度和红黑树的阈值。具体来说，泊松分布的参数λ被设置为0.75，这代表了哈希桶的平均填充率。

当哈希桶的填充率大于0.75时，链表长度大于8，红黑树就会被创建。反之，当哈希桶的填充率小于0.75时，链表长度小于6，红黑树就会被销毁。

**泊松分布的好处**

泊松分布的好处在于它可以提供一个合理的阈值来决定是否创建红黑树。泊松分布的参数λ可以根据哈希桶的平均填充率来调整，从而确保红黑树的创建和销毁是合理的。

如果泊松分布的参数λ被设置为一个较大的值，例如1.0，则红黑树的创建和销毁会更加频繁。这可能会导致性能损失，因为红黑树的创建和销毁都需要额外的时间和资源。

如果泊松分布的参数λ被设置为一个较小的值，例如0.5，则红黑树的创建和销毁会更加少。这可能会导致性能损失，因为哈希桶的填充率可能会过低，导致哈希冲突。

因此，泊松分布的参数λ被设置为0.75是一个合理的选择，因为它可以提供一个合理的阈值来决定是否创建红黑树。

[Java 中有哪些集合类？请简单介绍 - Java 热门面试题 200 道 - 面试鸭 - 程序员求职面试刷题神器](https://www.mianshiya.com/bank/1860871861809897474/question/1780933294699868162)

[数据库的脏读、不可重复读和幻读分别是什么？ - Java 热门面试题 200 道 - 面试鸭 - 程序员求职面试刷题神器](https://www.mianshiya.com/bank/1860871861809897474/question/1780933295496785922)
**脏读、不可重复读和幻读的区别**

脏读（Dirty Read）、不可重复读（Non-repeatable Read）和幻读（Phantom Read）是数据库隔离级别下可能发生的问题。

*   脏读：一个事务读到了另一个事务未提交的数据，如果该事务最终回滚，那么读取的数据就是不一致的。
*   不可重复读：同一事务，多次读取数据，由于其它事务的提交导致多次读取的值不一样。
*   幻读：同一事务，执行相同的查询语句，由于其它事务的插入导致返回的结果集不同。

这些问题都是由于事务之间的冲突导致的，不可重复读和幻读都是由于事务之间的读写冲突导致的。

## MySQL存储引擎

## 覆盖索引

## 索引类型
以下是扩展知识中的 4 点内容：

1. **B+tree 索引**：B+tree 是 MySQL 中最常用的索引类型。它使用平衡树结构来存储索引数据，适用于范围查询和排序。
2. **哈希索引**：哈希索引基于哈希算法，将索引列的值转换为哈希值，然后通过哈希表来进行快速的等值查询。主要用于 Memory 引擎。查找速度非常快，但不支持范围查询，只适用于精确匹配查询。
3. **倒排索引**：用于对文本字段进行全文搜索，允许在文本数据中进行关键字搜索和模糊匹配。
4. **R-树索引**：空间索引用于处理空间数据，如地理位置和几何形状。MySQL 提供了专门的空间索引类型，可以用于空间数据的查询和分析。

**索引下推 (Index Condition Pushdown, ICP) 的定义和目的**
索引下推是一种减少回表查询，提高查询效率的技术。它允许 MySQL 在使用索引查找数据时，将部分查询条件下推到存储引擎层过滤，从而减少需要从表中读取的数据行，减少了 IO。

**索引下推的应用范围**
索引下推适用于联合索引，减少回表次数，提高查询效率。它可以将需要在 Server 层做的筛选操作下推到存储引擎层。

**索引下推的例子**
例如，假设有一个表 `student`，有一个联合索引 `age` 和 `name`。如果执行以下查询：
```sql
SELECT * FROM student WHERE age = 18 AND name LIKE "%丽%";
```
若 `age` 存在二级索引，索引下推可以减少回表次数，提高查询效率。

**索引下推的注意点**
索引下推在 MySQL 5.6 及以后的版本支持，InnoDB 和 MyISAM 这两个存储引擎都生效。如果查询中引用了子查询索引下推可能不会生效，具体看 explain。

**聚簇索引和非聚簇索引的区别**

聚簇索引和非聚簇索引是 MySQL InnoDB 引擎中的两种索引类型。

*   **聚簇索引**：
    *   叶子节点存储完整的数据行。
    *   每个表只能有一个聚簇索引。
    *   通常是主键索引。
    *   支持范围查询和排序。
    *   优点：查询速度快，因为数据直接在叶子节点上。
    *   缺点：插入和更新时的代价大，可能会调整存储的位置。
*   **非聚簇索引**：
    *   叶子节点存储的是主键和索引列。
    *   可以有多个非聚簇索引。
    *   需要通过回表操作才能访问完整数据。

**回表的定义**

回表是指在非聚簇索引中，需要通过索引列找到主键值，然后再使用主键索引找到完整的数据。这个过程是必要的，因为非聚簇索引只存储索引列和主键值，而不存储完整的数据。

最左前缀原则是指在建立联合索引时，查询条件必须按照索引的顺序从左到右匹配，才能有效利用索引。也就是说，如果索引是 (a, b, c)，那么查询条件必须是 `where a = ? and b = ? and c = ?`，而不能是 `where c = ? and a = ? and b = ?`。

例如，在上面的例子中，建立了联合索引 (name, age, id)，但是查询条件是 `select * from user where age = 10 and id = 1;`，这就不符合最左前缀原则，因为 age 不是最左边的列。因此，索引就失效了。

最左前缀原则的原因是因为索引是按照从左到右的顺序存储的，如果不按照顺序匹配，索引就不能有效利用。

**RocketMQ** 是一个分布式消息中间件系统，用于处理大规模数据的实时处理和消息队列。它提供高性能、低延迟的服务发现和路由管理功能，适合于消息队列的需求。

**NameServer 和 Zookeeper 的对比**：

* **设计简洁度**：NameServer 设计相对简单，专门用于 RocketMQ 的需求，而 Zookeeper 是一个通用的分布式协调系统。
* **高可用性**：NameServer 是无状态的，多个实例之间可以通过 DNS 或 VIP 进行负载均衡，天然具备高可用性。Zookeeper 是一个强一致性系统，对节点之间的同步有严格要求，在某些极端情况下可能受到影响。
* **性能**：NameServer 只处理简单的配置和路由信息，不涉及复杂的状态同步和一致性协议，性能更高。Zookeeper 的写入是不可扩张的，压力都打在 Leader 节点上，不好扩展。
* **依赖性**：使用自研的 NameServer 可以降低对外部系统的依赖，简化系统架构，减少维护复杂度。

## B+树
**B+树的优势**

B+树是一种自平衡多叉树，具有以下几个显著优势：

1. **高效的查找性能**：B+树的查找时间复杂度为 O(log n)，能够保证在大数据量情况下也能有较快的响应时间。
2. **磁盘 I/O 次数少**：B+树的非叶子节点仅保存主键或索引值和页面指针，使得每一页能容纳更多的记录，因此内存中就能存放更多索引，容易命中缓存，使得查询磁盘的 I/O 次数减少。
3. **范围查询能力强**：B+树的叶子节点通过链表连接，从根节点定位到叶子节点查找到范围的起点之后，只需要顺序扫描链表即可遍历后续的数据，非常高效。

这些优势使得 B+树成为数据库系统中一种非常有效的索引结构。

![image.png](https://cdn.jsdelivr.net/gh/duanbiao2000/BlogGallery@main/picture/202412111455455.png)

**B树和B+树的区别**

B树和B+树都是用于数据库索引的树形结构，但它们有以下几个关键区别：

1. **数据存储位置**：
 * B树：所有节点都存储数据。
 * B+树：非叶子节点仅存储主键或索引值和页面指针，数据存储在叶子节点中。
2. **叶子节点连接方式**：
 * B树：叶子节点之间不连接。
 * B+树：叶子节点之间通过链表连接，形成有序的双向链表。
3. **范围查询能力**：
 * B树：只能通过中序遍历的方式进行查找。
 * B+树：可以通过遍历相邻的叶子节点进行范围查询。
4. **磁盘 I/O 次数**：
 * B树：由于所有节点都存储数据，磁盘 I/O 次数较高。
 * B+树：由于非叶子节点仅存储主键或索引值和页面指针，磁盘 I/O 次数较低。

这些区别使得 B+树比 B树更适合用于数据库索引。

