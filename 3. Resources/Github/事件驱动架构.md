---
createdAt: 2024-11-11 10:26
categories:
  - Design
tags:
  - Creative/Github
  - Creative/Tutorial
aliases: 📚 微服务大师课-深入事件驱动架构全攻略
---

通过事件（比如订单创建、付款完成）来触发业务流程，各服务基于事件消息进行通信。

<!--more-->

[📚 微服务大师课:深入事件驱动架构全攻略_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1nEmkYmEVc/)

## 术语

> [!abstract]
> 以下是视频中提到的关键名词和术语解释：
>
> 1. **Microservices（微服务）**\
>    一种架构风格，将应用程序分解为多个独立、可部署的小服务，每个服务负责特定的业务功能。这些服务可以独立开发、部署和扩展。
>
> 2. **Event-Driven Architecture（事件驱动架构）**\
>    系统架构中，通过事件（比如订单创建、付款完成）来触发业务流程，各服务基于事件消息进行通信。这种架构能提高系统的响应速度和独立性。
>
> 4. **GraphQL**\
>    一种数据查询语言，允许客户端请求特定的数据结构，提高了数据传输效率，并减少了不必要的数据加载。
>
> 5. **GRPC**\
>    一种高性能的远程过程调用（RPC）框架，支持多种编程语言，常用于服务之间高效的数据通信。
>
> 7. **Polyglot Persistence（多语言持久化）**\
>    在微服务架构中，允许不同的服务使用不同的数据库，以便选择最佳的数据存储解决方案来满足特定的业务需求。
>
> 8. **CQRS (Command Query Responsibility Segregation)（命令查询职责分离）**\
>    一种架构模式，将数据修改操作（命令）与查询操作分离，适用于需要高扩展性的应用程序。
>
> 9. **Saga Pattern（Saga 模式）**\
>    一种用于管理分布式事务的模式，将事务分解为一系列小事务，并提供回滚机制来保证一致性。
>
> 10. **Circuit Breaker（断路器）**\
>     保护服务系统的一种模式，在服务不可用或出错时，自动切断请求，避免其他服务受到影响，并在条件允许时重新恢复连接。
>
> 11. **Bulkhead Pattern（舱壁模式）**\
>     一种设计模式，通过将资源隔离，防止故障蔓延到整个系统，从而提高系统的鲁棒性。
>
> 12. **Sidecar Pattern（副车模式）**\
>     在微服务旁增加一个"副车"进程或容器，以处理日志、监控、安全等辅助任务，从而简化主服务的开发和部署。
>
>
> 14. **Pub/Sub (Publish/Subscribe)（发布/订阅）**\
>     一种消息传递模式，发布者将消息发送到特定的主题（Topic），而订阅者只接收自己订阅主题的消息，实现松耦合通信。
>
> 15. **Message Queue（消息队列）**\
>     存储和传递消息的系统，确保消息按顺序到达并提供容错能力，是实现事件驱动架构的关键。
>
> 16. **Event Streaming（事件流）**\
>     一种处理实时数据流的架构模式，将不同事件流合并成统一的流，用于实时分析、处理和响应。
>
> 17. **Data Redundancy（数据冗余）**\
>     将数据副本存储在多个位置，确保即使一个服务数据出错或丢失，其他服务依然可以访问该数据。
>
> 18. **Asynchronous Processing（异步处理）**\
>     不等待任务完成即可返回响应的处理方式，适用于高并发场景，提高系统效率和响应速度。
>
> 19. **Scalability（可扩展性）**\
>     系统根据负载动态调整资源，以保证性能的能力。微服务通过水平扩展（增加节点）实现高扩展性。
>
> 20. **Compliance（合规性）**\
>     遵守数据保护、安全标准（如 GDPR），是处理敏感数据的微服务（如支付、身份验证）的重要要求。
>

## 消息队列

微服务架构中的队列（Queue）具有多种优点，以下是一些主要的优势：


> [!NOTE]
> 1. **异步处理**：队列允许服务之间进行异步通信，发送方可以将消息发送到队列中，而不需要等待接收方的处理完成。这提高了系统的响应性和吞吐量。
> 
> 2. **解耦合**：使用队列可以将服务之间的依赖关系减到最小。发送方与接收方不直接依赖，可以独立地进行开发和部署，降低了系统的复杂性。
> 
> 3. **流量控制**：队列可以对请求进行排队，从而防止系统被瞬时的大量请求淹没。这种流量控制机制可以保护后端服务不被过载。
> 
> 4. **负载均衡**：多个消费者可以从同一个队列中消费消息，从而实现负载均衡。这可以有效利用资源，提高处理能力。
> 
> 5. **故障恢复**：如果某个服务暂时不可用，消息仍然可以被保留在队列中，待服务恢复后再处理。这种机制提高了系统的可靠性。
> 
> 6. **消息持久化**：许多消息队列系统提供消息持久化功能，可以将消息存储在磁盘上，防止数据丢失。这对于重要的业务场景尤其重要。
> 
> 7. **可伸缩性**：使用队列可以使得微服务的伸缩变得更加灵活，可以根据负载动态添加或移除消费者。
> 
> 8. **监控和分析**：队列可以提供丰富的监控和统计信息，帮助开发团队分析系统性能和瓶颈，进而优化服务。
> 
> 9. **支持分布式系统**：在分布式环境中，队列可以帮助不同地理位置的服务进行有效的通信，促进微服务的分布式部署。


## 消息传递模式

在消息传递系统中，"pull"、"push" 和 "pub/sub" 是三种常见的消息传递模式。每种模式都有其特点和适用场景：


![image.png](https://cdn.jsdelivr.net/gh/duanbiao2000/BlogGallery@main/picture/202411111623265.png)

## 延迟队列

Delay queue（延迟队列）是一种特殊类型的消息队列，它允许用户在一定的延迟时间后才处理消息。这种机制在许多场景中非常有用，尤其是在需要控制消息处理时间的应用中。

> [!NOTE]
>延迟队列的工作原理
> 
> 1. **发送消息**：
>    - 生产者将消息发送到延迟队列，并指定一个延迟时间（例如，几秒钟或几分钟）。
> 
> 2. **存储消息**：
>    - 消息会被存储在队列中，直到达到指定的延迟时间。此时，消息仍然是不可见的，消费者无法读取。
> 
> 3. **处理消息**：
>    - 一旦延迟时间到达，消息将变为可见，消费者可以从队列中拉取并处理这些消息。
> 
> ### 特点与优点
> 
> - **控制处理时间**：允许开发者控制何时处理特定的消息，这对于某些业务逻辑非常重要，例如在订单处理系统中预留时间以确认订单。
>   
> - **减轻瞬时负载**：延迟处理某些消息可以帮助减轻系统在高峰期的负载，允许系统在正常负载下进行处理。
> 
> - **定时任务**：可以用作一种简化的定时任务调度机制，允许开发者在未来的某个时间点执行特定操作。
> 
> ### 适用场景
> 
> - **重试机制**：在处理失败的消息时，可以将其放入延迟队列，在一段时间后重试处理。
> 
> - **订单处理**：在电商系统中，延迟队列可以用于处理订单确认、取消等操作。
> 
> - **限流**：在需要对请求进行速率限制的系统中，延迟队列可以帮助平滑流量，提高系统稳定性。
> 
> - **事件通知**：在某些情况下，事件可能需要在延迟后才通知用户，例如促销活动开始前的提醒。
> 
> ### 实现
> 
> 许多消息队列系统和框架都支持延迟队列的功能，例如：
> 
> - **RabbitMQ**：通过使用延迟交换（Delayed Exchange）来实现。
> - **Kafka**：可以通过设置消息的过期时间，实现类似功能。
> - **Redis**：可以通过使用有序集合（Sorted Set）来实现延迟队列。
> - **AWS SQS**：支持延迟队列的功能，可以直接设置延迟时间。
> 
> 延迟队列是构建灵活和高效消息处理系统的有力工具，能够满足多种业务需求。
