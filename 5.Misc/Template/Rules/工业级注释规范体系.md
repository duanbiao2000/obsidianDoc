---
view-count: 8
---
# [[Industrial_Comment_Standards]] - 工业级注释协议

---

## 1. 需求级别协议 (RFC 2119)

使用标准动词定义注释的强制性：

- **MUST**: 公开 API (Public API) 必须包含完整 Docstring。
- **SHOULD**: 复杂算法、非直观逻辑应添加行内注释解释“为什么”。
- **MAY**: 显而易见的代码（如简单的 Getter/Setter）可不注释。

---

## 2. 规范选型矩阵 (Google vs. Meta)

| 维度 | Google 标准 (文档优先) | Meta/Facebook 标准 (意图优先) |
| :--- | :--- | :--- |
| **核心哲学** | 全面、自足、工具可解析 | 简洁、实用、聚焦“为什么” |
| **文档字符串** | 强制、结构化 (Args/Returns) | 可选、精简、自然语言 |
| **行内注释** | 辅助补充 | 主要沟通渠道 |
| **适用场景** | 开源库、核心框架、API 边界 | 业务快速迭代、性能关键路径 |

---

## 3. Google 结构化 Docstring 协议

### A. 模块级 (Module)
- **摘要**: 一句话说明文件职责。
- **背景**: 链接至设计文档/RFC。
- **示例**: 提供 `Typical usage example`。

### B. 类级 (Class)
- **职责**: 说明类的设计考量而非内部属性。
- **属性 (Attributes)**: 仅列出公开 (Public) 属性。

### C. 函数级 (Function) - 核心 I/O
- **Args**: 参数名、类型、含义、约束（如：范围 [1, 100]）。
- **Returns**: 返回值类型及边界情况（如：缺失时返回空字典）。
- **Raises**: 明确触发异常的条件。
- **SLA/Note**: 记录 P99 延迟、并发限制、Profile 结果。

---

## 4. Meta 行内注释协议 (Inline Logic)

- **核心禁令**: 禁止总结代码“在做什么” (What)。
- **核心要求**: 阐明“为什么”这样做 (Why) 及权衡 (Trade-offs)。

**示例对标：**
- **❌ 错误**: `items = [i for i in data if i.valid]  # 过滤有效项`
- **✅ 正确**: `items = [i for i in data if i.valid]  # 移除失效项以减少内存占用 (约节省 30%)`

---

## 5. 技术债与决策标记 (Tags)

| 标记 | 含义 | 要求 |
| :--- | :--- | :--- |
| **TODO** | 待办事项 | 必须标注关联 Issue ID 或负责人。 |
| **FIXME** | 已知缺陷 | 描述根因及临时避让方案。 |
| **HACK** | 补丁/变通 | 解释为什么不能用优雅方案，设定删除期限。 |
| **RFC-ID** | 架构决策 | 引用内部 RFC 文档，解释重大选型背景。 |

---

## 6. 执行检查清单 (Checklist)

- [ ] **API 边界**: 是否包含 Args/Returns/Raises 且工具可解析？
- [ ] **性能代码**: 是否标注了 Trade-off 和性能基准 (Benchmark)？
- [ ] **跨团队集成**: 边界条件（如闭区间/开区间）是否明确？
- [ ] **为什么**: 注释是否解释了“非此不可”的原因而非逻辑复述？
- [ ] **时效性**: 修改代码实现后，注释是否同步更新？

---

**最后更新: 2026-01-01**