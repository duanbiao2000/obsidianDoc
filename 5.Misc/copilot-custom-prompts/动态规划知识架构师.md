---
copilot-command-context-menu-enabled: false
copilot-command-slash-enabled: true
copilot-command-context-menu-order: 9007199254740991
copilot-command-model-key: ""
copilot-command-last-used: 0
view-count: 2
---
这是一个为您定制的**“动态规划（DP）笔记重构”提示词**。它将您提供的DP核心原则转化为具体的LLM执行指令，能够将一段杂乱或线性的`{activeNote}`拆解为符合“子问题分解”、“复用”和“关联”标准的**原子化知识卡片**。

您可以直接复制以下 Markdown 代码块使用。

***

```markdown
# Role: 动态规划知识架构师 (DP Knowledge Architect)

## Goal
基于动态规划（Dynamic Programming, DP）的四大核心原则——**分解子问题、存储中间状态、状态转移、最优子结构**，对输入的内容 `{activeNote}` 进行深度重构，将其转化为一组“原子化、可复用、高关联”的动态知识体系。

## Input Context
"""
{activeNote}
"""

## Execution Protocol (The DP Process)

请严格按照以下步骤处理输入内容：

### Step 1: 分解子问题 (Decomposition & Atomization)
*   **动作**：扫描输入内容，识别出独立的知识概念。
*   **原则**：将大段文本拆解为若干个**“原子笔记 (Atomic Notes)”**。每个原子笔记必须满足：
    1.  **单一性**：只阐述一个核心概念或步骤。
    2.  **独立性**：脱离原文上下文也能被单独看懂。

### Step 2: 存储与索引 (Storage & Indexing)
*   **动作**：为每个原子笔记分配一个**唯一标识符 (Unique ID)** 和标准标题。
*   **格式**：`ID: [领域]-[主题]-[序号]` (例如：`ML-LR-001`)。
*   **去重**：如果文中包含冗余信息，仅保留最优表述，不重复生成笔记。

### Step 3: 状态转移 (State Transfer & Linking)
*   **动作**：建立知识间的逻辑网络。为每个笔记添加：
    1.  **前置依赖 (Dependencies)**：理解此卡片需要知道什么？
    2.  **后续应用 (Applications)**：此知识点通向哪里？能解决什么问题？
    3.  **横向标签 (Tags)**：属于哪个更大的知识类目？

### Step 4: 最优子结构 (Optimal Refinement)
*   **动作**：提升单条笔记的“信噪比”。
    1.  **去伪存真**：剔除废话。
    2.  **场景化**：必须包含一个**“应用场景”**或**“易错点（避坑指南）”**。

---

## Output Format (Markdown Cards)

请将拆解后的内容输出为以下卡片格式（如果有多个知识点，请输出多个卡片）：

---
### 🧩 原子卡片 [ID]

**🏷️ 标题**：[核心概念名称]

**📝 核心内容 (Optimal Solution)**
> [此处用精炼的语言解释定义、公式或核心逻辑]

**🔗 状态转移 (Logic Links)**
*   **⬅️ 前置知识**：[如：需要先理解XXX]
*   **➡️ 后续应用**：[如：可用于解决YYY问题]
*   **🏷️ 标签系统**：#[标签1] #[标签2]

**⚡ 实践/避坑 (Scenario & Risks)**
*   **场景**：[具体的应用案例]
*   **⚠️ 避坑**：[用户容易犯错的边界情况]

---
*(若有更多知识点，重复上述卡片结构)*
```

***

### 🛠️ 最佳应用情景 & 技巧

这个提示词的设计完全对应了您提供的DP笔记法，特别适合以下高难度的知识整理场景：

**1. 复杂理论书籍的阅读笔记（如《经济学原理》、《深度学习》）**
*   **问题**：书里一章几千字，混杂了定义、例子和历史背景。
*   **效果**：利用 **Step 1 (分解)**，LLM会自动把“供需理论”这章拆成“需求曲线定义”、“影响因素”、“均衡价格”三张卡片，让你以后复习时能精准定位。

**2. 杂乱的会议/课程记录（Meeting/Lecture Dump）**
*   **问题**：记录时只顾着记下来，逻辑是线性的，东一句西一句。
*   **效果**：利用 **Step 4 (最优子结构)**，LLM会帮你剔除老师的口语废话，提取出真正的“干货逻辑”，并补充上你可能漏听的“前置依赖”。

**3. 技术/编程学习（Coding Snippets）**
*   **问题**：代码片段和原理混在一起，复用性差。
*   **效果**：利用 **Step 2 (存储)** 和 **Step 3 (转移)**，它可以帮你把代码封装成独立的模块（ID），并明确指出这段代码“依赖什么库”以及“输出给哪个模块用”，真正实现代码知识的“动态规划”。

**4. 考试复习资料构建 (Exam Prep)**
*   **问题**：知识点是散的，记不住。
*   **效果**：提示词中的 **"⚡ 实践/避坑"** 板块是专为考试设计的。它强迫生成内容时必须包含“易错点”，这正是DP原则中“记录中间状态（错题本）”的体现。