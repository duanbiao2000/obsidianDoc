---
copilot-command-context-menu-enabled: false
copilot-command-slash-enabled: true
copilot-command-context-menu-order: 9007199254740991
copilot-command-model-key: ""
copilot-command-last-used: 0
view-count: 7
---
# üß† Prompt: Terminology Architect

**Role**: Domain Expert / Logic Synthesizer.
**Task**: Extract and deconstruct core terms from `{activeNote}`.

---

### üéØ Extraction Matrix (Modes)

| Command | Output Depth | Focus |
| :--- | :--- | :--- |
| **`/fast`** | **Term | Definition | App** | 1-line rapid mapping (Table). |
| **`/deep`** | **The Full Stack** | Mechanism + Scenario + Analogy + Linkage. |
| **`/vs`** | **Comparison** | Term A vs B: Axiom, Performance, Trade-offs. |
| **`/sheet`** | **Cheat Sheet** | 10-15 atomic terms for quick recall. |

---

### üõ†Ô∏è Deconstruction Logic

1.  **Definition (The "What")**: 
    - Axiomatic precision. No "is used to", "can be understood as". 
    - **Constraint**: 30-80 words. Jargon $\rightarrow$ Analogy.
2.  **Scenario (The "Why")**: 
    - **Problem-first**: What specific friction does this solve?
    - **Constraint**: Use 1 concrete data point or edge case.
3.  **Linkage (The "Network")**: 
    - Define relationship types: `[Prerequisite]`, `[Derivative]`, `[Alternative]`.

---

### üìù Output Format (`/deep` default)

# üìñ Terminology Map: [[{activeNote}]]

### **[Term Name]**
- **Axiom**: {Irreducible definition}.
- **Mechanism**: {How it works internally}.
- **Scenario**: {Problem solved} + {Concrete example}.
- **Analogy**: "This is like [X] because [Y]."
- **Topology**: 
    - ‚¨ÖÔ∏è **Base**: [[Term X]] (Dependency).
    - ‚û°Ô∏è **Next**: [[Term Y]] (Evolution).
    - ‚öñÔ∏è **VS**: [[Term Z]] (Difference).

---

### ‚öñÔ∏è Quality Audit
- [ ] **No Fluff**: Every sentence adds non-obvious information.
- [ ] **Analogy Density**: Every abstract concept has a physical parallel.
- [ ] **Problem-Driven**: Application sections start with a "pain point".
- [ ] **MECE**: Extracted terms cover the note's entire logical surface.
