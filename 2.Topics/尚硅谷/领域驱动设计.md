---
date: 2025-05-19 13:58
tags:
view-count: 3
---
## 🎯 DDD 核心概念：认知锚点库

---

### **第一层：基石概念** ★

|概念|压缩核心|符号|
|---|---|---|
|**DDD 本质**|业务模型驱动 → 代码结构反映业务 → 核心业务与技术分离|★|
|**四层架构**|Interface(请求适配) → Application(用例编排) → Domain(业务核心) → Infrastructure(技术细节)|★|
|**依赖方向**|高层(业务)→ 低层(技术)，通过接口依赖，实现控制反转|★|
|**实体(Entity)**|有唯一标识 + 生命周期，标识不变但属性可变|★|
|**值对象(VO)**|无标识，由属性定义相等性，应不可变|★|
|**聚合(Aggregate)**|一致性边界，通过聚合根管理内部对象|★|
|**聚合根(Root)**|聚合唯一入口，对外暴露行为，内部一致性守卫|★|
|**领域服务**|跨多个对象的业务逻辑，无法放入单个实体|★|
|**应用服务**|编排领域对象完成用例，管理事务，无核心业务逻辑|★|
|**仓储(Repository)**|聚合根获取/保存接口，隐藏存储细节，面向对象而非数据|★|
|**边界上下文**|模型使用范围，不同边界同概念可有不同含义|★|

---

### **第二层：问题 → 解决方案映射** △

|业务/架构问题|DDD 解决方案|关键机制|
|---|---|---|
|代码与业务脱节|领域模型驱动设计|实体+VO+聚合 内聚业务行为|
|业务逻辑散落各处|集中在 Domain 层|实体方法 + 领域服务|
|需求变更影响范围大|聚合边界限制影响范围|聚合 = 事务边界|
|技术变更影响业务|Domain 不依赖 Infrastructure|Repository 接口隔离|
|多人协作沟通障碍|统一的业务语言(Ubiquitous Language)|代码即文档，概念名=类名|
|复杂对象关系管理|聚合 + 聚合根|根管理内部一致性|
|跨对象业务逻辑混乱|领域服务|聚合根无法单独处理的逻辑|
|测试困难(技术耦合)|Domain 层业务逻辑独立测试|不依赖框架，纯 POJO 逻辑|
|服务拆分边界不清|边界上下文 → 微服务|业务语义而非技术导向|

---

### **第三层：四层架构详解**

```
Interface(接口层) ← 适配外部(Web/RPC/MQ消费)，请求→DTO转换
    ↓ (调用)
Application(应用层) ← 编排用例，事务管理，不含业务逻辑
    ↓ (调用)
Domain(领域层) ← ★★★ 核心业务逻辑，实体+VO+服务，无技术依赖
    ↓ (通过Repository接口)
Infrastructure(基础设施层) ← MyBatis/DB/消息队列，实现Repository
```

**各层职责与为什么**：

|层|职责|为什么独立？|处理什么易变性|
|---|---|---|---|
|Interface|请求响应、DTO转换、路由|外部接口类型多(Web/RPC/MQ)|接口形式、协议|
|Application|用例编排、事务、调度基础设施|用例流程是业务实现的形式|流程变化、工作流|
|Domain|实体、VO、聚合、业务规则|业务本质，最稳定最有价值|✓ 不应变（核心）|
|Infrastructure|数据库、框架、外部服务调用|技术实现细节频繁变化|DB类型、ORM、消息队列|

---

### **第四层：核心概念之间的关系**

```
聚合 = 一致性边界
  ├─ 聚合根(Entity) ← 外部唯一入口
  ├─ 其他Entity ← 只通过根访问
  └─ ValueObject ← 描述性属性(不可变)

业务流程实现 = 应用服务 + 领域对象
  ├─ 应用服务 ← 编排(创建、调用、保存)
  └─ Domain层
      ├─ 实体方法 ← 单个对象行为
      ├─ 领域服务 ← 多个对象协作
      └─ Repository接口 ← 获取/保存聚合

代码 → 数据 = Repository实现(DO转换)
  ├─ Domain: User(业务对象，有行为)
  ├─ Repository实现: User ←→ UserDO(转换)
  └─ Infrastructure: UserMapper(SQL映射)
```

---

### **第五层：实战映射 - MyBatis + DDD**

#### **Repository ≠ Mapper 的本质区别** ❗

|对比维度|Repository(Domain)|Mapper(Infrastructure)|
|---|---|---|
|**面向**|聚合根(业务对象)|数据表/数据行(POJO)|
|**定义位置**|Domain 层(接口)|Infrastructure 层(具体实现)|
|**关心**|如何获取/保存业务对象|如何映射 SQL 和数据|
|**调用者**|Application 层|Repository 实现类|
|**VO 处理**|直接作为对象属性|转换为原始类型存库|
|**例子**|`findById(id): User`|`selectById(id): UserDO`|

**映射关系**：

```
Interface 层              Application 层              Domain 层              Infrastructure 层
┌──────────────┐        ┌──────────────────┐        ┌────────────────┐    ┌──────────────────┐
│ Controller   │───────→│ RegisterUserCase │───────→│ UserRepository │◄───│ UserRepositoryImpl│
│ (请求/响应)  │        │ (编排用例)       │        │ (接口)         │    │ (使用 Mapper)    │
└──────────────┘        └──────────────────┘        └────────────────┘    └──────────────────┘
                                                                                    │
                                                                                    ↓
                                                                          ┌──────────────────┐
                                                                          │ UserMapper       │
                                                                          │ (MyBatis Mapper) │
                                                                          └──────────────────┘
                                                                                    │
                                                                                    ↓
                                                                          ┌──────────────────┐
                                                                          │ Database         │
                                                                          └──────────────────┘
```

**代码流** (Python 示例，跨语言通用逻辑)：

```python
# Domain 层：接口定义
class UserRepository(ABC):
    @abstractmethod
    def find_by_id(self, user_id: int) -> Optional['User']: pass
    
    @abstractmethod
    def save(self, user: 'User') -> None: pass

# Domain 层：业务对象
class User:  # 实体，聚合根
    def __init__(self, id: int, name: str, email: 'Email'):
        self.id = id
        self.name = name
        self.email = email  # VO
    
    def change_password(self, new_pwd: str) -> None:
        # 业务规则：密码长度验证等
        if len(new_pwd) < 8:
            raise ValueError("Password too short")
        self.password = new_pwd

class Email:  # 值对象(VO)，不可变
    def __init__(self, value: str):
        if '@' not in value:
            raise ValueError("Invalid email")
        self._value = value
    
    def get_value(self) -> str:
        return self._value

# Application 层：用例编排
class RegisterUserUseCase:
    def __init__(self, repo: UserRepository):
        self.repo = repo
    
    def execute(self, user_id: int, name: str, email_str: str):
        # 1. 创建领域对象
        email = Email(email_str)  # VO 创建，自带验证
        user = User(user_id, name, email)
        
        # 2. 业务处理(如果有)
        user.activate()  # User 实体行为
        
        # 3. 通过 Repository 保存(不关心具体实现)
        self.repo.save(user)
        
        # 4. 其他基础设施操作
        # email_service.send_activation(email.get_value())

# Infrastructure 层：Mapper 定义
class UserMapper:  # MyBatis 等 ORM 映射
    def select_by_id(self, user_id: int) -> Optional[Dict]:
        # SQL: SELECT id, name, email FROM users WHERE id = ?
        pass
    
    def insert(self, user_do: Dict) -> None:
        # SQL: INSERT INTO users (id, name, email) VALUES (?, ?, ?)
        pass

# Infrastructure 层：Repository 实现
class UserRepositoryImpl(UserRepository):
    def __init__(self, mapper: UserMapper):
        self.mapper = mapper
    
    def find_by_id(self, user_id: int) -> Optional[User]:
        user_do = self.mapper.select_by_id(user_id)
        if not user_do:
            return None
        # DO → Domain 转换
        return User(
            id=user_do['id'],
            name=user_do['name'],
            email=Email(user_do['email'])
        )
    
    def save(self, user: User) -> None:
        # Domain → DO 转换
        user_do = {
            'id': user.id,
            'name': user.name,
            'email': user.email.get_value()
        }
        self.mapper.insert(user_do)
```

---

### **第六层：反常识与陷阱** ❗

|错误认知|真相|原因|
|---|---|---|
|❗ Repository 就是 Mapper|Repository 是接口(Domain)，Mapper 是实现(Infrastructure)|分层解耦的核心|
|❗ DDD 适合所有项目|仅适合复杂业务系统|简单 CRUD 成本>收益|
|❗ 应用服务 = Service 层|应用服务是用例编排，普通 Service 是胖业务类|传统三层常混淆|
|❗ 聚合越小越好|聚合应以一致性边界为界，大小没有固定标准|过度设计导致复杂度上升|
|❗ 值对象就是不可变 POJO|VO 应有领域含义，包含验证/业务规则|防止贫血模型|
|❗ 所有实体都需 Repository|仅聚合根需要 Repository，其他实体通过根访问|避免过度复杂化|
|❗ 边界上下文 = 微服务|一个服务可含多个边界上下文，一个上下文也可拆成多个服务|边界上下文是业务概念，服务是部署单位|

---

### **第七层：决策流程树**

```
设计新功能？
├─ 是否跨多个聚合？
│  ├─ 否 → 实体方法内实现
│  └─ 是 → 领域服务实现
│
├─ 是否是持久化需求？
│  ├─ 是 → Repository 接口定义 + Mapper 实现
│  └─ 否 → 值对象或普通类
│
├─ 是否需要对外提供能力？
│  ├─ 是 → 应用服务(编排 Domain + Infra)
│  └─ 否 → 内部逻辑，封装在 Domain
│
└─ 如何测试？
   ├─ 业务逻辑 → Domain 层纯单元测试(无依赖)
   ├─ 用例流程 → Application 层集成测试(mock Repository)
   └─ 数据访问 → Infrastructure 层集成测试(真实 DB)
```

---

### **第八层：三大陷阱及规避方案**

#### **陷阱 1: 贫血模型** ❗

```
❌ 错误：
class User:
    id: int
    name: str
    # 只有数据，没有行为

✓ 正确：
class User:
    id: int
    name: str
    
    def change_password(self, new_pwd: str):
        # 验证 + 业务规则
        if len(new_pwd) < 8:
            raise ValueError(...)
        self.password = new_pwd
```

#### **陷阱 2: 胖服务** ❗

```
❌ 错误：
class UserService:
    def register(self, ...):
        # 验证、创建、持久化、发邮件、日志...
        # 200+ 行代码混在一起

✓ 正确：
# Domain 层
class User:
    def validate(self): pass
    def activate(self): pass

# Application 层
class RegisterUserUseCase:
    def execute(self, ...):
        user = User(...)
        user.activate()  # Domain
        repo.save(user)  # Infra
```

#### **陷阱 3: 过度设计** ❗

```
❌ 陷阱：为简单 CRUD 设计 10+ 个聚合
✓ 原则：聚合大小以一致性边界为界，不追求最小粒度
```

---

### **第九层：快速诊断表**

|症状|诊断|处方|
|---|---|---|
|需求变更牵一发动全身|聚合边界不清|重新识别聚合边界|
|业务逻辑遍布各个 Service|贫血模型 + 胖服务|逻辑移入实体/VO|
|新人难以理解业务代码|缺乏统一语言(Ubiquitous Language)|代码概念名 = 业务用语|
|单元测试难以编写(技术耦合)|Domain 层依赖 Infrastructure|Repository 用接口，DI 注入|
|微服务边界不清，数据一致性问题|未用边界上下文指导拆分|以边界上下文而非表为拆分单位|
|同一概念在不同模块含义不同，冲突|边界上下文划分不明确|明确每个上下文的语言和模型|

---

### **第十层：学习路径**

**5 分钟速记**：四层架构 + 三个核心(实体/VO/聚合)

**15 分钟深化**：+Repository vs Mapper，+应用服务概念

**30 分钟精通**：+领域服务，+边界上下文，+决策树

**1 小时进阶**：+事件驱动，+CQRS/Event Sourcing，+微服务拆分

**AI 提问建议**：

- _"这个业务逻辑应该放在实体还是领域服务？"_
- _"我应该如何识别这个系统的聚合边界？"_
- _"Repository 实现时如何处理 VO 与数据库字段的映射？"_
- _"这两个模块应该在同一个边界上下文吗？"_

---

**生成时间**：2025-12-14 | **版本**：1.0 | **用途**：架构设计/代码审查/系统重构