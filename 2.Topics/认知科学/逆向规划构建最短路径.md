---
view-count: 9
update: 2026-01-06 12:40
related:
  - "[[成果导向的时间管理系统]]"
  - "[[任务规划器-追求更有规划]]"
  - "[[The Quiet Power of Looking Back]]"
  - "[[算法设计核心概念梳理]]"
  - "[[文档化Planning]]"
---

**Backward Planning. Build the Shortest Path.**

你想要一个结果。你需要一条路径。
你可以盲目搜索，也可以有计划地前进。
这关乎算法，也关乎你的思考方式。

---

## 1. 给问题命名：从想法到 Algorithm

把规划当成一次 **graph search**。

| 比喻说法 | Algorithm 术语      | 含义                   |
| ---- | ----------------- | -------------------- |
| 规划问题 | Graph search      | 状态是节点，动作是边。          |
| 起点   | Initial state     | 你现在的位置：技能、时间、资源。     |
| 终点   | Goal state        | 明确、可验证的结果。           |
| 路径   | Node sequence     | 从起点到终点经过的状态序列。       |
| 不确定性 | State space size  | 状态和分支的总规模，有多大、多野。    |
| 正向规划 | Forward chaining  | 从当前事实往前推，希望“撞上”目标。   |
| 逆向规划 | Backward chaining | 从目标往回推，找“之前必须成立的条件”。 |

---

## 2. 两种搜索方式

### 2.1 Forward Planning：盲搜

Forward planning 是一种 **blind search**，类似裸的 BFS / DFS。

**怎么做**

1. 从当前状态出发。
2. 列出所有可能的下一步。
3. 选一个，走过去。
4. 重复，直到碰到目标，或时间用完。

**代价**

- 时间复杂度按 (O(b^d)) 增长：
  - (b)：branching factor（每一步的分支数）
  - (d)：depth（到目标的大致步数）
- 增长极快，大部分努力浪费在死路上。
- 你不知道有没有更短的路。
- 对长期目标而言，这是计算上的自杀。

**何时勉强可用（很少）**

只有在下面情况才勉强适合 forward：

1. 目标模糊，你就是在探索。
2. 选择很少。
3. 路径很短。

对清晰、长期的目标，用纯 forward planning 是陷阱。

---

### 2.2 Backward Planning：聪明搜索

Backward planning 是 **guided search**，用的是 backward chaining。

**怎么做**

1. 用一句话说清目标。
2. 问自己：**“在这个目标完成之前，最后一步必须是什么？”**
3. 把这一步当成新的 sub-goal（子目标）。
4. 重复往前推，一直推回到你现在的位置。

你会得到一条必要状态链：
Goal → … → … → Today。

**威力在哪里**

- 不可能通向目标的路径，一开始就被剪掉。
- 你先“瘦身”图，再在图上行走。
- 宽广的树被压成一条细链。
- 你更多是在沿着深度 (d) 前进，而不是遍历所有 (b^d) 分支。
  实际感觉工作量更接近 (O(d))，而不是 (O(b^d))。

**前提条件**

Backward planning 需要 **清晰目标**。
目标一旦含糊，这个方法就失灵。

---

## 3. 开发者怎么用它

想像你要做一个新功能。

**Forward（很多 Junior 的做法）**

- 从第一个能想到的任务开始写代码。
- 中途不断发现隐藏依赖。
- 频繁切换、补丁、重写。
- 精力被分散在很多分支上。
- 整体复杂度体感像 (O(b^d))。

**Backward（Senior 的做法）**

- 从“完成态”开始：最终 API、UI/UX、数据流、测试、监控。
- 问：**“要做到这一点，之前必须已经有什么？”**
  - 哪些 schema？
  - 哪个 background job？
  - 哪个 index？
  - 哪份 config？
  - 哪份接口契约？
- 逆推出一串具体任务（sub-goals）。
- 然后从最前面的必要前提开始，一路实现上去。
- 返工、意外大幅减少。
- 精力集中在一条主路径上，成本更接近 (O(d))。

这就是“goal‑driven”的真正含义：
先定义终点，再推演步骤，然后才开始写代码。

---

## 4. 结语

Backward planning 不是鸡汤口号，它是更优的 search algorithm，
适用于你的项目，也适用于你的人生规划。

在目标明确的情况下，还在用纯 forward planning，
就是用指数级代价，换线性进展——这是业余做法。

先定清目标。用 backward chaining 把路径推出来。
然后，只走这一条路径。

这不是魔法，这是工程。
