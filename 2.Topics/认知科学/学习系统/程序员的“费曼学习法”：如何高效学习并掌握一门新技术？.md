
### **程序员的费曼算法：一页求生指南**

#### **Function 1: Deconstruct(Technology) → InternalModel**
★ **核心行动:** 将技术从“黑箱”解构为可解释的组件与流程图，构建你自己的内部心智模型。

→ **战术 (Tactics):**
1.  **画关系图 (Component Mapping):** 用 Excalidraw 画出核心组件关系，并标注数据流与控制权。
    *   *例 (Kafka): `Producer → Topic → Consumer Group → Offset`，追问：“谁是数据流动的瓶颈？”*
2.  **写“白话”伪代码 (Plain-Language Pseudocode):** 禁用所有专业术语，描述核心流程。
    *   *例 (JWT): “用户交出密码，我发给他一个有时效的加密‘令牌’。下次他带令牌来，我用我的密钥解开看看，没过期就放行。”*
3.  **定位“认知黑箱” (Identify Black Boxes):** 在图中明确标出你不敢解释的部分（如：“Kafka分区为何不能减少？”），这是下一步的攻击目标。

`// Tools: Excalidraw (for logic), Mermaid.js (for flow)`

---

#### **Function 2: Teach(InternalModel) → RefinedModel**
★ **核心行动:** 通过向“假想敌”（AI或新手）教学，主动触发认知冲突，暴露模型的逻辑漏洞。

→ **战术 (Tactics):**
1.  **模拟技术分享 (Mock Tech Talk):** 用 OBS 录制一个15分钟的讲解，只讲“Why”。
    *   *例：“为什么Redis单线程还快？因为99%的耗时在网络IO，CPU不是瓶颈，多线程切换反而亏。”*
2.  **用AI当陪练 (AI as Sparring Partner):** 向 ChatGPT/Claude 提出极限约束问题。
    *   *Prompt: “用‘收发快递’作比喻，向菜鸟解释什么是`async/await`，不许用‘线程’或‘协程’。”*
3.  **用高频场景类比 (High-Frequency Analogy):**
    *   *例：“React Context 就像部门大群，通知方便（避免props drilling），但任何人发言（更新）都会打扰所有人（导致重渲染）。”*

---

#### **Function 3: Compress(RefinedModel) → CorePrinciple**
★ **核心行动:** 将复杂的模型无损压缩为一句话的“电梯演讲”和核心设计哲学。

→ **战术 (Tactics):**
1.  **写“推特体”定义 (Twitter-Sized Definition):** 用 ≤140 字符总结其存在价值。
    *   *例 (Webpack): “一个前端资产打包机。它把散乱的JS/CSS/图片打包成浏览器能一口气加载完的优化文件，本质是用构建时的复杂性换取运行时的简单性。”*
2.  **进行“死亡三问”对比 (The Triage Questions):**

| 技术 | 解决了什么旧痛点？ | 什么场景绝不能用？ | 它的主要竞品是谁？ |
| :--- | :--- | :--- | :--- |
| GraphQL | REST API 的数据冗余/缺失 | 简单的 CRUD API | gRPC (内部通信) |
3.  **提炼“防坑口诀” (Defensive Mantra):**
    *   *例 (TypeScript): “`interface`管长相，`type`管叫法；`any`是魔鬼，`unknown`是君子。”*

---

#### **Function 4: Verify(CorePrinciple, Code) → GroundTruth**
★ **核心行动:** 带着具体问题深入源码或实验，用“地面实况”验证并修正你的核心原则。

→ **战术 (Tactics):**
1.  **问题驱动的源码跳转 (Issue-Driven Code Navigation):** 在 VS Code 中，对一个不解的函数名 `Go to Definition`，直接在源码旁写下你的理解注释。
2.  **制造“最小破坏实验” (Minimum Breaking Change):** 故意写错代码，通过分析报错信息来反推其内部工作原理。
    *   *例：在 Vue3 中对一个普通对象使用 `.value`，观察报错，理解 `ref` 和 `reactive` 的本质区别。*
3.  **追踪调用栈 (Trace the Stack):** 在浏览器 `console` 中使用 `console.trace()` 来可视化一个框架函数的内部调用路径。

---

#### **常见Bug与补丁 (Common Bugs & Patches)**

| Bug | Patch |
| :--- | :--- |
| **教程驱动开发 (Tutorial-Driven Development)** | **强制离线实现 (Offline-First Implementation):** 先自己动手实现最小核心，再去看教程。 |
| **术语幻觉 (Terminology Illusion)** | **画时序图 (Sequence Diagram):** 用图来解释“事件循环”，而不是背诵“宏任务/微任务”。 |
| **孤独学习综合症 (Solo-Learning Syndrome)** | **结对费曼 (Paired Feynman):** 和同事互相讲解，强制要求对方每10分钟必须提出一个质疑。 |

---

#### **终极检验 (The Litmus Test)**

真正的掌握，不是“我记住了”，而是当技术过时，你依然能用这套算法，在24小时内掌握它的替代品。因为你构建的不是零散的知识点，而是可迁移的**认知引擎**。