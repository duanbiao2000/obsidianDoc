
## 第一部分：思维提示词框架

### 框架 1：问题澄清与深化（3-Clarify）

**使用场景**：当问题模糊不清时，自动深化理解

**模板**：
```
面对任何问题时，自动执行：

1️⃣ 澄清问题类型
   ├─ 这是"是什么"问题吗？（定义/概念）
   ├─ 这是"为什么"问题吗？（原因/机制）
   ├─ 这是"如何做"问题吗？（方法/实施）
   └─ 这是"评估"问题吗？（对比/选择）

2️⃣ 识别隐藏的假设
   ├─ 问者假设了什么是"已知"的？
   ├─ 什么背景知识可能缺失？
   ├─ 有哪些隐含的约束条件？
   └─ 反向思考：如果假设反过来呢？

3️⃣ 确定回答深度
   ├─ 初学者需要基础概念吗？
   ├─ 专家需要细节和权衡吗？
   ├─ 决策者需要行动建议吗？
   └─ 我的答案是否匹配提问者的实际需求？
```

**应用例**：
```
用户问：「如何理解单元测试？」

应用框架：
1️⃣ 问题类型 → "是什么" + "如何做"（混合）
2️⃣ 隐藏假设 → 用户是否知道不同测试类型？是否有代码背景？
3️⃣ 回答深度 → 先问：「您是初学者还是有编程经验？」
              如果是 Google 开发者 → 直接讲高级话题
              如果是初学者 → 从基础开始
```

---

### 框架 2：信息压缩与结构化（MECE原则）

**使用场景**：将复杂信息转化为可记忆的结构

**模板**：
```
互相排斥，完全穷举（Mutually Exclusive, Collectively Exhaustive）

任何信息集合都应满足：
✅ 互相排斥：每个类别之间没有重叠
✅ 完全穷举：所有情况都被覆盖

例：测试类型分类

❌ 不好的分类（重叠）：
  - 单元测试
  - 集成测试
  - 快速测试  ← 与其他类别重叠

✅ 好的分类（互斥且完全）：
  按被测对象：
  - 单元级（函数/方法）
  - 集成级（多个模块）
  - 系统级（整个应用）
  
  按速度：
  - 快速（<100ms）
  - 中等（100ms-1s）
  - 慢速（>1s）
```

---

### 框架 3：对标学习与反向工程（Reverse-Engineer）

**使用场景**：学习行业最佳实践

**模板**：
```
3步反向工程模式：

1️⃣ 找标杆
   ├─ 谁做得最好？（Google, Meta, Netflix）
   ├─ 他们的方案是什么？
   └─ 成本/收益是什么？

2️⃣ 拆解原理
   ├─ 为什么这个方案有效？
   ├─ 关键约束是什么？
   ├─ 有哪些隐含假设？
   └─ 什么条件下会失效？

3️⃣ 改写为自己的上下文
   ├─ 我们的规模/资源相同吗？
   ├─ 需要调整哪些部分？
   ├─ 风险在哪里？
   └─ MVP 版本是什么？

例：学习 Google 的测试策略
  标杆 → Google 的 70/20/10 测试比例
  原理 → 70% 快速单元 (快反馈) + 20% 集成 (真实性) + 10% E2E (覆盖)
  改写 → 我们团队 5 人，改为 60/30/10 平衡速度和可靠性
```

---

### 框架 4：权衡矩阵（Trade-off Matrix）

**使用场景**：复杂决策，权衡多个因素

**模板**：
```
2x2 矩阵或多维权衡表

例：Stub vs Spy vs Mock 的选择

维度 1：验证交互程度（低→高）
维度 2：维护成本（低→高）

┌─────────────┬──────────┬────────────┬──────────┐
│ 工具        │ 验证程度 │ 维护成本   │ 推荐指数 │
├─────────────┼──────────┼────────────┼──────────┤
│ Stub        │ ⭐      │ ⭐        │ ⭐⭐⭐ │
│ Spy         │ ⭐⭐⭐ │ ⭐⭐      │ ⭐⭐⭐ │
│ Mock        │ ⭐⭐⭐⭐│ ⭐⭐⭐⭐⭐│ ⭐     │
└─────────────┴──────────┴────────────┴──────────┘

决策规则：
IF 简单场景 → 用 Stub
IF 需要验证 → 用 Spy
IF 极端复杂 AND 团队成熟 → 用 Mock
```

---

## 第二部分：认知压缩 Prompt

### 压缩 Prompt 1：一句话精华提取

**目标**：从复杂概念中提取核心本质

**Prompt 模板**：
```
请用「一句话」解释 [概念]，要求：
1. 包含最核心的动作和目的
2. 避免术语（用比喻代替）
3. 一个普通人也能理解

例：
问：一句话解释「单元测试」
答：把程序的每个小积木分别测试，确保每块都是好的，这样拼起来才不容易垮。
```

**应用场景**：
- 写文档摘要
- 准备 30 秒电梯演讲
- 制作学习卡片（Anki）
- 技术博客标题

---

### 压缩 Prompt 2：对比压缩

**目标**：通过对比快速理解差异

**Prompt 模板**：
```
对比 [A] 和 [B]，用表格展示：

| 维度 | A | B | 记忆技巧 |
|------|---|---|---------|
| 何时用 | | | |
| 核心区别 | | | |
| 一个例子 | | | |
| 常见误区 | | | |

记忆技巧：用一个故事或比喻连接两者
```

**实例**：

对比 Mock 和 Spy

| 维度  | Mock | Spy     | 记忆技巧                         |
| --- | ---- | ------- | ---------------------------- |
| 本质  | 完全替换 | 窃听 + 保留 | Mock=演员（假的），Spy=窃听器（真实+记录）   |
| 用途  | 验证交互 | 验证+保留行为 | Mock 当你要完全控制；Spy 当你要验证又要真实结果 |
| 脆弱性 | 很高   | 中等      | Mock 越复杂越脆弱（像演员演戏，剧本改了就崩）    |
|     |      |         |                              |




### 压缩 Prompt 3：金字塔记忆法

**目标**：多层级记忆，从浅到深

**Prompt 模板**：
```
用金字塔结构学 [主题]：

顶层（1句话）：最核心结论
 ↓
第二层（3-5点）：支撑论点
 ↓
第三层（细节例子）：具体应用

例：单元测试金字塔

🔺 顶层：单元测试是最小单位代码的快速验证
   ↓
📊 第二层：
   ├─ 快速反馈（<100ms）
   ├─ 易于定位问题
   ├─ 覆盖边界情况
   ├─ 便于重构
   └─ 成本最低
   ↓
📝 第三层：
   ├─ 例：测试计算函数 sum(2,3) === 5
   ├─ 例：测试错误处理 sum(null) throws Error
   ├─ 例：测试边界 sum(MAX_INT, 1) handles overflow
   └─ 例：Mock 外部依赖但不 Mock 计算逻辑
```

---

### 压缩 Prompt 4：决策树速查表

**目标**：快速做出选择

**Prompt 模板**：
```
[问题] 的决策树：

Q1: [第一个关键问题]？
├─ YES → [建议 A]
└─ NO → Q2

Q2: [第二个问题]？
├─ YES → [建议 B]
└─ NO → [建议 C]

例：「我应该用什么测试？」

Q1: 需要验证依赖被如何调用吗？
├─ NO → 用 Stub ⭐⭐ (推荐)
└─ YES → Q2

Q2: 需要依赖返回的真实结果吗？
├─ YES → 用 Spy ⭐⭐⭐ (推荐)
└─ NO → Q3

Q3: 需要验证多个依赖的交互顺序吗？
├─ YES → 用 Mock ⭐ (谨慎)
└─ NO → 用 Stub
```

---

## 第三部分：工具集成脚本

### 脚本 1：Anki 生成器（学习卡片自动化）

**目标**：自动生成学习卡片，无痛记忆

**应用**：
```python
#!/usr/bin/env python3
"""
Anki 卡片生成器
用途：将学习笔记自动转换为可导入 Anki 的卡片

安装：pip install genanki
"""

import genanki
import json
from datetime import datetime

# 定义卡片模型
card_model = genanki.Model(
    1234567890,
    'Developer Learning',
    fields=[
        {'name': 'Front'},
        {'name': 'Back'},
        {'name': 'Tags'},
        {'name': 'Source'}
    ],
    templates=[{
        'name': 'Card 1',
        'qfmt': '''
        <h2>{{Front}}</h2>
        <div class="tags">{{Tags}}</div>
        ''',
        'afmt': '''
        {{FrontSide}}
        <hr>
        {{Back}}
        <div class="source">来源：{{Source}}</div>
        '''
    }]
)

class AnkiCardGenerator:
    def __init__(self, deck_name='Developer Learning'):
        self.deck = genanki.Deck(
            2345678901,
            deck_name
        )
        self.card_model = card_model
    
    def add_concept_card(self, question, answer, tags, source=''):
        """添加概念卡片"""
        note = genanki.Note(
            model=self.card_model,
            fields=[question, answer, tags, source]
        )
        self.deck.add_notes(note)
        return self
    
    def add_example_card(self, scenario, solution, tags, source=''):
        """添加例子卡片"""
        return self.add_concept_card(
            f"[例] {scenario}",
            f"✅ {solution}",
            tags,
            source
        )
    
    def add_comparison_card(self, what_to_compare, differences, tags, source=''):
        """添加对比卡片"""
        return self.add_concept_card(
            f"对比：{what_to_compare}",
            differences,
            tags,
            source
        )
    
    def export(self, filename='developer_learning.apkg'):
        """导出 Anki 文件"""
        genanki.TEMPLATE_ROOT = '.'
        genanki.Package(self.deck).write_to_file(filename)
        print(f"✅ 卡片已导出到 {filename}")
        return filename

# 使用示例
if __name__ == '__main__':
    gen = AnkiCardGenerator('JS 测试最佳实践')
    
    # 添加基础概念卡片
    gen.add_concept_card(
        '什么是单元测试？',
        '''✅ 测试程序的最小单位（函数/方法）
        - 速度快：< 100ms
        - 易定位：直接找到问题
        - 覆盖全：边界情况都测试
        - 成本低：快速反馈循环''',
        'testing, unit-test',
        'Google Testing Best Practices'
    )
    
    # 添加对比卡片
    gen.add_comparison_card(
        'Stub vs Spy vs Mock',
        '''| 工具 | 验证交互 | 保留行为 | 用途 |
        |------|--------|--------|------|
        | Stub | ❌ | ❌ | 快速提供数据 |
        | Spy | ✅ | ✅ | 验证调用+保留结果 |
        | Mock | ✅ | ❌ | 严格验证交互 |''',
        'testing, mock',
        'JavaScript Testing Guide'
    )
    
    # 添加例子卡片
    gen.add_example_card(
        '如何选择测试替身？',
        '''问题 1：需要验证交互？
        ├─ NO → 用 Stub
        └─ YES → 问题 2
        
        问题 2：需要真实结果？
        ├─ YES → 用 Spy
        └─ NO → 用 Mock''',
        'testing, decision',
        'JavaScript Testing Guide'
    )
    
    gen.export('testing_best_practices.apkg')
```

**使用步骤**：
```bash
# 1. 保存上述代码为 anki_generator.py
# 2. 安装依赖
pip install genanki

# 3. 运行
python anki_generator.py

# 4. 导入 Anki（打开 Anki → File → Import）
```

---

### 脚本 2：Obsidian 双向链接索引生成器

**目标**：自动建立知识图谱

**应用**：
```python
#!/usr/bin/env python3
"""
Obsidian 知识图谱生成器
用途：从 Markdown 文件生成双向链接索引
"""

import os
import re
from pathlib import Path
from collections import defaultdict

class ObsidianIndexGenerator:
    def __init__(self, vault_path='./notes'):
        self.vault_path = Path(vault_path)
        self.graph = defaultdict(set)
        self.concepts = {}
    
    def scan_files(self):
        """扫描所有 Markdown 文件"""
        files = list(self.vault_path.glob('**/*.md'))
        print(f"📁 找到 {len(files)} 个笔记文件")
        return files
    
    def extract_metadata(self, content):
        """提取 YAML frontmatter"""
        yaml_pattern = r'^---\n(.*?)\n---'
        match = re.search(yaml_pattern, content, re.DOTALL)
        if match:
            yaml_content = match.group(1)
            metadata = {}
            for line in yaml_content.split('\n'):
                if ':' in line:
                    key, value = line.split(':', 1)
                    metadata[key.strip()] = value.strip()
            return metadata
        return {}
    
    def extract_links(self, content):
        """提取 [[链接]]"""
        links = re.findall(r'\[\[([^\]]+)\]\]', content)
        return set(links)
    
    def extract_concepts(self, filename, content):
        """提取一级标题作为概念"""
        h1_pattern = r'^# (.+?)$'
        match = re.search(h1_pattern, content, re.MULTILINE)
        if match:
            concept = match.group(1)
            self.concepts[filename] = {
                'title': concept,
                'file': filename
            }
            return concept
        return filename
    
    def build_graph(self):
        """构建知识图"""
        files = self.scan_files()
        
        for file in files:
            content = file.read_text(encoding='utf-8')
            concept = self.extract_concepts(file.name, content)
            links = self.extract_links(content)
            
            for link in links:
                self.graph[concept].add(link)
                self.graph[link]  # 确保所有概念都在图中
    
    def generate_index(self):
        """生成索引文档"""
        index_content = '''# 知识图谱索引

> 自动生成的双向链接索引

## 📊 关系图
\n'''
        
        for concept, links in sorted(self.graph.items()):
            if links:
                index_content += f"\n### {concept}\n"
                for link in sorted(links):
                    index_content += f"- [[{link}]]\n"
        
        # 统计信息
        index_content += f"\n---\n\n## 📈 统计\n"
        index_content += f"- 总概念数：{len(self.concepts)}\n"
        index_content += f"- 总链接数：{sum(len(v) for v in self.graph.values())}\n"
        index_content += f"- 最多关联的概念：{self._find_most_connected()}\n"
        
        return index_content
    
    def _find_most_connected(self):
        """找最多关联的概念"""
        if not self.graph:
            return "无"
        most_connected = max(self.graph.items(), key=lambda x: len(x[1]))
        return f"{most_connected[0]} ({len(most_connected[1])} 个关联)"
    
    def export(self, output_path='INDEX.md'):
        """导出索引"""
        self.build_graph()
        index = self.generate_index()
        
        output = self.vault_path / output_path
        output.write_text(index, encoding='utf-8')
        print(f"✅ 索引已导出到 {output}")
        return output

# 使用示例
if __name__ == '__main__':
    gen = ObsidianIndexGenerator('./my_notes')
    gen.export('_INDEX.md')
```

**使用步骤**：
```bash
# 1. 在 Obsidian 笔记目录中运行
python obsidian_indexer.py

# 2. 在 Obsidian 中查看生成的 _INDEX.md
# 3. 双向链接会自动显示在图谱中
```

---

### 脚本 3：智能提示词生成器（AutoAgent）

**目标**：根据场景自动生成最优提示词

**应用**：
```python
#!/usr/bin/env python3
"""
智能提示词生成器
用途：根据学习场景自动生成个性化提示词
"""

from enum import Enum
from dataclasses import dataclass

class LearningContext(Enum):
    BEGINNER = "初学者"
    INTERMEDIATE = "进阶"
    EXPERT = "专家"
    DECISION_MAKER = "决策者"

class ContentType(Enum):
    CONCEPT = "概念学习"
    COMPARISON = "对比学习"
    PROBLEM_SOLVING = "问题解决"
    DECISION = "决策支持"
    IMPLEMENTATION = "实施指南"

@dataclass
class PromptContext:
    topic: str
    context: LearningContext
    content_type: ContentType
    background: str = ""
    constraints: list = None

class PromptGenerator:
    def __init__(self):
        self.templates = {
            (LearningContext.BEGINNER, ContentType.CONCEPT): '''
请用简单的比喻解释 {topic}，假设读者没有任何背景知识。

结构：
1️⃣ 一句话核心（比喻）
2️⃣ 三个关键特点
3️⃣ 一个现实中的例子
4️⃣ 常见误区

注意：避免术语，用日常用语。
            ''',
            
            (LearningContext.INTERMEDIATE, ContentType.COMPARISON): '''
对比 {topic}，假设读者有基础知识。

结构：
1️⃣ 快速总结（异同）
2️⃣ 详细对比表
3️⃣ 选择标准
4️⃣ 实战例子

注意：聚焦实践差异。
            ''',
            
            (LearningContext.EXPERT, ContentType.DECISION): '''
为 {topic} 的决策提供深度分析。

结构：
1️⃣ 权衡矩阵（多维度）
2️⃣ 风险分析
3️⃣ 成本效益
4️⃣ Google/Netflix/Meta 的做法
5️⃣ 反向思考：什么时候失效？

注意：基于数据和案例。
            ''',
            
            (LearningContext.DECISION_MAKER, ContentType.IMPLEMENTATION): '''
为 {topic} 的实施提供行动清单。

结构：
1️⃣ 30 秒电梯演讲
2️⃣ 为什么重要（3 个理由）
3️⃣ 实施步骤（优先级排序）
4️⃣ 成功指标
5️⃣ 常见陷阱

注意：聚焦 ROI 和执行力。
            '''
        }
    
    def generate(self, ctx: PromptContext) -> str:
        """生成自适应提示词"""
        key = (ctx.context, ctx.content_type)
        
        template = self.templates.get(key)
        if not template:
            template = self._fallback_template(ctx)
        
        prompt = template.format(topic=ctx.topic)
        
        # 添加个性化信息
        if ctx.background:
            prompt += f"\n\n背景信息：{ctx.background}"
        
        if ctx.constraints:
            prompt += "\n\n约束条件：\n"
            for constraint in ctx.constraints:
                prompt += f"- {constraint}\n"
        
        return prompt.strip()
    
    def _fallback_template(self, ctx: PromptContext) -> str:
        """默认模板"""
        return f'''
请帮助我理解 {ctx.topic}

我的背景：{ctx.context.value}
学习目标：{ctx.content_type.value}

请用清晰的结构讲解，包括：
1. 核心概念
2. 关键区别
3. 实战应用
4. 常见误区
        '''

# 使用示例
if __name__ == '__main__':
    gen = PromptGenerator()
    
    # 场景 1：初学者想理解单元测试
    ctx1 = PromptContext(
        topic="单元测试",
        context=LearningContext.BEGINNER,
        content_type=ContentType.CONCEPT,
        background="我是 Python 开发新手，有 1 个月编程经验"
    )
    print("=" * 50)
    print("场景 1：初学者学习概念")
    print("=" * 50)
    print(gen.generate(ctx1))
    
    # 场景 2：进阶开发者对比 Stub vs Spy vs Mock
    ctx2 = PromptContext(
        topic="Stub vs Spy vs Mock",
        context=LearningContext.INTERMEDIATE,
        content_type=ContentType.COMPARISON,
        background="我在 Google 工作，需要为团队选择合适的测试策略"
    )
    print("\n" + "=" * 50)
    print("场景 2：进阶开发者对比学习")
    print("=" * 50)
    print(gen.generate(ctx2))
    
    # 场景 3：决策者评估测试框架投资
    ctx3 = PromptContext(
        topic="应该投资自动化测试框架吗",
        context=LearningContext.DECISION_MAKER,
        content_type=ContentType.DECISION,
        constraints=[
            "团队规模：50 人",
            "项目复杂度：中等（微服务架构）",
            "预算限制：$100k/年"
        ]
    )
    print("\n" + "=" * 50)
    print("场景 3：决策者支持")
    print("=" * 50)
    print(gen.generate(ctx3))
```

**使用步骤**：
```bash
# 1. 保存为 prompt_generator.py
# 2. 运行
python prompt_generator.py

# 3. 复制输出的提示词到 Claude/ChatGPT
```

---

## 第四部分：新手操作指南

### 快速开始 5 分钟指南

#### 步骤 1：选择学习框架（2 分钟）

```
你的问题是什么类型？

1️⃣ 问题太模糊？ → 用【3-Clarify 框架】
2️⃣ 需要快速记忆？ → 用【MECE 原则】
3️⃣ 学习行业最佳实践？ → 用【Reverse-Engineer 框架】
4️⃣ 需要做复杂决策？ → 用【权衡矩阵】

例：
  问题："我应该用哪个测试框架？"
  → 这需要权衡矩阵来对比
  → 使用【权衡矩阵】框架
```

#### 步骤 2：生成认知压缩提示词（2 分钟）

```
打开 prompt_generator.py，或直接告诉我：

- 你是谁？（初学者/进阶/专家/决策者）
- 你想学什么？（概念/对比/决策/实施）
- 背景是什么？

系统自动生成最优提示词 → 复制到 Claude 提问
```

#### 步骤 3：生成学习卡片（1 分钟）

```bash
# 让 AI 帮你整理笔记为 Anki 卡片
python anki_generator.py

# 在 Anki 中导入
File → Import → 选择 .apkg 文件

# 每天 15 分钟复习
```

---

### 场景应用示例

#### 应用场景 A：快速学习新概念（15 分钟）

```
1. 用【一句话精华提取】理解核心
   Prompt: "用一句话解释 [概念]"
   
2. 用【对比压缩】区分相似概念
   Prompt: "对比 A 和 B，用对比表"
   
3. 添加 Anki 卡片记忆
   python anki_generator.py
   
4. 建立到其他知识的链接
   在 Obsidian 中使用 [[双向链接]]
```

#### 应用场景 B：做复杂决策（30 分钟）

```
1. 澄清问题
   用【3-Clarify 框架】深化理解
   
2. 找标杆
   用【Reverse-Engineer 框架】学习最佳实践