---
archived: true
view-count: 3
tags:
  - ComplexityClassification
  - PatternSelection
  - Architecture
  - SystemDesign
related:
  - '[[01-架构设计方法论集]]'
---
# 架构师范式选择：本质识别手册

### 0. 核心原则
*   **55min 定义问题，5min 解决。**
*   **新手问 How，高手问 What。**
*   **范式错位 = 复杂度爆炸。**

---

### 1. 复杂性分类 (Cynefin)
*   **简单 (Simple)**：感知 $\rightarrow$ 归类 $\rightarrow$ 响应。**范式：面向过程**（脚本/自动化）。
*   **繁杂 (Complicated)**：分析 $\rightarrow$ 专家评估。**范式：OOP**（封装复杂模型）。
*   **复杂 (Complex)**：探索 $\rightarrow$ 感知。**范式：FP / 响应式**（数据流/不可变）。
*   **混乱 (Chaotic)**：行动 $\rightarrow$ 止损。**范式：命令式**（快速执行）。

---

### 2. 复杂性二元论 (Brooks)
*   **必要复杂性 (Essential)**：业务固有逻辑。
*   **偶然复杂性 (Accidental)**：工具/方法选型错误。
*   **目标：接纳必要，抹除偶然。**

---

### 3. 三维本质扫描器

#### **维度 A：数据流 vs 状态机**
*   **数据流**：`Input -> Transform -> Output`。**选 FP**（如 ETL、编译器、图像处理）。
*   **状态机**：`Object + Action -> New State`。**选 OOP**（如 订单生命周期、GUI、游戏逻辑）。

#### **维度 B：顺序 vs 并发**
*   **确定性顺序**：第一步 $\rightarrow$ 第二步。**选 命令式**。
*   **高并发/资源竞争**：内存共享有害。**选 Actor (Erlang) / CSP (Go)**。

#### **维度 C：逻辑 vs 规则**
*   **逻辑流程**：如何做 (How)。**选 命令式/结构化**。
*   **推理规则**：要什么 (What)。**选 声明式 (SQL/Prolog)**。

---

### 4. 正反案例分析

*   **✅ 订单状态流转 (State-Heavy)**
    *   本质：有限状态机。
    *   实践：**OOP 状态模式**。封装行为，保护状态一致性。
*   **✅ 实时日志分析 (Data-Heavy)**
    *   本质：转换管道。
    *   实践：**FP 链式调用**。Filter $\rightarrow$ Map $\rightarrow$ Reduce。

*   **❌ ETL 任务过度 OOP**
    *   错误：写 20 个类（ReaderFactory, WriterStrategy）。
    *   后果：逻辑碎片化，偶然复杂度爆炸。
    *   修正：**脚本/函数式**。直观表达 `CSV -> JSON`。
*   **❌ GUI 交互强行纯 FP**
    *   错误：每次按键生成全量新 State。
    *   后果：性能雪崩（GC 压力），Redux 样板代码冗余。
    *   修正：**局部可变状态 (OOP/Mutable)**。UI 本质是有状态实体。

---

### 5. 混合范式策略 (Polyglot Strategy)
| 业务域 | 本质 | 推荐范式 |
| :--- | :--- | :--- |
| **交易核心** | 强一致、复杂状态 | Java/C# (OOP) |
| **风控/流算** | 规则推理、数据变换 | Scala/Flink (FP) |
| **报表统计** | 声明式查询 | SQL/Python (Declarative) |
| **网关胶水** | 高 IO、流程调度 | Go/Node.js (Imperative) |

---

### 6. 终极总结
*   **数据流 $\rightarrow$ FP**
*   **状态机 $\rightarrow$ OOP**
*   **多任务协作 $\rightarrow$ Actor/CSP**
*   **策略：先看穿本质，再顺势而为。**