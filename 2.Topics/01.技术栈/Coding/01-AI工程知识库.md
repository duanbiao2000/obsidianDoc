---
rating: 3.5
related:
- '[[AI大模型知识体系]]'
- '[[上下文工程]]'
- '[[多智能体系统如何像顶尖研究团队一样协同工作]]'
- '[[Testing and Quality Assurance Agent]]'
- '[[AI协作作战手册设计规范 v1.0]]'
- '[[Spec-Driven Development（规格驱动开发）]]'
tags:
- AI-Application-Development
- Agent-Synthesis
- AI
- Engineering
- PromptEngineering
- MultiAgent
- Domain/AI
- Domain/Technology/Engineering
- Type/Reference
- Status/Done
---

# AI工程知识库

> 本文档整合了AI工程相关的核心实践、工具与方法论，为工程师提供完整的AI应用开发知识体系。

---

## 📚 一、提示词工程（Prompt Engineering）

### 1. 核心范式与原则
*源自：[[AI大模型知识体系]]*

**核心公式**：
- 提示词 = 效率工具
- Agent + RAG = 生产力工程
- 微调 + 架构 = 核心壁垒

**三大能力分支**：
- **应用工具 (Tools)**：Prompt Engineering, Dify, Coze, Ollama, Cursor
- **应用开发 (Development)**：RAG/GraphRAG, Agent, Workflow, vLLM, TensorRT-LLM
- **微调与算法 (Algorithms)**：Transformer 机制, MoE, SFT, LoRA, PEFT, RLHF, DPO

---

### 2. 上下文工程
*源自：[[上下文工程]] & [[上下文工程解析]]*

**核心概念**：
- 上下文是 AI 理解任务的"工作记忆"
- 有效上下文管理是高质量输出的关键
- 上下文漂移会导致输出偏离目标

**实践方法**：
- 模块化上下文：将复杂任务拆解为独立模块
- 渐进式上下文：从简单到复杂逐步展开
- 上下文刷新：在关键节点重构任务背景

---

### 3. Prompt 模板库
*源自：[[AI协作作战手册设计规范 v1.0]]*

**作战手册五大模块**：
1. **指导宪法**：明确 AI 角色、目标、约束
2. **黄金范例**：提供成功示例作为语义锚定
3. **多轮上下文设计**：预设任务结构、阶段流程
4. **上下文刷新机制**：在关键节点重构任务背景
5. **失效应对策略**：为 AI 可能的误差预设修复机制

**使用流程**：
- 第一步：填写"指导宪法"和"黄金范例"，锁定角色与风格
- 第二步：预设任务阶段（多轮上下文）或直接启动对话
- 第三步：在每个阶段视情况使用"上下文刷新"或"修正提示"
- 第四步：任务结束后，总结有效模式与待优化点

---

### 4. Sequential Thinking
*源自：[[sequential - thinking的适用场景]]*

**适用场景**：
- 复杂问题拆解：将大问题分解为可管理的小任务
- 多步骤推理：需要逐步推导才能得出结论
- 迭代优化：需要多次反馈和修正的任务

**实现方法**：
- 思维链（Chain-of-Thought）：显式展示推理步骤
- 自我反思：在关键步骤检查推理的正确性
- 回溯修正：发现错误时可以回溯到前面步骤

---

## 📚 二、多智能体系统（Multi-Agent Systems）

### 1. Agent 架构范式
*源自：[[多智能体系统如何像顶尖研究团队一样协同工作]] & [[智能 Agent 架构关键范式]]*

**核心特征**：
- 自主性：可以自主决策和执行任务
- 协作性：多个 Agent 之间可以协作完成复杂任务
- 可扩展性：可以动态添加或移除 Agent

**架构模式**：
- **层级式**：有明确的上下级关系，适合集中式决策
- **分布式**：Agent 之间平等协作，适合去中心化场景
- **混合式**：结合层级和分布式的优点

---

### 2. 协作模式设计
*源自：[[多智能体系统如何像顶尖研究团队一样协同工作]]*

**典型协作模式**：
- **流水线模式**：Agent 按顺序处理任务，每个 Agent 专注于特定环节
- **并行模式**：多个 Agent 同时处理不同部分，适合可并行分解的任务
- **竞争模式**：多个 Agent 竞争生成最佳方案，适合需要探索的场景
- **协商模式**：Agent 之间协商达成一致，适合需要妥协的场景

**最佳实践**：
- 明确每个 Agent 的角色和职责
- 设计清晰的通信协议
- 建立冲突解决机制

---

### 3. FabricAI 智能助手
*源自：[[FabricAI智能助手]]*

**核心功能**：
- 知识检索：从文档库中快速检索相关信息
- 任务执行：根据用户需求自动执行一系列操作
- 智能问答：基于上下文的精准回答

**技术特点**：
- 模块化设计：可插拔的功能组件
- 上下文感知：理解用户意图和历史上下文
- 多模态支持：处理文本、图像等多种输入

---

## 📚 三、模型选型与评估

### 1. 大模型选型决策树
*源自：[[大模型选型决策树]]*

**决策维度**：
| 维度 | 评估标准 | 推荐模型 |
|------|----------|----------|
| **成本** | API 调用成本、推理成本 | GPT-4o-mini, Claude Haiku |
| **延迟** | 响应时间要求 | Llama 3.1, Gemma |
| **准确性** | 任务准确率要求 | GPT-4o, Claude 3.5 Sonnet |
| **数据隐私** | 是否允许数据上传 | 本地部署模型 |
| **定制化** | 是否需要微调 | Llama, Mistral |

**选型建议**：
- 高准确性 + 低延迟：GPT-4o（成本较高）
- 低成本 + 通用任务：GPT-4o-mini
- 数据敏感 + 本地部署：Llama 3.1
- 特定领域：考虑领域专用模型

---

### 2. Testing Agent
*源自：[[Testing and Quality Assurance Agent]]*

**核心功能**：
- 自动化测试：根据需求自动生成测试用例
- 代码审查：检查代码质量和潜在问题
- 性能测试：评估系统性能指标

**测试框架**：
- **单元测试**：测试单个函数或方法
- **集成测试**：测试多个模块之间的交互
- **端到端测试**：测试整个系统的功能

---

### 3. 能力–采用率鸿沟
*源自：[[AI能力–采用率鸿沟]]*

**核心概念**：
- 模型已经很强，但个人和企业只在用其中很小一部分能力
- 未来 5–10 年的主要任务是缩小这条鸿沟
- 从"问答玩具"变成真正的"任务工作者"

**费曼重构**：
> 我们现在有一台"超级无敌全能机"，它其实会做很多事：会写作业、查资料、帮你订机票、看病前先帮你查一轮、帮公司看合同、记流水账……但大多数人**只拿它当会说话的搜索引擎**：问一句，它答一句，就结束了。

**应用场景**：
- **个人层面**：设计自己的 AI 采纳路线图
- **团队层面**：辨别"玩具用法" vs "生产用法"
- **投资与战略**：判断产品是否在缩小鸿沟

---

## 📚 四、应用场景

### 1. AI 在写代码领域
*源自：[[AI在写代码领域的当前水平]]*

**当前能力**：
- 代码生成：根据描述自动生成代码
- 代码解释：解释复杂代码的功能
- 代码重构：优化代码结构和性能
- 调试辅助：帮助定位和修复 bug

**局限性**：
- 上下文长度限制：无法处理超大代码库
- 隐式依赖：难以理解复杂的隐式依赖关系
- 领域知识：缺乏特定领域的专业知识

---

### 2. Skills 选型策略
*源自：[[skills选型策略]]*

**选型原则**：
- **明确需求**：清楚自己需要什么能力
- **评估成本**：权衡时间、金钱和学习成本
- **考虑兼容性**：确保与现有技术栈兼容

**推荐路径**：
1. **入门**：从通用工具开始（Cursor, Copilot）
2. **进阶**：学习 Prompt Engineering 和 RAG
3. **高级**：掌握 Agent 和微调技术

---

### 3. SpecKit 开发
*源自：[[SpecKit四个阶段]] & [[specs开发阶段]]*

**四个阶段**：
1. **需求分析**：明确用户需求和业务目标
2. **规格定义**：编写详细的规格说明文档
3. **实现开发**：根据规格进行代码开发
4. **测试验证**：验证实现是否符合规格

**Arc 蓝图**：
*源自：[[Arc-将蓝图细化为具体的装配指令]]*

将高层次的蓝图细化为具体的可执行指令，确保 AI 理解和执行正确的任务。

---

### 4. Tech Stack Selection Guide
*源自：[[Tech Stack Selection Guide Build Smart Not Overcomplicated]]*

**选型原则**：
- **Build Smart**：选择能解决问题的技术
- **Not Overcomplicated**：避免过度设计
- **考虑团队能力**：选择团队熟悉的技术

---

### 5. 写代码 vs 写作
*源自：[[写代码 vs 写作：AI评估维度对比]]*

**评估维度对比**：
| 维度 | 代码生成 | 内容写作 |
|------|----------|----------|
| **准确性** | 严格正确，语法错误不可容忍 | 语法错误相对可容忍 |
| **逻辑性** | 必须逻辑严密 | 逻辑要求相对宽松 |
| **可维护性** | 要求代码可读、可维护 | 可读性要求较低 |
| **创造性** | 需要在框架内创新 | 需要较高的创造性 |

---

### 6. The Effective Engineer GPT
*源自：[[The Effective Engineer GPT5.1high版本]]*

**核心功能**：
- 工程实践指导：提供最佳实践建议
- 问题诊断：帮助定位和解决工程问题
- 学习路径规划：制定个性化的学习计划

---

### 7. CheeryStudio 自反能力
*源自：[[CheeryStudio自反能力提示词生成器]]*

**自反能力**：
- AI 能够反思自己的输出
- 发现错误并自我修正
- 持续优化输出质量

---

### 8. The Book of Secret Knowledge
*源自：[[the-book-of-secret-knowledge]]*

**知识体系**：
- 整合多个领域的知识
- 提供跨领域的连接
- 支持知识图谱构建

---

### 9. AI 协作白皮书
*源自：[[AI 协作白皮书]]*

**协作模式**：
- 人机协作：AI 作为助手，人作为决策者
- 机机协作：多个 AI 之间协作完成任务
- 混合协作：人和 AI 混合组成团队

---

### 10. Prompt 模板库结构设计
*源自：[[Prompt 模板库结构设计]]*

**结构设计原则**：
- 模块化：每个模板独立可用
- 可组合：多个模板可以组合使用
- 可复用：模板可以在不同场景复用

---

## 📚 五、AI 工具与框架

### 常用工具
- **Cursor**：AI 代码编辑器
- **Copilot**：GitHub AI 编程助手
- **Dify**：AI 应用开发平台
- **Coze**：AI 对话平台
- **Ollama**：本地 LLM 运行工具

### 框架
- **LangChain**：AI 应用开发框架
- **AutoGPT**：自动化 Agent
- **CrewAI**：多 Agent 协作框架

---

## 🔗 参考资源

- [[2.Topics/系统构建/03-AI工程实战集]] - 系统构建中的 AI 工程实践
- [[Spec-Driven Development（规格驱动开发）]] - 规格驱动开发
- [[多智能体系统如何像顶尖研究团队一样协同工作]] - 协作模式详解
