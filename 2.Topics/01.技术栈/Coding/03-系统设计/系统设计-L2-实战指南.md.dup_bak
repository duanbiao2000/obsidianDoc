---
view-count: 7
update: 2026-01-22T00:00:00.000Z
tags:
  - DesignPatterns
  - DocumentationProcess
  - SystemDesign
  - Architecture
  - Type/Reference
  - Domain/Technology
  - DesignPatterns
  - DocumentationProcess
  - SystemDesign
  - Architecture
related:
  - '[[智能 Agent 架构关键范式]]'
  - '[[系统设计与架构模式]]'
  - '[[微服务架构完全指南]]'
---
# 系统设计-L2-实战指南

## 一、设计思维

### 核心概念

**Design Thinking** 是一套用于理解和解决复杂设计挑战的、以用户为中心的迭代式流程。

**核心价值**：
- 用户理解：通过深度用户调研建立同理心
- 规划：快速可视化概念和方案
- 原型测试：尽早验证设计假设
- 迭代：基于反馈持续改进

---

## 二、系统设计与架构模式

### 1. 设计模式选择决策

| 模式 | 核心动作 | 典型应用 | 吐槽 |
|:--- | :--- | :--- | :--- |
| **单例** | 唯一实例 | 日志/连接池 | 容易变全局耦合坑 |
| **工厂方法** | 子类决定实例 | 游戏角色生成 | 避免 if-else 散落 |
| **抽象工厂** | 创建产品族 | 跨平台 UI 套件 | 高级但结构重 |
| **适配器** | 接口转换 | 兼容老 API | 救火队员专用 |
| **装饰者** | 动态包装 | IO 流/咖啡加料 | 比继承灵活的"乐高" |
| **代理** | 控制访问 | 懒加载/权限检查 | 它是中间商 |
| **观察者** | 一对多通知 | 事件监听/消息订阅 | 生产环境建议用 MQ |
| **策略** | 算法动态替换 | 支付方式/排序算法 | 消除臃肿分支 |
| **责任链** | 请求沿链传递 | 拦截器/审批流 | 接力赛模式 |

### 2. 设计模式应用决策树

1. **创建逻辑复杂？** → 工厂
2. **要给旧代码打补丁？** → 适配器
3. **功能要动态堆叠？** → 装饰者
4. **算法经常变？** → 策略
5. **需要解耦多方通信？** → 观察者

### 3. 避坑指南

- **单例不是银弹**：它是披着模式外衣的全局变量，难测试、高耦合
- **组合优于继承**：能用装饰者/策略，就不要写深层的继承树
- **不要过度设计**：
  - 只有 2 个分支？用 `if-else`
  - 只有 3 个类？直接 `new`
  - **YAGNI** (You Ain't Gonna Need It) 是最高优先级
- **模式的终局**：代码写到最后，模式应该消失在业务逻辑里，而不是处处显摆

---

## 三、系统设计文档与 PRD、Spec

### 1. 核心逻辑

**通过文档分层解耦业务价值、技术架构与实现细节，实现从需求到代码的确定性映射**

### 2. 分析

**递进关系**：业务需求 $\rightarrow{PRD}$ 系统设计 $\rightarrow{Spec}$ 开发实现

**职责解耦**：
- PM 负责 PRD（定义"做什么"）
- 架构师负责系统设计（定义"怎么架"）
- 开发负责 Spec（定义"怎么写"）

**价值闭环**：
- PRD 保证商业对齐
- 系统设计控制技术风险
- Spec 提升并行开发效率

### 3. 抽象

**复杂度隔离原则**：
- PM 无需理解 Redis 缓存，开发无需反复确认商业逻辑

**契约锁定模式**：
- 并行开发的前提是"契约"的预先锁定

**架构决策前置**：
- 在 Spec 编写前完成关键选型，可将技术瓶颈的发现成本从"开发阶段"左移至"设计阶段"

### 4. 结构化

**输入 $\to$ 价值定义 $\to$ 架构映射 $\to$ 实现规格 $\to$ 输出**

- **输入**：原始业务需求
- **PRD**：用户场景 + 成功指标
- **系统设计**：模块依赖 + 数据流 + 决策决策
- **Spec**：API 定义 + 表结构 + 业务逻辑
- **输出**：高质量交付物（Code）

### 5. 应用

#### 决策规则

- **IF** 涉及金融支付、高并发或跨团队复杂系统
  - **THEN** MUST 执行完整三层文档协议
- **IF** 处于初创期、内部工具或低风险迭代
  - **THEN** 可采用"轻量 PRD + 代码即文档（Swagger/Figma）"的两层模式

#### 核心检查清单

- [ ] **PRD 环节**：核人指标（KPI）是否具备可度量性？
- [ ] **系统设计环节**：是否包含了架构图、关键决策（SQL/NoSQL）及其非功能性需求（性能/安全）？
- [ ] **Spec 环节**：API 接口（REST/GraphQL）与数据表索引设计是否已锁定？
- [ ] **同步校验**：Spec 的细节是否完美覆盖了 PRD 中的业务边界？

---

## 四、技术文档：极简矩阵

| 特性 | RFC / 设计文档 | ADR (决策记录) | 技术设计方案 | 部署计划 / 运维手册 |
|:--- |:--- |:--- |:--- |:--- |
| **核心** | **为什么**做 & **做什么** | **为什么**这样选 | **如何**实现细节 | **如何**上线 & 回滚 |
| **范围** | 跨团队大型变更 | 关键决策点 | 单个功能/服务 | 具体的发布流程 |
| **时机** | 项目最早期 | 选型确定后 | 开发前 | 部署前 |
| **重量** | **重** (达成共识) | **轻** (记录背景) | **中** (指导开发) | **重** (操作精确) |
| **目标** | 战略对齐 | 历史溯源 | 消除实现歧义 | 安全发布 | 快速回滚 |

### 实例演示：实时协作功能

**RFC（Request for Comments）**

**标题**：引入实时协作引擎

- **摘要**：实现类似 Google Docs 的多人编辑，提升协作效率
- **动机**：当前数据覆盖冲突严重，竞品已支持
- **目标**：延迟 < 200ms；并发连接 > 10,000

**ADR (决策记录)**

- **标题**：ADR-005: 采用 WebSocket 协议
- **状态**：已接受
- **背景**：需在 WebSocket 与 Long-Polling 间选型
- **决策**：使用 WebSocket
- **理由**：
  - 全双工通信，延迟极低
  - 省省服务器连接开销
- **后果**：
  - 需配置网关 (Nginx) 支持连接
  - 客户端需实现断线重连逻辑

**技术设计方案**

- **接口**：
  - WS: `join_task` / `new_comment`
  - REST: `POST /comments` (数据持久化)
- **前端**：监听 `new_comment` 事件 $\rightarrow$ 动态插入 DOM

**部署计划**

- **窗口**：2026-01-15 02:00 - 03:00 AM
- **步骤**：
  1. 开启维护模式
  2. 备份数据库
   3. 执行 `V3.2.1` SQL 迁移
  4. 部署 `collab-service`
  5. 部署 `main-app`
- 6. 验证：Pod 运行状态 $\rightarrow$ 测试账号实测 $\rightarrow$ 监控连接数
- 7. 回滚预案：5xx 报错 $\rightarrow$ 回退代码版本 $\rightarrow$ 缩容新服务 $\rightarrow$ 执行数据库回滚脚本

---

**关联笔记**
- [[智能 Agent 架构关键范式]]
- [[微服务架构完全指南]]
- [[AI协作完全指南]]
- [[企业应用架构模式]]
