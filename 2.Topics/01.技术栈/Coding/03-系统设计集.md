---
tags:
  - SystemDesign
  - Architecture
  - DistributedSystems
  - Performance
  - Patterns
related:
  - "[[系统架构分类框架]]"
  - "[[12-Factor App 故障排查手册]]"
  - "[[企业应用架构模式]]"
  - "[[数据库类型的最佳使用场景]]"
  - "[[常用中间件]]"
---

# 系统设计集

> 本文档整合了系统设计相关的核心原则、模式与实践，为工程师提供完整的系统设计知识体系。

---

## 📚 一、架构设计原则

### 1. No Magic, Just Code
*源自：[[No Magic, Just Code设计哲学]]*

**核心理念**：
- 代码应该清晰易懂，避免"魔法"和隐藏的复杂性
- 显式优于隐式
- 简单性优于聪明性

**实践原则**：
- 避免使用过度抽象的设计模式
- 代码命名应该清晰表达意图
- 复杂逻辑应该有明确的注释和文档

---

### 2. 系统架构分类框架
*源自：[[系统架构分类框架]]*

**核心公式**：
- 架构 = 权衡（Trade-off）
- 复杂度 ∝ 状态同步成本
- 陷阱 = 忽视非线性边界

**核心系统冲突与破局**：
| 系统分类 | 核心冲突 | 破局关键 |
|:--- |:--- |:--- |
| **网络系统** | 延迟 vs 带宽 | 连接复用 (H2/QUIC) + 协议压缩 |
| **数据库** | 一致性 vs 可用性 | 权衡一致性模型；Saga/补偿事务 |
| **消息队列** | 顺序性 vs 吞吐量 | 幂等设计 + 动态流控 + 多分区并行 |
| **流处理** | 实时性 vs 准确性 | Watermark 策略 + 精准一次 (Exactly-Once) |
| **日志/仓储** | 检索速度 vs 成本 | 热冷分离 + 索引降噪 + 数据倾斜优化 |
| **库存/支付** | 高并发 vs 准确性 | 预留+确认机制；强幂等控制；实时对账 |
| **身份/权限** | 安全 vs 性能 | Token 生命周期权衡；细粒度缓存策略 |
| **AI 训练** | GPU 利用率 vs 通信开销 | 数据/模型并行策略；异步 Checkpoint |
| **云原生** | 可靠性 vs 复杂度 | 熔断重试机制；故障域隔离；连接池优化 |

**架构避坑雷达（常见陷阱）**：
- **过度设计**：业务可容忍最终一致，却强推强一致导致性能崩溃
- **环境偏差**：将局域网优化策略直接搬到公网，忽视高延迟/丢包
- **资源浪费**：对 TB 级日志全字段建立全文索引，导致存储成本失控
- **状态爆炸**：无状态流处理外推至有状态计算，未考虑状态集合的无界增长
- **级联故障**：缺少降级/超时处理，单个下游服务故障拖垮全局

**架构师诊断三步法**：
1. **定位层级**：基础设施、数据处理、业务逻辑、还是安全合规？
2. **提取矛盾**：该场景下最不可调和的两个变量是什么？
3. **边界模拟**：流量/数据量增加 10 倍，哪个节点最先发生"非线性崩溃"？

**黄金法则**：没有完美方案，只有在特定约束下成本最优的权衡。

---

### 3. 系统设计与架构模式
*源自：[[系统设计与架构模式]]*

**常见架构模式**：

| 模式 | 适用场景 | 优点 | 缺点 |
|------|----------|------|------|
| **单体架构** | 小型项目、快速交付 | 开发简单、部署容易 | 扩展性差 |
| **分层架构** | 中型项目、清晰边界 | 职责清晰、易于测试 | 过度设计 |
| **微服务架构** | 大型项目、团队协作 | 扩展性强、故障隔离 | 运维复杂 |
| **事件驱动架构** | 高并发场景、解耦需求 | 松耦合、异步处理 | 复杂度高 |

**设计原则**：
- **单一职责**：每个组件只负责一个功能
- **开闭原则**：对扩展开放，对修改关闭
- **依赖倒置**：高层模块不应依赖低层模块
- **接口隔离**：客户端不应依赖它不需要的接口

---

### 4. 企业应用架构模式
*源自：[[企业应用架构模式]]*

**核心模式**：
- **领域模型（Domain Model）**：将业务逻辑封装在领域模型中
- **数据传输对象（DTO）**：在层之间传递数据
- **服务层（Service Layer）**：封装业务逻辑
- **仓储模式（Repository）**：抽象数据访问

**实践建议**：
- 根据项目复杂度选择合适的架构模式
- 避免过度设计，遵循 YAGNI 原则
- 保持架构的灵活性，便于后续演进

---

### 5. 12-Factor App 故障排查手册
*源自：[[12-Factor App 故障排查手册]]*

**总体故障观**：
- 故障 ≠ 异常 → 故障 = 设计必然
- 可恢复性 > 不出错 → 系统假设会失败
- 配置可变 代码不变 → 降低环境耦合
- 自动化优先 → 人是最大不确定性

**八大维度故障排查**：

| 维度 | 核心原则 | 常见陷阱 |
|:---|:---|:---|
| **配置/环境** | 配置入环境变量 → 避免硬编码 | ❗ 配置漂移 → 故障根源 |
| **依赖/构建** | 显式声明依赖 → 隐式=不可复现 | ❗ 热修代码 → 技术债加速器 |
| **运行时/进程** | 无状态进程 → 可水平扩展 | ❗ 本地状态 → 扩展性杀手 |
| **服务/依赖交互** | 外部服务即资源 → 随时可替换 | ❗ 服务假定稳定 → 级联故障源 |
| **并发/扩展** | 进程扩展而非线程 → 结构清晰 | ❗ 垂直扩展 → 成本指数上升 |
| **日志/可观测性** | 日志是事件流 → 非文件 | ❗ 无结构日志 → 排障噩梦 |
| **管理任务/调试** | 管理任务=一次性进程 → 与主服务同配置 | ❗ 手工修Prod → 不可复现 |

**故障排查终极模型**：
- **问题定位顺序**：配置 → 依赖 → 进程 → 服务 → 并发 → 日志
- **核心信条**：能自动恢复的系统，才配上线
- **反模式总结**："在Prod手改配置 + 本地状态 + 无日志"

---

### 6. IOC 和 DI
*源自：[[IOC（控制反转）和 DI（依赖注入）]]*
*源自：[[300行代码解释依赖注入的原理]]*

**控制反转（IoC）**：
- 将对象的创建和依赖关系的管理交给容器
- 降低组件之间的耦合度
- 提高代码的可测试性

**依赖注入（DI）**：
- 通过构造函数、setter 方法或接口注入依赖
- 三种注入方式：构造函数注入、setter 注入、接口注入

**实现示例**（伪代码）：
```python
# 不使用 DI
class Service:
    def __init__(self):
        self.db = Database()  # 紧耦合

# 使用 DI
class Service:
    def __init__(self, db: Database):  # 依赖注入
        self.db = db
```

---

## 📚 二、分布式系统

### 1. 分布式集体组合策略
*源自：[[分布式集体组合策略]]*

**核心概念**：
- 多个独立的节点通过协议协作完成任务
- 每个节点都是自治的，没有中心控制

**组合策略**：
- **主从复制**：一个主节点处理写操作，多个从节点处理读操作
- **多主复制**：多个主节点都可以处理写操作
- **分区**：数据分布在不同的节点上

---

### 2. 任务队列 vs 消息队列
*源自：[[消息队列vs任务队列]]*

| 特性 | 任务队列 | 消息队列 |
|------|----------|----------|
| **用途** | 异步任务处理 | 事件驱动、解耦 |
| **保证** | 至少执行一次 | 至少投递一次 |
| **重试** | 自动重试失败任务 | 消息确认机制 |
| **典型实现** | Celery, Sidekiq | RabbitMQ, Kafka |

**选择建议**：
- 需要异步处理后台任务 → 任务队列
- 需要事件驱动、系统解耦 → 消息队列
- 需要高吞吐量的日志处理 → Kafka
- 需要可靠投递、灵活路由 → RabbitMQ

---

### 3. 常用中间件
*源自：[[常用中间件]]*

| 中间件 | 类型 | 特点 | 适用场景 |
|--------|------|------|----------|
| **Redis** | 缓存/存储 | 高性能、数据结构丰富 | 缓存、会话存储 |
| **RabbitMQ** | 消息队列 | 可靠投递、灵活路由 | 任务队列、事件驱动 |
| **Kafka** | 消息队列 | 高吞吐、可持久化 | 日志处理、流处理 |
| **Elasticsearch** | 搜索引擎 | 全文搜索、实时索引 | 日志分析、数据搜索 |
| **Nginx** | 反向代理 | 高性能、负载均衡 | API 网关、静态资源 |

---

### 4. 工具链与编排框架
*源自：[[工具链与编排框架]]*

**编排框架**：
- **Kubernetes**：容器编排，管理容器化应用
- **Docker Compose**：本地开发环境编排
- **Nomad**：轻量级编排，支持多种工作负载

**工具链**：
- **CI/CD**：Jenkins, GitLab CI, GitHub Actions
- **监控**：Prometheus, Grafana
- **日志**：ELK Stack（Elasticsearch, Logstash, Kibana）
- **追踪**：Jaeger, Zipkin

---

## 📚 三、性能与优化

### 1. 代码认知负荷
*源自：[[代码认知负荷：高效工程的底层度量]]*

**核心概念**：
- 认知负荷是理解代码所需的脑力消耗
- 高认知负荷的代码难以维护和扩展

**降低认知负荷的方法**：
- 使用清晰的命名
- 保持函数短小精悍
- 避免深层嵌套
- 使用一致的代码风格

---

### 2. 性能瓶颈排查
*源自：[[线上应用性能瓶颈与报错排查思路]]*

**排查思路**：
1. **监控指标**：CPU、内存、磁盘 I/O、网络 I/O
2. **应用指标**：响应时间、吞吐量、错误率
3. **数据库指标**：查询时间、连接池使用率
4. **缓存指标**：命中率、过期率

**优化策略**：
- **算法优化**：选择更高效的算法
- **数据结构优化**：选择合适的数据结构
- **缓存优化**：增加缓存、提高缓存命中率
- **异步处理**：将同步改为异步
- **负载均衡**：分散请求到多个实例

---

### 3. 并发基础核心
*源自：[[并发基础核心解析]]*

**核心概念**：
- **并发**：多个任务在同一时间段内执行
- **并行**：多个任务在同一时刻执行
- **同步**：保证数据一致性
- **竞态条件**：多个线程同时访问共享数据导致的问题

**并发模型**：
- **共享内存模型**：线程通过共享内存通信
- **消息传递模型**：线程通过消息通信

**最佳实践**：
- 尽量使用无锁数据结构
- 避免死锁
- 使用线程池管理线程资源

---

### 4. 多线程的主要用途
*源自：[[多线程的主要用途]]*

**主要用途**：
- **提高响应性**：UI 线程与工作线程分离
- **提高吞吐量**：并行处理多个任务
- **利用多核**：充分利用多核 CPU

**应用场景**：
- IO 密集型任务：网络请求、文件读写
- CPU 密集型任务：数据处理、图像处理

---

## 📚 四、数据与存储

### 1. 数据库选型
*源自：[[数据库类型的最佳使用场景]]*

| 数据库 | 适用场景 | 特点 |
|--------|----------|------|
| **MySQL** | 通用关系型数据 | 成熟稳定、生态完善 |
| **PostgreSQL** | 复杂查询、JSON 数据 | 功能强大、扩展性好 |
| **MongoDB** | 文档型数据 | 灵活的 Schema、高性能 |
| **Redis** | 缓存、实时数据 | 高性能、数据结构丰富 |
| **Elasticsearch** | 全文搜索、日志分析 | 强大的搜索能力 |
| **Cassandra** | 大规模写入 | 高可用、可扩展 |

**选型决策**：
- 数据结构是否固定？固定 → 关系型，灵活 → NoSQL
- 查询类型是什么？事务查询 → SQL，全文搜索 → Elasticsearch
- 数据量多大？小量 → MySQL，海量 → Cassandra
- 实时性要求？高实时 → Redis，可接受延迟 → 其他

---

### 2. 数据库要点
*源自：[[数据库要点]]*

**设计原则**：
- **范式化**：减少数据冗余，避免数据不一致
- **索引**：合理使用索引提高查询性能
- **分区**：大表分区提高性能
- **读写分离**：主库写、从库读，分担压力

**性能优化**：
- 慢查询分析：找出性能瓶颈
- 索引优化：创建合适的索引
- 查询优化：避免全表扫描
- 连接池：减少连接创建开销

---

### 3. 实时应用架构设计
*源自：[[实时应用架构设计指南]]*

**核心组件**：
- **消息队列**：异步处理消息
- **WebSocket**：实时双向通信
- **流处理**：实时数据处理
- **缓存**：快速访问热点数据

**架构模式**：
```
客户端 → WebSocket → API 网关 → 消息队列 → 消费者 → 数据库
                  ↓
                 缓存
```

---

### 4. 学习知识库架构
*源自：[[学习知识库架构]]*

**核心原则**：
- **连接优先**：笔记之间应该有丰富的链接
- **原子化**：每个笔记只讨论一个主题
- **可检索**：使用标签和元数据提高可检索性

**最佳实践**：
- 使用双向链接
- 创建索引笔记
- 定期回顾和整理

---

## 📚 五、设计方法论

### 1. Task Graph 建模
*源自：[[Task Graph建模适用场景]]*

**核心概念**：
- 将任务建模为有向无环图（DAG）
- 节点表示任务，边表示依赖关系

**适用场景**：
- 工作流自动化
- 数据管道（Data Pipeline）
- CI/CD 流水线
- 调度系统

**建模示例**：
```
      [任务A]
        ↓
    [任务B] → [任务C]
        ↓         ↓
    [任务D] ← [任务E]
```

---

### 2. 逻辑判断的三个维度
*源自：[[逻辑判断的三个维度]]*

**三个维度**：
1. **布尔逻辑**：真/假判断
2. **模糊逻辑**：程度判断（非常、比较、一般）
3. **概率逻辑**：可能性的判断（大概率、小概率）

**应用场景**：
- 风险评估：使用概率逻辑
- 决策支持：使用模糊逻辑
- 条件判断：使用布尔逻辑

---

### 3. 系统设计文档
*源自：[[系统设计文档与 PRD、Spec]]*

**文档层级**：
- **PRD（产品需求文档）**：描述"做什么"
- **系统设计文档**：描述"怎么架"
- **Spec（规格说明）**：描述"怎么写"

**协作架构**：
```
PRD（PM） → 系统设计（架构师） → Spec（开发） → 代码
```

**核心主张**：
软件质量取决于产品价值、架构蓝图与实现细节之间的逻辑连续性。

---

### 4. 开发过程中的关键不变量
*源自：[[开发过程中的关键不变量]]*

**不变量示例**：
- 数据一致性：关键数据必须保持一致
- 安全性：用户权限必须得到保证
- 可用性：系统必须保持可用

**实践方法**：
- 明确识别系统的不变量
- 通过测试验证不变量
- 在代码中保护不变量

---

### 5. 纽约客笔记架构优化建议
*源自：[[纽约客笔记架构优化建议]]*

**优化方向**：
- **结构化**：使用清晰的结构组织笔记
- **标签化**：使用标签分类笔记
- **链接化**：在笔记之间创建链接
- **定期回顾**：定期回顾和整理笔记

---

### 6. 跨领域播客 Transcript 快速框架构建法
*源自：[[跨领域播客 Transcript 快速框架构建法]]*

**构建方法**：
1. **快速浏览**：了解主要内容
2. **提取关键概念**：识别核心观点
3. **构建框架**：组织概念之间的关系
4. **填充细节**：补充具体内容
5. **总结提炼**：形成可传播的框架

---

### 7. 逐字稿风格：高转化脚本架构指南
*源自：[[逐字稿风格：高转化脚本架构指南]]*

**架构要素**：
- **开场**：吸引注意力
- **痛点**：触发共鸣
- **解决方案**：提供价值
- **证明**：建立信任
- **行动号召**：引导行动

---

## 🔗 参考资源

- [[2.Topics/系统构建/01-架构设计方法论集]] - 系统构建中的架构设计
- [[2.Topics/系统构建/02-后端工程实践集]] - 后端工程实践
- [[系统架构分类框架]] - 核心架构分类框架
