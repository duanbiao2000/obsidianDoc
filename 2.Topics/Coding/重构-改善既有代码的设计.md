---
date: 2025-08-23 14:49
tags:
  - 重构
view-count: 5
update: 2026-01-08 17:12
related:
  - "[[原则驱动行动]]"
  - "[[2025-12-07-2026开发思维模型转变]]"
  - "[[教练式CodeReview特征指南]]"
  - "[[2025-12-07- 教练式 Code Review]]"
---

## 自测试代码 · 现代实用主义提炼版（20% 关键信息）

### ★ 一句话总纲

> **绝大多数情况下，如果想要重构，必须先有可自测试的代码。**
> —— Martin Fowler, *Refactoring* 〔[mf-stc]〕

自测试代码 = 你每次改动，都能用一键测试立刻知道**有没有把东西弄坏**。

---

### 1. 核心定义 & 价值（What & Why）

**自测试代码（Self-Testing Code）**：

- 每段关键业务逻辑，都有对应的**自动化测试**（单元 / 集成 / 端到端）
- 改代码 → 跑测试 → 快速反馈：行为是否被破坏

**现代实用主义视角：**

- 价值 / 真理 = 实际效果：
  - 没有测试 → 不敢重构 → 架构烂尾、技术债堆积
  - 有测试 → 敢动老代码 → 系统能持续演化
- 实践是唯一反馈：
  - 测试就是把“预期行为”变成可反复执行的反馈通道
- 足够好 > 完美：
  - 不追求一开始全覆盖，只要关键路径被测试保护，你就已经赢过大多数团队

---

### 2. 高 ROI 决策原则（Decide）

按二八定律，把测试优先砸在**20% 最关键代码**上：

1. **prioritize**
   - 优先给这些地方补测试：
     - 核心业务流程（下单、支付、登录…）
     - 历史故障高发模块（经常出 Bug 的地方）
     - 即将重构 / 大改动的模块
   - 原则：**没有测试，就不要大规模重构**

2. **select**
   - 选最简单可落地的工具链：
     - 语言自带测试框架（JUnit / pytest / Jest…）
     - 现有 CI 能跑的东西，而不是“看起来高级但没人会用”的方案
   - 不为追新工具而增加复杂度

3. **balance**
   - 明确取舍：
     - 新功能开发 vs. 补关键测试
     - 交付速度 vs. 技术债
   - 实用做法：
     - 对每个需求/迭代，预留一小块时间**专门写测试 & 还技术债**

---

### 3. 高 ROI 行动原则（Do）

1. **adopt「足够好」策略**
   - 不从“全项目测试体系”起步
   - 从**一个模块 + 几个关键用例**开始：
     - Happy path（正常流程）
     - 1–2 个核心异常场景

2. **focus 最小化行动（MVP 测试）**
   - 重构前：
     - 先写测试**冻结当前行为**（哪怕它现在设计很烂）
   - 改完后：
     - 跑测试确认行为不变，再谈优化 / 重构下一块
   - 避免一口气重构全局却没有安全网

3. **transform 笔记 → 可执行步骤**
   - 不写“如何写好测试”的大段感想
   - 写成可执行清单：
     - 下一次在某模块动刀前，要先补哪 3 个测试用例？
     - CI 中要加哪条命令？（如 `npm test` / `pytest`）

4. **use 反馈驱动学习**
   - 每次测试失败：
     - 不是“麻烦”，而是暴露设计问题 / 边界条件的信号
   - 用失败案例倒推：
     - 哪些逻辑应该拆分？
     - 哪些依赖需要替换为可模拟的接口？

---

### 4. 最小落地清单（可以今天就做）

1. 选一个你**最常改动**的模块：
   - 为其中 1–2 个最关键函数 / API 写**第一个单元测试**

2. 在 CI 中加一条规则：
   - 每次提交 / 合并前自动跑测试
   - 测试失败则阻止部署（哪怕现在只有少量测试）

3. 下次重构前，先做两步：
   - 用当前行为写 3–5 个测试“锁定”现状
   - 重构后确保这些测试仍然通过

4. 每周复盘一次：
   - 是否有“因为没测试，不敢改代码”的情况？
   - 下周选一个这样的点，先补测试再动手

---

### 5. 实用主义式总结

> 在当前你的团队 / 项目的约束下，\
> 哪 20% 的代码一旦出错代价最大？\
> 先给它们装上「自测试安全网」，\
> 你就获得了持续重构和演进系统的**最低可用资本**。

# 🛡️ 自测试代码：重构的唯一入场券

> **核心价值 (The 20%)**：没有自动化测试的代码重构是**赌博**。自测试代码不是为了“找Bug”，而是为了构建一张**安全网**，让你敢在不破坏现有功能的前提下，随时修改烂代码。

### ⚡️ 关键行动 (Action Items)

1. **重构前置条件 (Pre-condition)**
   - **Action**: 严禁在裸奔（无测试）状态下重构。
   - **SOP**: 想改一段复杂逻辑？$\to$ 先为它补写测试（Capture Behavior） $\to$ 运行测试变绿 $\to$ 开始重构 $\to$ 再次运行测试变绿。

2. **强制CI门禁 (Gatekeeper)**
   - **Action**: 把 `npm test` / `pytest` 加入你的部署脚本。
   - **Rule**: 测试失败 = 禁止合并/上线。哪怕只是改了一个标点符号。

3. **测试即文档 (Tests as Docs)**
   - **Action**: 写测试时，用业务语言命名（如 `should_calculate_discount_correctly`）。
   - **Value**: 新人看不懂代码逻辑？让他去看测试用例。这比过期的Wiki文档靠谱一百倍。

4. **最低限度覆盖 (MVP Coverage)**
   - **Action**: 别追求 100% 覆盖率，那是不懂 ROI 的表现。
   - **Focus**: 优先覆盖**核心业务逻辑**（如支付计算、权限校验）和**常改动的模块**。UI 样式、Getter/Setter 没必要测。

### 🚫 避坑指南 (Anti-Patterns)

- **事后补测试 (Test Last)**：代码写完了再补测试，往往是为了凑覆盖率指标，既痛苦又没用。**测试应该辅助你设计接口（TDD）。**
- **过度Mock (Mock Hell)**：把所有外部依赖都 Mock 掉，导致测试通过了，线上服务却连不上数据库。**保留适量的集成测试。**
- **只测快乐路径 (Happy Path Only)**：只测输入正确的情况。**真正的Bug都在边缘情况（Edge Cases）和错误处理里。**

### 💡 实用洞见 (Pragmatic Insight)

- **Refactoring Capability**: 团队的技术水平，不看用的框架多新，而看**敢不敢动那一坨 5 年前的核心代码**。有测试就敢，没测试就“屎山堆积”。
- **Asset vs Liability**: 没有测试的代码是**债务**（Liability），有测试的代码才是**资产**（Asset）。

**System Status**: Extraction Complete. 案例已剥离，行动法则已固化。
