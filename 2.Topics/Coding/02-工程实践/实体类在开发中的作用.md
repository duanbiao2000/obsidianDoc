---
view-count: 2
---
在 Java 开发中，**实体类（Entity Class）** 是构建系统的“砖块”，它们在各个层级中承担着不同但关键的角色。下面是它们在实际开发中的主要应用场景：

---

### 🧱 1. 数据持久化（ORM 映射）
实体类通常与数据库中的表一一对应，是 ORM 框架（如 MyBatis、JPA、Hibernate）操作数据库的核心。

- 每个实体类代表一张表，字段对应表中的列
- 通过注解（如 `@Entity`、`@Table`、`@Column`）实现映射
- 示例：`UserEntity` 映射到 `user` 表

---

### 🔄 2. 数据传输（DTO/VO）
实体类也常作为 **数据传输对象（DTO）** 或 **视图对象（VO）**，在系统各层之间传递数据。

- Controller → Service → DAO 层之间传递数据
- 前后端交互时封装 JSON 数据
- 示例：`UserVO` 用于前端展示，`UserDTO` 用于接收注册请求

---

### 🧠 3. 业务逻辑封装
在领域驱动设计（DDD）中，实体类可以包含与自身相关的业务逻辑方法。

- 如 `OrderEntity` 中包含 `calculateTotalPrice()` 方法
- 提高代码的内聚性，避免“贫血模型”

---

### 🧪 4. 表单数据绑定
在 Web 开发中，实体类常用于接收前端表单提交的数据。

```java
@PostMapping("/register")
public ResponseVO register(@Valid UserRegisterVO vo) {
    // vo 中封装了用户名、密码、验证码等字段
}
```

---

### 📦 5. 缓存与消息传输
实体类也常用于 Redis 缓存、RabbitMQ 消息体等场景：

- 将实体类序列化为 JSON 存入 Redis
- 作为消息体发送到消息队列中

---

### 🧩 6. 接口文档生成（Swagger）
配合注解（如 `@ApiModel`、`@ApiModelProperty`），实体类可用于自动生成接口文档。

---

### ✅ 总结：实体类的多重身份

| 场景 | 作用 |
|------|------|
| ORM 映射 | 映射数据库表结构 |
| 数据传输 | 封装请求/响应数据 |
| 业务逻辑 | 封装与实体相关的行为 |
| 表单绑定 | 接收前端提交的数据 |
| 缓存/消息 | 存储或传输结构化数据 |
| 文档生成 | 自动生成接口说明 |

---

你在做的 EasyMeeting 项目中，像 `UserEntity`、`MeetingEntity` 就是典型的实体类，既用于数据库映射，也可能参与缓存、消息传输和前端展示。如果你想，我可以帮你梳理一下项目中实体类和 VO/DTO 的边界设计，或者生成一套规范的实体类模板 😄