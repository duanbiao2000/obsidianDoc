---
date: 2025-05-19 13:58
tags:
view-count: 5
---
# [[Concurrency_Evolution_History]] - 并发演进协议

---

## 1. 演进全景矩阵 (The Timeline)

| 时代 | 技术模型 | 核心驱动 (Why) | 瓶颈 (Bottleneck) |
| :--- | :--- | :--- | :--- |
| **1980s** | **多进程 (Multi-process)** | 掩盖 I/O 等待，CPU 利用率 | 内存爆炸、切换开销大 |
| **1990s** | **多线程 (Multi-threading)** | 内存共享，解决 C10K | 竞态条件、死锁、同步成本 |
| **2000s** | **事件驱动 (Callback)** | 消除 OS 调度开销 | 回调地狱、无法利用多核 |
| **2010s** | **协程 (Async/Await)** | 顺序代码 + 异步效率 | 库生态分裂、CPU 密集型阻塞 |
| **Today** | **分布式并发 (Distributed)** | 单机物理极限 | 网络延迟、一致性熵增 |

---

## 2. 核心协议详解

### A. 多进程时代：资源隔离
- **本质**: OS 强制剥夺 CPU 权。
- **Why**: CPU 速度 > I/O 速度 100 倍，通过切换任务榨干 CPU。
- **Trade-offs**: 
    - **得**: 强隔离（崩溃不蔓延）、逻辑简单。
    - **失**: 内存极度昂贵 (每个进程 50MB+)，IPC 通信复杂。

### B. 多线程时代：内存共享
- **本质**: 轻量级进程，共享堆空间。
- **Why**: 解决进程过重导致的 C10K 内存压力。
- **Trade-offs**:
    - **得**: 内存利用率高、数据交换零成本。
    - **失**: 编程复杂度指数级上升（Lock/Mutex/Deadlock）。

### C. 事件驱动/回调：用户态调度
- **本质**: 1 个线程 + 1 个事件循环。
- **Why**: 线程数 > 10,000 时，OS 上下文切换耗尽所有 CPU。
- **Trade-offs**:
    - **得**: 极高并发（50,000+ qps）、无锁开销。
    - **失**: 代码逻辑碎片化（Callback Hell）、阻塞点卡死全局。

### D. 协程/Async：心智重构
- **本质**: 应用程序控制的“伪线程”。
- **Why**: 既要线程的“顺序代码”直觉，也要事件驱动的“非阻塞”性能。
- **Trade-offs**:
    - **得**: try/catch 可用、逻辑连续。
    - **失**: 库生态不兼容、遗漏 `await` 导致逻辑悬空。

---

## 3. 并发模型性能对比

| 指标 | 多进程 | 多线程 | 协程 (Async) |
| :--- | :--- | :--- | :--- |
| **创建成本** | 高 (毫秒级) | 中 (微秒级) | 极低 (纳秒级) |
| **内存开销** | ~50MB / 任务 | ~1MB / 任务 | ~2KB / 任务 |
| **切换成本** | 系统内核切换 (慢) | 系统内核切换 (快) | 用户态切换 (零开销) |
| **数据共享** | 困难 (IPC) | 极易 (共享内存) | 极易 (变量访问) |

---

## 4. 商业比喻：厨房演进

- **多进程**: 给每个订单盖一个**独立厨房**。安全但费钱。
- **多线程**: 1 个大厨房，**50 个厨师**挤在一起抢锅。容易打架（死锁）。
- **事件驱动**: 只有 **1 个超级服务员**。点单后闪现，不等菜出锅。
- **协程**: 服务员掌握了**分身术**。看起来在专心陪你，其实等菜时分身去扫地了。

---

## 5. 执行检查清单 (Checklist)

### 选型自测
- [ ] **高计算/低 I/O**: 选多线程 + 并行计算。
- [ ] **高 I/O / 低计算**: 选协程 (Node/Python/Go)。
- [ ] **强安全性要求**: 选多进程隔离。

### 风险红线
- [ ] **Lock**: 超过 3 个锁嵌套必查死锁。
- [ ] **Async**: 禁止在协程内调用阻塞型同步库。
- [ ] **Scaling**: 单机连接数 > 50,000 必须引入分布式均衡。

---

**最后更新: 2026-01-01**