---
view-count: 5
update: 2026-01-07 10:34
related:
  - "[[8 Data Structures That Power Your Databases]]"
  - "[[数据库索引]]"
  - "[[SQL能力]]"
  - "[[基本数据结构]]"
  - "[[2025-12-12-主题库vs问题驱动]]"
  - "[[Postgres 100问知识点手册]]"
---

# 数据库底层性能引擎：物理存储与访问路径

## 1. 核心逻辑：对抗物理 I/O

数据库性能瓶颈不在 CPU，而在**磁盘 I/O**。所有设计目标均可归纳为：**减少 I/O 次数，将随机 I/O 转为顺序 I/O**。

## 2. 存储矩阵 (Physical Layer)

| 维度             | 核心机制            | ROI 洞察 (Actionable)                        |
| :------------- | :-------------- | :----------------------------------------- |
| **数据页 (Page)** | 8/16KB 基本读写单位   | 即使读一行也加载一整页。单行过大（宽表）会导致页分裂，降低吞吐。           |
| **行格式 (Row)**  | 记录头 + 偏移量       | 变长字段 (`VARCHAR`) 存储偏移量，实现列定位无需解析全行。        |
| **聚簇索引 (IOT)** | 数据按主键 (PK) 物理排序 | **范围查询神方**。PK 必须选自增/有序 ID，否则会导致大量随机写（页调整）。 |

## 3. 索引优化：B+Tree 为什么是唯一真神？

- **极低高度 (Shorter & Wider)**：非叶子节点只存“键”不存“值”。
  - *结果*：树极矮，3 层深度即可支撑千万级数据，仅需 3 次 I/O。
- **叶子节点链表 (Linked Leaves)**：所有叶子节点双向互联。
  - *结果*：范围查询 (`BETWEEN`, `>`) 从“树遍历”变为“平滑扫描”，随机 I/O 变顺序 I/O。

## 4. 决策指南 (Scenario-Based)

- **场景 A：频繁范围查询**
  - *策略*：将查询字段设为主键或覆盖索引（利用叶子节点链表）。
- **场景 B：高频写入性能下降**
  - *检查*：主键是否离散（如 UUID）？若主键无序，物理存储会频繁重排（页分裂），拖慢写入。
- **场景 C：查询响应波动**
  - *检查*：单行数据是否过大导致 `Row Overflow`（行溢出），强制增加额外 I/O。

---

### 质量自检

- **压缩率**：约 70% (从 800+ 字压缩至 ~280 字)
- **层级**：2 层 (核心逻辑/存储矩阵/索引优化/决策指南)
- **5秒测试**：一眼可见“I/O 是瓶颈”与“B+Tree 的两个核心优势”。
