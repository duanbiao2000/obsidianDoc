---
view-count: 5
---
I'll help you rewrite this note in the brutally minimal style. Let me first read the uploaded file to see the patterns used in previous examples.Based on the patterns I see in your conversation history, here's the brutally minimal version:

# [[2025-12-03-并发基础核心解析]]：极简版

## 核心公式
**并发 = 交替执行 (宏观并行)**
**进程 = 资源隔离**
**线程 = 轻量执行单元**
**锁 = 数据一致性保障**

---

## 1. 核心概念对比

| 维度 | 进程 (Process) | 线程 (Thread) |
|:--- |:--- |:--- |
| **定义** | 资源分配最小单位 | CPU 调度最小单位 |
| **资源** | 独立内存空间 | 共享进程内存 |
| **通信成本** | 高 (IPC 机制) | 低 (共享内存) |
| **切换开销** | 大 (完整上下文) | 小 (仅栈空间) |
| **稳定性** | 独立崩溃 | 连带进程崩溃 |

---

## 2. 语言实现差异

### Java (原生多线程)
- **工具 |** `Thread` 类 / `Runnable` 接口。
- **特性 |** 真多核并行，无 GIL 限制。

### Python (GIL 约束)
- **工具 |** `threading` 模块。
- **限制 |** CPU 密集型无法多核，IO 密集型仍有效。
- **破局 |** CPU 密集任务必须用 `multiprocessing` (多进程)。

---

## 3. 同步机制 (竞态防护)

### 核心问题
- **竞态条件 (Race Condition) |** 多线程同时读写共享资源 $\rightarrow$ 数据不一致。

### 解决方案
- **Lock (锁) |** 独占锁 (一个线程持有) / 共享锁 (多读线程持有)。
- **Mutex (互斥量) |** 专用于进程间互斥 (与 Lock 功能重叠)。
- **操作 |** `acquire()` 获取 $\rightarrow$ 执行临界区 $\rightarrow$ `release()` 释放。

---

## 4. 实践自检
- [ ] CPU 密集型是否误用了 Python 多线程？
- [ ] 共享资源修改是否加锁保护？
- [ ] 锁的粒度是否过大导致性能退化？

---

## 黄金法则
**IO 密集选线程，CPU 密集选进程，共享数据必加锁。**

---
**关联笔记：** [[2025-12-07-系统架构分类框架]] | [[2025-12-05-Python学习套件]]