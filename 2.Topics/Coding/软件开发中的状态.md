---
view-count: 4
update: 2026-01-08 19:58
related:
  - "[[React19高可用开发实例]]"
  - "[[React开发范式与架构分析]]"
  - "[[2025-12-07-系统架构分类框架]]"
---
## 软件中的「状态」进阶版 · 一页清

---

### 0. 核心再定义

> 在软件里，**状态（state） = 某一时刻系统内部「会影响接下来行为的全部信息」**。

形式化一点可以看成：

> (newState, output) = f(oldState, input)

- 状态不是所有数据，而是**对将来行为有影响的那部分数据**。
- 掌握状态本质 = 掌握「系统为什么这样行为，以及下一步会怎样」。

---

## 一、状态的关键维度（比“快照”更精确）

★ 1.1 生命周期维度  
- 瞬时状态：函数调用栈、本次请求中的局部变量  
- 会话状态：一次会话期间有效（登录态、购物车）  
- 长期持久状态：数据库记录、配置、用户数据

★ 1.2 可见性维度  
- 局部状态：函数 / 组件内部私有（React 组件 state）  
- 模块级状态：模块内部共享（单例对象、模块级缓存）  
- 进程级状态：整个服务实例共享（全局变量、连接池）  
- 分布式状态：多节点共享（分布式缓存、数据库、副本）

★ 1.3 持久性维度  
- 内存状态（in-memory）：随进程消失  
- 持久状态（persistent）：落在磁盘 / DB / 日志中  
- 派生状态（derived）：可由其他状态运算得到（缓存、索引）

---

## 二、用「状态机」来建模系统行为

### 2.1 有限状态机（FSM）核心

- 有限集合：**状态 S + 输入 I + 转移函数 δ**  
- 本质：**用少量离散状态 + 明确转移规则**，替代「一堆 if-else」

例：订单状态机  
- 状态：Created → Paid → Shipped → Completed / Cancelled  
- 事件：支付成功、发货、确认收货、取消  
- 规则：  
  - Created 只能接收「支付成功 / 取消」  
  - Shipped 不能再「取消」

★ 好处：  
- 状态空间清晰，可画图、可验证  
- 易于发现「不该发生的转移」

---

## 三、状态与「纯函数 / 副作用」

### 3.1 纯函数 vs 有状态

- 纯函数：output 只取决于 input，不依赖外部状态，也不修改外部状态。  
- 有状态函数：行为依赖或修改外部状态（时间、随机数、全局变量、DB）。

★ 函数式编程的核心目标之一：  
> 把「逻辑计算」变成尽量多的纯函数，把「状态读写」控制在少数位置。

好处：  
- 易测试（给定输入→确定输出）  
- 易推理（无隐蔽依赖）

---

## 四、复杂系统里的几类关键状态

### 4.1 UI / 前端状态

- 局部 UI 状态：输入框值、弹窗是否显示  
- 业务状态：登录态、购物车、当前用户信息  
- 远程状态：从后端拉来的数据（server state）

实践要点：  
- 单一事实来源（Single Source of Truth）：  
  - 避免同一业务状态在多个地方复制一份  
- 单向数据流（如 Redux）：  
  - 事件（action）→ 减速器（reducer）→ 新 state

---

### 4.2 后端 / 服务端状态

- 资源状态（REST 中的 R）：  
  - URL 指向一个资源，其表现形式（representation）就是其状态快照。  
- 会话 / token 状态：  
  - 登录凭证是否有效、权限范围。  
- 服务器运行状态：  
  - 连接数、线程池队列、缓存命中率、健康状况。

实践要点：  
- 尽量让 API **无状态（stateless）**：  
  - 每个请求独立可处理，所需状态由客户端或其他服务提供 → 便于横向扩展  
- 把需要「记住」的东西放进：
  - DB、缓存、消息队列，而不是随机的全局变量。

---

### 4.3 数据与 Event Sourcing

- 传统做法：只存「当前状态」  
  - 如：账号余额 = 100
- Event Sourcing：存一系列事件  
  - 如：存「充值 +100」「消费 -20」「补偿 +20」  
  - 当前状态 = 所有事件的聚合结果

好处：  
- 可追溯：能回答「为什么现在是 100？」  
- 可重放：支持新统计 / 新视角的引入

代价：  
- 读写逻辑更复杂，需要额外聚合层（CQRS）。

---

## 五、并发、一致性与状态

### 5.1 状态 + 并发 = 难点

典型问题：  
- 两个线程同时修改同一状态 → 脏写 / 丢数据  
- 多服务同时缓存同一条数据 → 不一致

### 5.2 控制手段

- 锁 / 互斥（悲观并发）：一次只允许一个修改者  
- 乐观并发：版本号 / 时间戳 + 更新失败重试  
- 事务（Transaction）：  
  - 要么全部成功，要么全部回滚（ACID）

### 5.3 CAP & 一致性模型（简化）

- CAP：一致性（C）、可用性（A）、分区容错（P）三选二（分布式系统必然要权衡）。  
- 最终一致（Eventually Consistent）：  
  - 一段时间内允许不同副本状态不一样，但最终收敛。

---

## 六、状态管理常见坑 & 原则

### 6.1 常见坑

- 状态到处都是：  
  - 全局变量、单例、隐式缓存 → 难以追踪  
- 状态重复：  
  - 多处各存一份「用户信息」，更新不同步  
- 隐式状态：  
  - 函数行为依赖未显式声明的外部条件  
- 状态爆炸：  
  - 用 bool + 枚举堆出几十种组合，没人知道哪几种合法

### 6.2 实践原则（高 ROI）

★ 原则 1：收敛状态来源  
- 为同一业务事实定义唯一「权威来源」（DB / 某服务）。  
- 其余视为缓存 / 视图，可丢弃或重建。

★ 原则 2：明确状态机  
- 对重要业务对象（订单、工单、用户生命周期）画状态图：  
  - 状态集合  
  - 合法转移  
  - 每个转移的触发事件 & 副作用

★ 原则 3：显式声明依赖  
- 函数签名、API 定义中写清楚：  
  - 读 / 写了哪些状态  
- 避免“顺便改了一下某个全局变量”。

★ 原则 4：弱化可变状态  
- 能用参数传递就不要用全局变量  
- 能用不可变数据（新对象）就少用原地修改

---

## 七、如何系统学习「状态」？（最小路径）

1. 从一个你熟悉的系统出发（如：电商 / 博客）：  
   - 画出：  
     - 用户 / 订单 / 支付的**状态机**  
     - 前端购物车 / 登录态的**状态流转**

2. 选一门技术栈深入一个维度：  
   - 前端：React 状态、Redux、server state（React Query）  
   - 后端：数据库事务、缓存一致性、REST 资源建模  
   - 分布式：CAP、一致性模型、Event Sourcing、CQRS

3. 写小实验：  
   - 手写一个简单状态机（有限几种状态 + 转移表）  
   - 增加并发场景，观察没加锁 / 加锁 / 乐观锁的差异。

---

### 收尾总结

- 「state」不是一个术语，而是你理解和控制软件行为的**主轴**。  
- 初级：知道有哪些状态。  
- 中级：知道状态在哪里读写、如何转换。  
- 高级：能设计出**简单、可验证、可扩展**的状态空间和转移规则。

如果你愿意，我可以下一步帮你把「状态机建模」应用到一个你正在写的真实模块（比如登录、订单流转、任务调度），做一份从需求 → 状态图 → 代码结构的完整示例。