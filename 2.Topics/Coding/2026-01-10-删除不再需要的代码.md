---
view-count: 4
update: 2026-01-10 11:38
related:
  - "[[2026-01-06-HNW 审美开发选题]]"
---

这是一个被严重低估但极其重要的工程实践：**如何安全、彻底、可验证地删除不再需要的代码**。很多团队“不敢删代码”，导致系统中堆积大量僵尸逻辑（zombie code），不仅增加维护成本，还埋下安全隐患和认知负担。

下面提供一套 **从理念到工具的完整方法论**，帮助你从“注释掉留着以防万一”走向 **“自信删除 + 可验证移除”**。

---

## ❌ 为什么“注释掉”是反模式？

```python
# def old_payment_handler(order):
#     # legacy logic from 2018
#     if order.gateway == "PayPalOld":
#         ...
```

### 问题：

- **代码仍在版本历史中** → 无法真正“清理”
- **IDE 仍会索引/提示** → 干扰开发
- **新人误以为“可能还会用”** → 不敢动
- **测试覆盖率虚高** → 注释代码不运行但占行数
- **技术债可视化失败** → 僵尸代码藏在注释里

> 💡 **记住：注释掉的代码 = 未完成的删除 = 技术债**

---

## ✅ 安全删除代码的四步法（Safe Code Deletion Protocol）

---

### 第一步：**确认“死代码”——用工具而非直觉**

不要凭感觉！使用静态分析工具自动检测：

| 语言                    | 工具                                                |
| --------------------- | ------------------------------------------------- |
| Python                | `vulture`, `dead`                                 |
| JavaScript/TypeScript | `ts-prune`, `unimported`, Webpack Bundle Analyzer |
| Java                  | `UCDetector`, IntelliJ “Unused Symbol”            |
| Go                    | `go-unused`, `staticcheck`                        |
| C#                    | Visual Studio “Remove Unused Members”             |

#### 示例（Python）：

```bash
pip install vulture
vulture myproject/  # 输出：myproject/utils.py:45: unused function 'old_logger'
```

✅ **产出**：一份**可验证的未使用代码清单**，而非主观猜测。

---

### 第二步：**分阶段删除 —— 先标记，再移除**

#### 阶段 1：添加“待删除”标记（Safe Marking）

```python
# DEPRECATED: Will be removed after 2026-03-01. Used by LegacyMobileApp (EOL).
def old_api_v1():
    ...
```

- 明确删除时间或条件
- 记录依赖方（如“仅被已下线的 App 使用”）

#### 阶段 2：监控调用（Observability）

如果无法确定是否被调用：

- 在函数入口加日志或指标：

  ```python
  def risky_function():
      metrics.increment("risky_function_called")  # 监控 2 周
      ...
  ```

- 若监控期内无调用 → 安全删除

> 📌 **原则**：**“可观察性是删除的前提”**

---

### 第三步：**彻底删除 + 提交信息规范**

#### 删除时：

- **单独提交**（不要混在功能 PR 中）
- **提交信息明确说明**：

  ```
  feat(clean): remove deprecated payment handler

  - Removed `old_paypal_handler()` (unused since 2025-10)
  - Confirmed via:
      * vulture scan
      * 30-day call metric = 0
      * LegacyMobileApp EOL on 2025-12-01
  ```

✅ **好处**：

- Git 历史清晰可追溯
- Code Review 聚焦“删除合理性”
- 回滚时知道删了什么

---

### 第四步：**验证删除效果（Verification）**

删除后必须验证：

| 验证项               | 方法                                       |
| ----------------- | ---------------------------------------- |
| **构建通过**          | CI 流水线跑通                                 |
| **测试覆盖不变/提升**     | 对比删除前后的测试覆盖率报告                           |
| **无新告警**          | 监控系统无异常（如 5xx 错误）                        |
| **包体积减小**（前端/移动端） | Webpack / Xcode 构建产物对比                   |
| **依赖图简化**         | 使用 `dependency-cruiser` 等工具生成调用图，确认无残留引用 |

> 🔍 **高级技巧**：\
> 在 CI 中加入 **“禁止新增注释代码”** 的检查：
>
> ```bash
> # 检查是否有连续3行以上注释代码（启发式）
> git diff --name-only | xargs grep -n "^\s*#.*def\|^\s*//.*function" || true
> ```

---

## 🛠️ 特殊场景处理

### 场景 1：**“可能以后会用”**

- **对策**：信任版本控制系统！\
  Git 保留了所有历史。真要恢复，用：

  ```bash
  git log -S "old_function_name"  # 找到删除它的 commit
  git show <commit>:path/to/file.py  # 查看旧代码
  ```

- **心理建设**：**“写代码的成本 << 维护僵尸代码的成本”**

### 场景 2：**公共库中的废弃 API**

- 使用 **正式弃用流程**：

  ```python
  import warnings

  def old_func():
      warnings.warn(
          "old_func is deprecated, use new_func() instead.",
          DeprecationWarning,
          stacklevel=2
      )
      ...
  ```

- 在下一个主版本（v2.0）中彻底删除

### 场景 3：**配置开关控制的代码（Feature Flag）**

- 删除步骤：
  1. 关闭开关（线上不再启用）
  2. 监控 1~2 周确认无调用
  3. 删除开关 + 相关代码
  4. 删除开关配置

---

## 📊 删除代码的价值（不只是“干净”）

| 维度       | 收益                      |
| -------- | ----------------------- |
| **可维护性** | 减少认知负荷，新人上手更快           |
| **安全性**  | 移除含漏洞的旧逻辑（如 MD5 加密、旧协议） |
| **性能**   | 减少包体积、启动时间、内存占用         |
| **可靠性**  | 避免“意外调用僵尸路径”导致故障        |
| **文化**   | 建立“持续清理”的工程文化，对抗熵增      |

---

## ✅ 终极建议：建立“删除仪式感”

- **每周五下午**：团队花 15 分钟，每人提交一个“小删除 PR”
- **设立“清理周”**：每季度专门处理技术债，包括代码删除
- **庆祝删除**：在 Slack 发个 🧹 表情：“刚删了 200 行僵尸代码！”

> 🗣️ **记住**：\
> **“优秀的程序员不仅会写代码，更懂得何时、如何安全地删除代码。”**\
> 删除不是破坏，而是**对系统未来的投资**。

如果你有具体想删但不敢删的代码片段，欢迎贴出来，我可以帮你设计安全删除方案！

---

`dependency-cruiser` 是一个非常有用的工具，主要用于分析 JavaScript 和 TypeScript 项目中的模块依赖关系。它可以帮助你生成可视化的依赖图，让你能够轻松地识别出项目中未使用的、孤立的或者不必要的依赖引用。这对于简化项目结构、清理僵尸代码（即那些不再需要但还留在项目中的代码）尤其有帮助。

### 使用 `dependency-cruiser` 的基本步骤

1. **安装 `dependency-cruiser`**：\
   首先，你需要在你的项目中安装 `dependency-cruiser`。可以通过 npm 或者 yarn 来进行安装。

   ```bash
   npm install --save-dev dependency-cruiser
   # 或者
   yarn add --dev dependency-cruiser
   ```

2. **配置 `.dependency-cruiser.js` 文件**：\
   在项目的根目录下创建一个配置文件（如 `.dependency-cruiser.js`），根据你的需求调整规则。例如，你可以定义哪些类型的依赖被认为是“允许的”，哪些是“不允许的”。

3. **运行分析**：\
   使用命令行来运行 `dependency-cruiser` 并生成报告。默认情况下，它会输出一个 JSON 格式的报告，但是通过使用不同的 reporters，你也可以生成 HTML、控制台文本等格式的报告。

   ```bash
   depcruise --config .dependency-cruiser.js src -x '**/*.test.js' -F html > dependency-graph.html
   ```

   这条命令将会分析 `src` 目录下的所有文件（排除测试文件），并生成一个 HTML 格式的依赖图。

4. **查看和分析结果**：\
   打开生成的 HTML 文件（或者其他格式的报告），检查依赖关系图。寻找任何异常的依赖路径或孤立的节点，这些可能是可以安全移除的僵尸代码或不必要的依赖。

5. **基于发现采取行动**：\
   根据 `dependency-cruiser` 提供的信息，开始删除或重构项目中的不必要代码和依赖。确保每一步操作后重新运行 `dependency-cruiser` 来验证改进。

通过这种方式，`dependency-cruiser` 不仅可以帮助你简化项目的依赖图，还能促进更好的代码组织和维护习惯。这在长期来看有助于提高代码质量，降低技术债务。
