---
view-count: 7
update: 2026-01-08 20:07
related:
  - "[[200组开发选题]]"
  - "[[PostgreSQL开发者实战指南]]"
  - "[[Anki卡牌仓库]]"
  - "[[Plan文档比较与实例]]"
  - "[[Prompt管理科学]]"

tags: ["Domain/Cognitive/Tools", "Type/Reference"]

---
> 💭 **Thinking Process**
>
> 1.  **意图识别 (Intent Recognition)**:
>     *   用户提供了一份关于“自建服务器”的原始笔记，内容涵盖硬件准备、NixOS 安装、Docker 部署、Caddy 配置、脚本自动化等。
>     *   目标：将这份笔记重构为一份“清晰的操作文档”。
>     *   隐含需求：需要结构化强、步骤明确、可复制性高 (Copy-Paste friendly)，适合新手或中级开发者直接照着做。需要去除冗余的理论描述，侧重实操。
>
> 2.  **内容结构分析 (Structure Analysis)**:
>     *   原笔记逻辑：理念 -> 硬件 -> 系统(NixOS) -> Docker -> 核心组件(Caddy/DB) -> 部署脚本 -> 安全 -> 监控 -> 扩展 -> 成本 -> 总结。
>     *   重构后逻辑应更符合操作流：前置准备 -> 系统配置 -> 服务编排 -> 自动化部署 -> 维护监控。
>
> 3.  **信息提取与优化 (Extraction & Optimization)**:
>     *   *OS*: 强调 NixOS 的 Declarative 特性，但为了通用性，可以将 NixOS 作为推荐，但也暗示通用 Linux 逻辑。
>     *   *Docker*: 将 Dockerfile 和 Compose 整合。
>     *   *Caddy*: 突出自动 HTTPS 的优势。
>     *   *Script*: 脚本部分是核心价值，需要高亮并解释每一步。
>     *   *Security*: 简化为防火墙和 SSH。
>
> 4.  **格式设计 (Format Design)**:
>     *   采用 Markdown。
>     *   使用 Emoji 增强视觉引导。
>     *   使用代码块分割具体操作。
>     *   增加“检查点 (Checkpoints)”让用户确认进度。
>
> 5.  **Drafting (草拟内容)**:
>     *   *标题*：自建服务器实战手册：基于 NixOS + Docker 的低成本方案。
>     *   *Phase 1 环境*：旧电脑 + NixOS 配置。
>     *   *Phase 2 服务*：Docker Compose + Caddy。
>     *   *Phase 3 自动化*：Shell 脚本 + Cron。
>     *   *Phase 4 运维*：日志与安全。
>
> 6.  **Refining (打磨)**:
>     *   *Script 优化*：解释为什么需要 `sleep 30` (等待新实例就绪)。
>     *   *Caddyfile*：确保格式正确。
>     *   *高 ROI 提示*：强调 Caddy 自动 HTTPS 的便利性。

### ✅ 正式回答

这是一份重构后的**自建服务器实战手册**。文档采用模块化结构，按操作顺序排列，可直接用于部署落地。

---

# 🛠️ 自建服务器实战手册：NixOS + Docker 零成本部署方案

> **文档目标**：利用旧硬件（如闲置笔记本），通过开源工具链实现企业级部署能力（零停机、HTTPS、CI/CD）。
> **核心栈**：NixOS (系统) + Docker (容器) + Caddy (网关) + Git (版本控制)。

---

## 📋 阶段一：基础设施准备 (Infrastructure)

### 1. 硬件要求
*   **设备**：任意 x86_64 电脑（旧笔记本/Mini PC）。
*   **网络**：需具备公网 IP 或配置内网穿透（Cloudflare Tunnel）。

### 2. 操作系统配置 (NixOS)
*推荐使用 NixOS 以实现配置即代码（Infrastructure as Code）。*

在 `/etc/nixos/configuration.nix` 中添加以下核心配置：

```nix
{ config, pkgs, ... }:

{
  # 1. 网络配置 (固定 IP)
  networking.interfaces.enp0s3.ipv4.addresses = [{
    address = "192.168.1.100";
    prefixLength = 24;
  }];
  
  # 2. 开放端口 (SSH, HTTP, HTTPS)
  networking.firewall.allowedTCPPorts = [ 22 80 443 ];

  # 3. 启用 SSH 服务
  services.openssh = {
    enable = true;
    settings.PasswordAuthentication = false; # 强制密钥登录
    settings.PermitRootLogin = "no";
  };

  # 4. 安装 Docker
  virtualisation.docker.enable = true;
  users.users.your_user.extraGroups = [ "docker" ];
}
```

---

## 🐳 阶段二：服务编排 (Orchestration)

在项目根目录下创建以下文件。

### 1. 构建镜像 (`Dockerfile`)
采用多阶段构建，减小镜像体积。

```dockerfile
# Stage 1: 构建
FROM gradle:7-jdk11 AS build
COPY . /app
WORKDIR /app
RUN gradle build --no-daemon

# Stage 2: 运行
FROM openjdk:11-jre-slim
COPY --from=build /app/build/libs/*.jar app.jar
# 暴露端口
EXPOSE 8080
CMD ["java", "-jar", "app.jar"]
```

### 2. 服务定义 (`docker-compose.yml`)
集成应用、网关与分析工具。

```yaml
version: '3.8'

services:
  # 主应用
  app:
    build: .
    restart: always
    networks:
      - web_net

  # 网关 (自动 HTTPS)
  caddy:
    image: caddy:2
    restart: always
    ports:
      - "80:80"   # HTTP
      - "443:443" # HTTPS
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile
      - caddy_data:/data
    networks:
      - web_net
    depends_on:
      - app

  # 流量分析 (轻量级替代 Google Analytics)
  plausible:
    image: plausible/analytics:latest
    restart: always
    networks:
      - web_net

networks:
  web_net:

volumes:
  caddy_data:
```

### 3. 网关配置 (`Caddyfile`)
Caddy 会自动申请并续期 SSL 证书。

```caddyfile
# 主域名
example.com {
    reverse_proxy app:8080
}

# 分析服务子域名
analytics.example.com {
    reverse_proxy plausible:8000
}
```

---

## 🚀 阶段三：自动化部署 (CI/CD)

通过 Shell 脚本实现 GitOps 风格的自动更新。

### 1. 零停机部署脚本 (`deploy.sh`)
利用 Docker Compose 的扩展功能实现滚动更新。

```bash
#!/bin/bash
set -e

echo "🚀 开始部署..."

# 1. 拉取代码 & 构建
git pull origin main
docker-compose build

# 2. 启动新实例 (扩容到 2 个)
# Caddy 会自动负载均衡到两个实例
docker-compose up -d --scale app=2 --no-recreate

# 3. 健康检查等待 (根据应用启动速度调整)
echo "⏳ 等待新实例启动..."
sleep 30

# 4. 移除旧实例 (缩容回 1 个)
# Docker 会优先保留最新的容器
docker-compose up -d --scale app=1

# 5. 重载 Caddy 配置 (可选，仅当 Caddyfile 变更时需要)
# docker-compose exec caddy caddy reload

echo "✅ 部署完成！"
```

### 2. 自动触发器 (`auto-deploy.sh`)
检测 Git 仓库是否有变动，仅在有更新时执行部署。

```bash
#!/bin/bash
cd /path/to/your/project

# 检查远程更新
git fetch origin
LOCAL=$(git rev-parse HEAD)
REMOTE=$(git rev-parse origin/main)

if [ $LOCAL != $REMOTE ]; then
    echo "📦 发现新版本，触发部署..."
    ./deploy.sh >> /var/log/deploy.log 2>&1
else
    echo "💤 无更新"
fi
```

### 3. 定时任务 (Cron)
每分钟检查一次更新。

```bash
# 编辑 crontab: crontab -e
* * * * * /path/to/your/project/auto-deploy.sh
```

---

## 🛡️ 阶段四：运维与监控 (Ops)

### 常用运维命令

| 任务 | 命令 |
| :--- | :--- |
| **查看实时日志** | `docker-compose logs -f --tail=100` |
| **查看错误日志** | `docker-compose logs app | grep "ERROR"` |
| **重启所有服务** | `docker-compose restart` |
| **进入容器Shell** | `docker-compose exec app /bin/bash` |

### 安全最佳实践
1.  **SSH Key Only**: 禁用密码登录，仅允许 SSH 密钥。
2.  **最小权限防火墙**: 仅开放 80, 443, 22 端口。
3.  **数据备份**: 定期备份 `caddy_data` 和数据库 Volume。

---

## 💡 总结：为什么选择此方案？

*   **💰 成本**: **$0** (除了电费和域名)。
*   **🔒 安全**: 代码在本地，数据在本地，没有云厂商锁定。
*   **⚡️ 体验**: **Push to Git -> 自动上线**，体验与 Vercel/Heroku 无异。
*   **📈 扩展**: 未来可平滑迁移至 K8s 或 Docker Swarm，但目前这就够了。