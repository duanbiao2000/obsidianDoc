
# 全栈工程师学习路线

---
aliases:

---
20230825 1214
links:
title:
origin: 
tags: #flashcards #todo 




9. 学习云计算：AWS、Azure 或 Google Cloud。

   云计算是一种通过网络提供按需共享的计算资源和数据的模型。它允许用户通过网络访问共享的计算资源，如服务器、存储、应用程序和服务，而无需拥有和管理这些资源。

   云计算的主要知识点包括云服务模型（如IaaS、PaaS和SaaS）、云部署模型（如公有云、私有云和混合云）、虚拟化技术、弹性计算、按需付费等。

   云计算的经典用法包括使用云存储来存储和共享数据、使用云服务器来托管应用程序和网站、使用云平台来开发和部署应用程序等。

   您可以了解更多关于云计算的知识点和经典用法，以便更好地利用云计算技术。

   云服务模型是指云计算提供商向用户提供的不同类型的云服务。目前，主流的云服务模型包括基础设施即服务（IaaS）、平台即服务（PaaS）和软件即服务（SaaS）三种。

   基础设施即服务（IaaS）是一种云服务模型，它提供了虚拟化的计算资源，如服务器、存储和网络。用户可以在这些虚拟化资源上安装操作系统和运行应用程序，而无需购买和维护物理硬件。IaaS提供商负责管理虚拟化基础设施，而用户则负责管理操作系统和应用程序。

   平台即服务（PaaS）是一种云服务模型，它提供了一个完整的开发和部署环境，用于构建、测试和运行应用程序。PaaS提供商负责管理基础设施、操作系统和中间件，而用户则负责开发和管理应用程序。

   软件即服务（SaaS）是一种云服务模型，它提供了完整的应用程序，可供用户通过网络访问。SaaS提供商负责管理基础设施、操作系统、中间件和应用程序，而用户只需使用应用程序即可。

   这些云服务模型为用户提供了不同层次的抽象和控制能力。IaaS提供了最低层次的抽象，用户需要管理更多的组件；而SaaS则提供了最高层次的抽象，用户只需使用应用程序即可¹。

   云计算的服务模型 - CSDN博客. https://blog.csdn.net/mukouping82/article/details/116403133
   
10. 学习 DevOps 工具：Docker、Kubernetes 或 Jenkins。

    Docker、Kubernetes和Jenkins都是用于开发和部署应用程序的工具。Docker是一个开源的容器化平台，它可以帮助开发人员将应用程序打包到容器中，以便在任何支持Docker的环境中运行。Kubernetes是一个开源的容器编排系统，它可以帮助开发人员管理和部署容器化应用程序。Jenkins是一个开源的持续集成和持续部署（CI/CD）工具，它可以帮助开发人员自动化构建、测试和部署应用程序。

    Docker、Kubernetes和Jenkins可以结合使用来实现自动化的应用程序部署。例如，您可以使用Jenkins来自动化构建Docker镜像，并将其推送到Docker仓库。然后，您可以使用Kubernetes来从Docker仓库中拉取镜像，并在Kubernetes集群中部署容器化应用程序。

    下面是一个简单的示例，演示了如何使用Jenkins、Docker和Kubernetes来实现自动化应用程序部署：

    1. 在Jenkins中配置一个构建任务，用于构建Docker镜像并将其推送到Docker仓库。
    2. 在Kubernetes集群中创建一个部署，用于从Docker仓库中拉取镜像并部署容器化应用程序。
    3. 在Jenkins中配置一个部署任务，用于触发Kubernetes集群中的应用程序部署。

    这只是一个简单的示例，您可以根据实际需求来定制您的CI/CD流程¹²。

    docker vs kubernetes in jenkins - Stack Overflow. https://stackoverflow.com/questions/70187818/docker-vs-kubernetes-in-jenkins 
    DevOps Using Jenkins, Docker, and Kuberneteshttps://www.betsol.com/blog/devops-using-jenkins-docker-and-kubernetes/ 

总之，成为全栈工程师需要学习多种技术和工具，但这也使得这个职业变得更加有趣和有挑战性。

### devops工程师需要掌握的技术栈

DevOps工程师需要掌握的技术栈包括开发和运维两方面的技能。在开发方面，DevOps工程师需要熟悉至少一种编程语言，了解软件开发的基本流程和方法。此外，DevOps工程师还需要熟悉持续集成和持续部署（CI/CD）工具，如Jenkins、Travis CI等。

在运维方面，DevOps工程师需要熟悉操作系统、网络和安全等基础知识。此外，DevOps工程师还需要熟悉虚拟化技术和容器化技术，如Docker和Kubernetes等。

除了技术技能，DevOps工程师还需要具备良好的沟通能力和团队合作精神。DevOps的目标是促进开发和运维团队之间的协作，因此DevOps工程师需要能够有效地与团队成员沟通，协调各方资源，推动项目顺利进行。

总之，DevOps工程师需要掌握广泛的技能，包括编程、软件开发、持续集成和持续部署、操作系统、网络、安全、虚拟化和容器化等。此外，良好的沟通能力和团队合作精神也是必不可少的¹²。

DevOps Best Practiceshttps://www.atlassian.com/devops/what-is-devops/devops-best-practices
What is a DevOps Engineer?https://www.atlassian.com/devops/what-is-devops/devops-engineer
DevOps 初学者入门指南https://zhuanlan.zhihu.com/p/22638204 

## 工具效率篇

Visual Studio Code是一款由微软开发且跨平台的免费源代码编辑器。它支持语法高亮、代码自动补全（又称 IntelliSense）、代码重构、查看定义功能，并且内置了命令行工具和 Git 版本控制系统。它具备两大优势：「键盘快捷键」和「丰富的插件」¹。

有一篇文章介绍了10个超级好用的VScode使用技巧，包括一次更改所有类似单词、将光标移到行的末尾和开头、代码折叠、打开终端、拆分屏幕、查找函数、版本控制、查看与上一修订版一起更改的行、查看日期和作者以及使用上次提交查看更改等¹。

希望这些信息对您有所帮助！

效率倍增！10个超级好用的VScode使用技巧！ - 知乎专栏. https://zhuanlan.zhihu.com/p/341534303 
VScode 教程 https://www.runoob.com/w3cnote/vscode-tutorial.html
VSCode编写C/C++的基础入门教程 - 知乎 - 知乎专栏. https://zhuanlan.zhihu.com/p/109335025 Accessed 
前端最强vscode教程（基础篇 https://zhuanlan.zhihu.com/p/382129498 

## JavaScript关键技术

以下是 JavaScript 的关键技术：

1. DOM（文档对象模型）：用于访问和操作 HTML 文档的 API。

2. AJAX（异步 JavaScript 和 XML）：用于在不重新加载页面的情况下更新网页内容的技术。

3. jQuery：一个流行的 JavaScript 库，用于简化 DOM 操作和 AJAX。

4. AngularJS：一个流行的 JavaScript 框架，用于构建单页应用程序。

5. React：一个流行的 JavaScript 库，用于构建用户界面。

6. Node.js：一个流行的 JavaScript 运行时环境，用于在服务器上运行 JavaScript 代码。

7. Vue.js：一个流行的 JavaScript 框架，用于构建用户界面。

8. TypeScript：一种由 Microsoft 开发的编程语言，是 JavaScript 的超集，添加了类型和其他功能。

9. ES6（ECMAScript 2015）：JavaScript 的最新版本，添加了许多新功能和语法。

10. Webpack：一个流行的 JavaScript 模块打包器，用于将多个 JavaScript 文件打包成一个文件。

以上是一些常见的 JavaScript 技术。当然，JavaScript 还有很多其他技术和工具。

**ES6的新功能和语法**

ES6 是 ECMAScript 2015 的简称，是 JavaScript 的一种新版本。它引入了许多新的语法和功能，使代码更现代化、更可读。ES6 引入了许多伟大的功能，例如箭头函数、模板字符串、类、解构、模块等等。以下是一些 ES6 的新功能和语法：

- let 和 const 语句
- 模板字符串
- 箭头函数
- 类
- 解构
- 对象字面量的简写语法
- 数组的扩展运算符
- 函数的剩余参数
- Promise 对象
- Symbol 类型

write less, do more - FreeCodecamp. https://www.freecodecamp.org/news/write-less-do-more-with-javascript-es6-5fd4a8e50ee2/
ECMAScript 6: New Featureshttp://es6-features.org/

### React关键知识点

React 是一个用于构建用户界面的 JavaScript 库。以下是 React 的一些关键知识点：

- JSX
- 类和函数组件
- 属性
- 状态
- 生命周期方法
- 钩子

react中的jsx,状态,生命周期方法,钩子分别是什么含义? 请举出代码示例

JSX 是一种 JavaScript 的语法扩展，它允许我们在 JavaScript 中编写类似于 HTML 的代码。状态是组件中的数据，可以在组件中进行更改。生命周期方法是在组件的生命周期中自动调用的方法。钩子是在组件的生命周期中自动调用的函数。

以下是一些示例代码：

```jsx
import React, { useState } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

这是一个简单的计数器，它使用了状态和钩子。当用户单击按钮时，计数器会增加。

### DOM简介

### AJAX关键知识点

### Vue关键知识点

Vue是一个用于创建用户界面的开源JavaScript框架，也是一个创建单页应用的Web应用框架 。Vue的关键知识点有：

- 声明式渲染：Vue通过模板语法，让我们可以声明式地描述基于JavaScript状态的HTML输出。

- 响应式系统：Vue自动追踪JavaScript状态的变化，并高效地更新DOM。

- 组件化：Vue允许我们通过组件，将复杂的用户界面分解为可复用的代码块。

- 指令：Vue提供了一些内置的指令，用于在元素上绑定数据或事件，也可以自定义指令。

- 过滤器：Vue提供了一些内置的过滤器，用于对数据进行格式化或转换，也可以自定义过滤器。

- 计算属性和侦听器：Vue提供了计算属性和侦听器，用于在数据变化时执行一些逻辑或副作用。

- 生命周期钩子：Vue提供了一些生命周期钩子，用于在组件创建、更新或销毁时执行一些操作。

- 路由：Vue配合vue-router库，可以实现单页应用的路由管理。

- 状态管理：Vue配合vuex库，可以实现单页应用的状态管理。

- 过渡和动画：Vue提供了一些内置的过渡和动画效果，用于在元素进入或离开时添加动画。

  [Template Syntax | Vue.js (vuejs.org)](https://vuejs.org/guide/essentials/template-syntax.html)

  https://vuejs.org/examples/
  常用的Vue代码片段https://juejin.cn/post/7016262531383558181
  vscode快速生成vue用户代码片段https://zhuanlan.zhihu.com/p/140463840

#### VS Coder常用的代码片段？

[Vue Snippets(vue-ls) - Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=vaniship.vue-ls-snippets)





### TypeScript关键知识点

TypeScript是一种基于JavaScript的编程语言，它提供了一些关键的知识点，可以帮助开发者编写更健壮和可维护的代码。以下是一些TypeScript的关键知识点：

- 类型系统：TypeScript支持静态类型检查，可以在编译时发现潜在的错误和不匹配。TypeScript提供了多种基本类型，如string，number，boolean，以及复杂类型，如数组，元组，枚举，接口，类，泛型等。
- 类和接口：TypeScript支持面向对象的编程范式，可以使用类和接口来定义和实现抽象和封装。类可以继承，实现和扩展其他类或接口，接口可以描述对象的结构和行为，以及约束类的实现。
- 装饰器：TypeScript支持装饰器语法，可以在运行时修改类，方法，属性和参数的行为。装饰器是一种特殊的函数，可以接收一个目标对象作为参数，并返回一个新的对象或者修改原有对象。装饰器可以用来实现依赖注入，元数据注解，日志记录等功能。
- 模块和命名空间：TypeScript支持模块化的编程风格，可以使用import和export语句来导入和导出模块中的变量，函数，类等。模块可以遵循不同的规范，如ES6模块，CommonJS模块等。命名空间是一种组织代码的方式，可以避免全局变量的污染和冲突。命名空间可以使用namespace关键字来定义，并使用点号来访问其成员。



### Webpack使用说明

Webpack是一个强大的工具，可以帮助你打包和优化你的前端资源，比如JavaScript，CSS，图片等。Webpack的使用说明如下：

1. 安装Webpack和相关的依赖包，比如webpack-cli，webpack-dev-server等。你可以使用npm或者yarn来安装。
2. 创建一个webpack.config.js文件，用来配置Webpack的各种选项，比如入口文件，输出文件，加载器，插件等。
3. 在package.json文件中添加一些脚本，比如"build"，"start"，"test"等，用来运行Webpack或者其他工具。
4. 在你的源代码中使用import或者require来引入你需要的模块，Webpack会自动解析和打包它们。
5. 运行npm run build或者yarn build来生成你的最终文件，它们会被放在dist文件夹中。
6. 运行npm run start或者yarn start来启动一个开发服务器，它会自动刷新你的浏览器，让你看到你的修改效果。
7. 运行npm run test或者yarn test来执行你的测试用例，确保你的代码没有错误。

Webpack使用说明就是这样了，希望你能够愉快地使用Webpack来构建你的前端项目！

## Java关键知识点

以下是 Java 的关键知识点：

1. Java 基础知识：Java 语言的基本概念和语法。

2. 面向对象编程（OOPs）概念：Java 是一种面向对象的编程语言，因此 OOPs 概念是 Java 中的关键知识点。

3. 方法重载和覆盖：Java 中的方法重载和覆盖是 OOPs 概念的一部分，也是 Java 中的关键知识点。

4. 接口和抽象类的继承：Java 中的接口和抽象类是 OOPs 概念的一部分，也是 Java 中的关键知识点。

5. 异常处理：Java 中的异常处理是一种机制，用于处理程序中出现的错误。

6. 包：Java 中的包是一种机制，用于组织相关类和接口。

7. 集合：Java 中的集合是一种框架，用于存储和操作对象。

8. 多线程：Java 中的多线程机制允许程序同时执行多个任务。

以上是 Java 的一些关键知识点。当然，Java 还有很多其他知识点。

### Java堆\栈内存之间的区别

为了以最佳方式运行应用程序，JVM将内存分为堆和栈内存。每当我们声明新变量和对象、调用新方法、声明字符串或执行类似操作时，JVM从堆或栈内存中为这些操作分配内存¹。

栈内存用于静态内存分配和线程的执行。它包含特定于方法的原始值和从方法中引用的位于堆中的对象的引用。访问此内存是以后进先出（LIFO）的顺序进行的。每当我们调用一个新方法时，栈顶部会创建一个新块，其中包含特定于该方法的值，如原始变量和对象引用。当方法完成执行时，其对应的栈帧被刷新，流程返回到调用方法，并为下一个方法腾出空间¹。

堆空间用于在运行时动态分配Java对象和JRE类的内存。新对象总是在堆空间中创建，而这些对象的引用存储在栈内存中。这些对象具有全局访问性，我们可以从应用程序的任何地方访问它们¹。

下面是一个简单的例子，说明了Java程序中如何分配内存：
```java
public class Memory {
    public static void main(String[] args) {
        int i = 1; // Line 1
        Object obj = new Object(); // Line 2
        Memory mem = new Memory(); // Line 3
        mem.foo(obj); // Line 4
    }

    private void foo(Object param) {
        String str = param.toString(); // Line 6
        System.out.println(str);
    }
}
```
在上面这个例子中，当程序运行时，所有运行时类都加载到堆空间中。当在第1行找到main()方法线程时，Java运行时创建了栈内存供其使用。在第2行，使用new关键字创建一个新对象，并将其分配到堆空间。在第3行，使用new关键字创建另一个对象并将其分配到堆空间。在第4行，调用foo()方法并传递一个参数。这将创建一个新块来保存foo()方法所需的值，并将其推送到栈顶部。在第6行，声明一个新变量并将其初始化为param.toString()的返回值。这个值将保存在刚才创建的块中。

Stack Memory and Heap Space in Javahttps://www.baeldung.com/java-stack-heap
Heap vs. Stack: Code Exampleshttps://stackify.com/java-heap-vs-stack/ 
Stack Vs Heap Java - Javatpoint. https://www.javatpoint.com/stack-vs-heap-java 

### Java(开发中)经典(高效的程序)代码片段

下面是两个更复杂的 Java 程序示例，它们涵盖了更多的知识点：

1. 计算圆的面积和周长：

```java
public class Circle {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    public double getArea() {
        return Math.PI * radius * radius;
    }

    public double getCircumference() {
        return 2 * Math.PI * radius;
    }
}

public class Main {
    public static void main(String[] args) {
        Circle circle = new Circle(5);
        System.out.println("Area: " + circle.getArea());
        System.out.println("Circumference: " + circle.getCircumference());
    }
}
```

在这个示例中，我们定义了一个名为 `Circle` 的类，它表示一个圆。`Circle` 类有一个实例变量 `radius`，表示圆的半径。我们还定义了一个构造函数，用于初始化圆的半径。

此外，我们还定义了两个方法 `getArea` 和 `getCircumference`，分别用于计算圆的面积和周长。这两个方法使用了 `Math.PI` 常量和 `Math.pow` 方法来进行计算。

然后，我们定义了一个名为 `Main` 的类，它包含一个 `main` 方法。在 `main` 方法中，我们创建了一个 `Circle` 类的实例，并使用其方法来计算圆的面积和周长。

2. 计算两个日期之间的天数：

```java
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;

public class Main {
    public static void main(String[] args) {
        LocalDate date1 = LocalDate.of(2020, 1, 1);
        LocalDate date2 = LocalDate.of(2020, 2, 1);
        long daysBetween = ChronoUnit.DAYS.between(date1, date2);
        System.out.println("Days between: " + daysBetween);
    }
}
```

在这个示例中，我们使用了 Java 8 中引入的新日期和时间 API 来计算两个日期之间的天数。我们首先使用 `LocalDate.of` 方法创建了两个 `LocalDate` 实例，分别表示两个日期。

然后，我们使用 `ChronoUnit.DAYS.between` 方法来计算两个日期之间的天数。这个方法接受两个 `Temporal` 参数，并返回它们之间相差的天数。

最后，我们在控制台输出了计算结果。

这些只是一些简单的 Java 程序示例，实际上 Java 语言可以用来编写更复杂的程序。希望这些示例能帮助您更好地理解 Java 语言的特性和用法。

下面是另外两个 Java 程序示例，它们涵盖了更多的知识点：

1. 使用泛型定义一个简单的栈：

```java
import java.util.ArrayList;
import java.util.List;

public class Stack<T> {
    private List<T> elements = new ArrayList<>();

    public void push(T element) {
        elements.add(element);
    }

    public T pop() {
        if (elements.isEmpty()) {
            throw new IllegalStateException("Stack is empty");
        }
        return elements.remove(elements.size() - 1);
    }

    public boolean isEmpty() {
        return elements.isEmpty();
    }
}

public class Main {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        while (!stack.isEmpty()) {
            System.out.println(stack.pop());
        }
    }
}
```

在这个示例中，我们定义了一个名为 `Stack` 的泛型类，它表示一个栈。`Stack` 类使用了一个 `List` 来存储栈中的元素。

我们定义了三个方法 `push`、`pop` 和 `isEmpty`，分别用于向栈中添加元素、从栈中弹出元素和检查栈是否为空。这些方法使用了 `List` 类的 `add`、`remove` 和 `isEmpty` 方法来实现。

然后，我们定义了一个名为 `Main` 的类，它包含一个 `main` 方法。在 `main` 方法中，我们创建了一个 `Stack<Integer>` 类的实例，并使用其方法来向栈中添加元素和从栈中弹出元素。

2. 使用接口定义一个简单的形状类层次结构：

```java
interface Shape {
    double getArea();
}

class Circle implements Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle implements Shape {
    private double width;
    private double height;

    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }

    @Override
    public double getArea() {
        return width * height;
    }
}

public class Main {
    public static void main(String[] args) {
        Shape[] shapes = new Shape[2];
        shapes[0] = new Circle(5);
        shapes[1] = new Rectangle(10, 20);
        for (Shape shape : shapes) {
            System.out.println(shape.getArea());
        }
    }
}
```

在这个示例中，我们定义了一个名为 `Shape` 的接口，它表示一个形状。`Shape` 接口定义了一个方法 `getArea`，用于计算形状的面积。

然后，我们定义了两个类 `Circle` 和 `Rectangle`，它们分别表示圆和矩形。这两个类都实现了 `Shape` 接口，并重写了其中的 `getArea` 方法。

最后，我们定义了一个名为 `Main` 的类，它包含一个 `main` 方法。在 `main` 方法中，我们创建了一个 `Shape` 类型的数组，并向其中添加了两个形状对象。然后，我们遍历这个数组，并使用多态性调用每个形状对象的 `getArea` 方法。

这些只是一些简单的 Java 程序示例，实际上 Java 语言可以用来编写更复杂的程序。希望这些示例能帮助您更好地理解 Java 语言的特性和用法。



[20个常用的经典JAVA代码片段_java命令语句](https://blog.csdn.net/tdoly/article/details/9170861)

## Python关键技术

### 装饰器实例

装饰器（Decorator）是 Python 中一种常用的语言特性，它允许我们在不修改原有代码的情况下，为函数或方法添加新的功能。装饰器本质上是一个函数，它接受一个函数作为参数，并返回一个新的函数。

下面是一个简单的装饰器示例，它演示了如何使用装饰器来计算函数的执行时间：

```python
import time

def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.2f} seconds to run.")
        return result
    return wrapper

@timer
def my_function(n):
    total = 0
    for i in range(n):
        total += i
    return total

my_function(1000000)
```

在这个示例中，我们定义了一个名为 `timer` 的装饰器函数。这个函数接受一个函数 `func` 作为参数，并返回一个新的函数 `wrapper`。在 `wrapper` 函数中，我们首先记录了当前时间，然后调用了原始函数 `func` 并获取其返回值。接着，我们再次记录当前时间，并计算出原始函数 `func` 的执行时间。最后，我们打印出执行时间并返回原始函数的返回值。

然后，我们定义了一个名为 `my_function` 的函数，并使用 `@timer` 语法将其装饰。这相当于调用 `my_function = timer(my_function)`。

当我们调用 `my_function(1000000)` 时，实际上调用的是装饰器返回的新函数 `wrapper`。因此，我们可以看到输出中包含了原始函数 `my_function` 的执行时间。

这样，我们就可以使用装饰器来为原有函数添加新的功能，而无需修改原有代码。



### python经典重构实例

重构（Refactoring）是指在不改变代码外部行为的前提下，对代码进行修改以改善其内部结构和可读性。重构可以帮助我们提高代码质量，使其更容易理解和维护。

下面是一个简单的重构示例，它演示了如何使用提取函数（Extract Function）重构技术来改善代码可读性：

```python
# 重构前
def print_report(data):
    total = 0
    for item in data:
        total += item["price"] * item["quantity"]
    tax = total * 0.1
    total += tax

    print("---- Report ----")
    for item in data:
        print(f"{item['name']}: {item['price']} x {item['quantity']}")
    print(f"Total (excl. tax): {total - tax:.2f}")
    print(f"Tax: {tax:.2f}")
    print(f"Total (incl. tax): {total:.2f}")

data = [
    {"name": "Item 1", "price": 10, "quantity": 2},
    {"name": "Item 2", "price": 20, "quantity": 1},
]
print_report(data)

# 重构后
def calculate_total(data):
    total = 0
    for item in data:
        total += item["price"] * item["quantity"]
    return total

def print_report(data):
    total = calculate_total(data)
    tax = total * 0.1
    total += tax

    print("---- Report ----")
    for item in data:
        print(f"{item['name']}: {item['price']} x {item['quantity']}")
    print(f"Total (excl. tax): {total - tax:.2f}")
    print(f"Tax: {tax:.2f}")
    print(f"Total (incl. tax): {total:.2f}")

data = [
    {"name": "Item 1", "price": 10, "quantity": 2},
    {"name": "Item 2", "price": 20, "quantity": 1},
]
print_report(data)
```

在这个示例中，我们定义了一个名为 `print_report` 的函数，它接受一个包含多个字典的列表作为参数，并打印出一个报表。在重构前，`print_report` 函数中包含了计算总价的逻辑。

在重构后，我们将计算总价的逻辑提取到一个新的函数 `calculate_total` 中。这样，`print_report` 函数就变得更加简洁，它只负责打印报表，而不再包含计算逻辑。

这样的重构使得代码更加清晰易懂，也更容易维护。当我们需要修改计算逻辑时，只需修改 `calculate_total` 函数即可，而无需修改 `print_report` 函数。

**实例2**

下面是另一个简单的重构示例，它演示了如何使用内联变量（Inline Variable）重构技术来简化代码：

```python
# 重构前
def get_discounted_price(price, discount):
    discounted_price = price * (1 - discount)
    return discounted_price

# 重构后
def get_discounted_price(price, discount):
    return price * (1 - discount)
```

在这个示例中，我们定义了一个名为 `get_discounted_price` 的函数，它接受两个参数 `price` 和 `discount`，并返回折扣后的价格。

在重构前，`get_discounted_price` 函数中定义了一个局部变量 `discounted_price` 来存储折扣后的价格。但是，这个变量只被使用了一次，因此我们可以将其内联到返回语句中。

在重构后，我们直接在返回语句中计算折扣后的价格，而不再使用局部变量。这样，`get_discounted_price` 函数就变得更加简洁。

这样的重构使得代码更加清晰易懂，也更容易维护。当我们需要修改计算逻辑时，只需修改返回语句即可。

### python经典代码片段(持续补充:再给10例python开发中经典高效的程序代码片段)

在这段代码中，`**` 是一个运算符，它用于解压字典。在函数 `Merge` 中，`res = {**dict1, **dict2}` 这一行代码的作用是将两个字典 `dict1` 和 `dict2` 合并为一个新字典 `res`。

例如，如果我们有两个字典：
```python
dict1 = {"name": "Joy", "age": 25}
dict2 = {"name": "Joy", "city": "New York"}
```
当我们调用函数 `Merge(dict1, dict2)` 时，它会返回一个新字典，其中包含来自两个输入字典的所有键值对：
```python
res = Merge(dict1, dict2)
print(res)
```
输出： {'name': 'Joy', 'age': 25, 'city': 'New York'}

需要注意的是，如果两个输入字典中有相同的键，则后一个字典中的值会覆盖前一个字典中的值。在上面的示例中，`dict1` 和 `dict2` 都有键 `"name"`，所以在合并后的字典 `res` 中，键 `"name"` 的值为 `"Joy"`，即来自 `dict2` 的值。

[VSCode 一字十行之代码片段_lefex的博客-CSDN博客](https://blog.csdn.net/lefex/article/details/109541898?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-109541898-blog-118413252.235^v31^pc_relevant_default_base3&spm=1001.2101.3001.4242.2&utm_relevant_index=4)

20条非常实用的Python代码实例 https://bing.com/search?q=Python+%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b
Python 100例https://www.runoob.com/python/python-100-examples.html
20条非常实用的Python代码实例https://zhuanlan.zhihu.com/p/374461054
Python实例100个https://blog.csdn.net/weixin_41084236/article/details/81564963

------

下面是一些在 Python 开发中常用的高效代码片段：

1. 列表推导式（List Comprehension）：使用列表推导式可以快速生成新列表。

```python
squares = [x**2 for x in range(10)]
```

2. 生成器表达式（Generator Expression）：与列表推导式类似，但生成器表达式返回的是一个生成器，它可以更高效地处理大量数据。

```python
squares = (x**2 for x in range(10))
```

3. 字典推导式（Dictionary Comprehension）：与列表推导式类似，但用于快速生成新字典。

```python
squares = {x: x**2 for x in range(10)}
```

4. 集合推导式（Set Comprehension）：与列表推导式类似，但用于快速生成新集合。

```python
squares = {x**2 for x in range(10)}
```

5. 枚举（Enumerate）：使用 `enumerate` 函数可以在遍历列表时获取元素的索引和值。

```python
my_list = ['apple', 'banana', 'orange']
for i, item in enumerate(my_list):
    print(f"Index: {i}, Item: {item}")
```


6. 使用 `zip` 函数同时遍历多个列表：

```python
list1 = [1, 2, 3]
list2 = ['a', 'b', 'c']
for x, y in zip(list1, list2):
    print(x, y)
```

7. 使用 `defaultdict` 避免键错误：

```python
from collections import defaultdict

my_dict = defaultdict(int)
my_dict['key'] += 1
```

8. 使用 `Counter` 类统计元素出现次数：

```python
from collections import Counter

my_list = ['a', 'b', 'c', 'a', 'b', 'a']
count = Counter(my_list)
print(count)
```

9. 使用 `lambda` 函数定义简单的匿名函数：

```python
my_list = [1, 2, 3]
squared_list = map(lambda x: x**2, my_list)
```

10. 使用 `filter` 函数过滤列表元素：

```python
my_list = [1, 2, 3, 4, 5]
even_list = filter(lambda x: x % 2 == 0, my_list)
```

这些只是一些常用的高效代码片段，实际上还有许多其他技巧可供使用。在编写 Python 代码时，应该尽量利用语言特性来提高代码的可读性和效率。

下面是另外 10 个在 Python 开发中常用的高效代码片段：

1. 使用 `join` 方法连接字符串：

```python
my_list = ['a', 'b', 'c']
my_string = ''.join(my_list)
```

2. 使用 `in` 运算符检查列表中是否包含元素：

```python
my_list = [1, 2, 3]
if 2 in my_list:
    print("Found")
```

3. 使用列表切片反转列表：

```python
my_list = [1, 2, 3]
reversed_list = my_list[::-1]
```

4. 使用 `all` 函数检查列表中的所有元素是否都为真：

```python
my_list = [True, True, False]
result = all(my_list)
```

5. 使用 `any` 函数检查列表中是否有任何元素为真：

```python
my_list = [True, True, False]
result = any(my_list)
```

6. 使用 `sorted` 函数对列表进行排序：

```python
my_list = [3, 1, 2]
sorted_list = sorted(my_list)
```

7. 使用 `min` 和 `max` 函数查找列表中的最小值和最大值：

```python
my_list = [3, 1, 2]
min_value = min(my_list)
max_value = max(my_list)
```

8. 使用切片删除列表中的多个元素：

```python
my_list = [1, 2, 3, 4, 5]
del my_list[1:3]
```

9. 使用切片插入多个元素：

```python
my_list = [1, 2, 3]
my_list[1:1] = [4, 5]
```

10. 使用 `isinstance` 函数检查对象类型：

```python
x = 'hello'
if isinstance(x, str):
    print("x is a string")
```

这些只是一些常用的高效代码片段，实际上还有许多其他技巧可供使用。在编写 Python 代码时，应该尽量利用语言特性来提高代码







#### 单例模式实例

单例模式（Singleton Pattern）是一种常用的软件设计模式，它保证一个类只有一个实例，并提供一个访问该实例的全局访问点。

在 Python 中，可以使用多种方法来实现单例模式。下面是一种常用的方法，它使用了一个类变量和一个类方法来实现单例模式：

```python
class Singleton:
    _instance = None

    @classmethod
    def instance(cls):
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance

# 使用示例
s1 = Singleton.instance()
s2 = Singleton.instance()

print(s1 is s2)  # True
```

在这个示例中，我们定义了一个名为 `Singleton` 的类，它有一个类变量 `_instance` 和一个类方法 `instance`。当我们第一次调用 `Singleton.instance()` 时，它会创建一个 `Singleton` 类的实例，并将其存储在类变量 `_instance` 中。当我们再次调用 `Singleton.instance()` 时，它会返回之前创建的实例，而不是创建一个新的实例。

这样，无论我们调用多少次 `Singleton.instance()`，它都会返回同一个实例。因此，我们可以保证 `Singleton` 类只有一个实例。

#### 工厂模式实例

工厂模式（Factory Pattern）是一种常用的创建型设计模式，它提供了一种封装对象创建过程的方法。工厂模式定义了一个用于创建对象的接口，但将实际创建对象的过程延迟到子类中进行。

下面是一个简单的工厂模式示例，它演示了如何使用工厂模式来创建不同类型的动物：

```python
class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "Woof"

class Cat(Animal):
    def speak(self):
        return "Meow"

class AnimalFactory:
    def get_animal(self, animal_type):
        if animal_type == "dog":
            return Dog()
        elif animal_type == "cat":
            return Cat()
        else:
            return None

# 使用示例
factory = AnimalFactory()

dog = factory.get_animal("dog")
print(dog.speak())  # Woof

cat = factory.get_animal("cat")
print(cat.speak())  # Meow
```

在这个示例中，我们定义了一个名为 `Animal` 的基类和两个子类 `Dog` 和 `Cat`。`Dog` 类和 `Cat` 类都重写了基类中的 `speak` 方法，分别返回 `"Woof"` 和 `"Meow"`。

然后，我们定义了一个名为 `AnimalFactory` 的工厂类，它有一个方法 `get_animal`。这个方法接受一个字符串参数 `animal_type`，根据这个参数的值来创建不同类型的动物。例如，如果 `animal_type` 的值为 `"dog"`，则 `get_animal` 方法会返回一个 `Dog` 类的实例；如果 `animal_type` 的值为 `"cat"`，则 `get_animal` 方法会返回一个 `Cat` 类的实例。

这样，我们可以使用工厂类来封装对象创建的过程，而不是直接在客户端代码中创建对象。当我们需要添加新类型的动物时，只需在工厂类中添加相应的逻辑即可，而无需修改客户端代码。

#### 其他设计模式

在 Python 中，除了单例模式和工厂模式之外，还常用到许多其他设计模式。下面是一些常用的设计模式及其简要说明：

- 适配器模式（Adapter Pattern）：允许不兼容的接口之间进行通信。它通过封装一个对象，并提供一个新的接口来实现这一点。

- 建造者模式（Builder Pattern）：将复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。

- 装饰器模式（Decorator Pattern）：动态地为对象添加额外的职责。它通过包装一个对象，并提供一个新的接口来实现这一点。

- 观察者模式（Observer Pattern）：定义了一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。

- 策略模式（Strategy Pattern）：定义了一系列算法，并将每个算法封装起来，使它们之间可以相互替换。它允许算法在运行时根据需要进行切换。

这些只是一些常用的设计模式，实际上还有许多其他设计模式可供使用。设计模式通常用于解决在软件开发中经常遇到的特定问题，它们可以帮助我们编写更加清晰、可维护和可扩展的代码。

#### 匿名函数实例

匿名函数（Anonymous Function）是指一种没有名称的简单函数。在 Python 中，可以使用 `lambda` 关键字来定义匿名函数。

下面是 10 个使用匿名函数的高效代码片段：

1. 使用 `map` 函数对列表中的每个元素应用函数：

```python
my_list = [1, 2, 3]
squared_list = map(lambda x: x**2, my_list)
```

2. 使用 `filter` 函数过滤列表元素：

```python
my_list = [1, 2, 3, 4, 5]
even_list = filter(lambda x: x % 2 == 0, my_list)
```

3. 使用 `reduce` 函数对列表中的元素进行累积操作：

```python
from functools import reduce

my_list = [1, 2, 3]
total = reduce(lambda x, y: x + y, my_list)
```

4. 使用 `sorted` 函数对列表进行自定义排序：

```python
my_list = ['banana', 'apple', 'orange']
sorted_list = sorted(my_list, key=lambda x: len(x))
```

5. 使用匿名函数作为参数传递给其他函数：

```python
def apply_function(f, x):
    return f(x)

result = apply_function(lambda x: x**2, 3)
```

6. 使用匿名函数作为字典值：

```python
my_dict = {
    'square': lambda x: x**2,
    'cube': lambda x: x**3,
}

result = my_dict['square'](3)
```

7. 使用匿名函数作为返回值：

```python
def get_function(power):
    return lambda x: x**power

square = get_function(2)
result = square(3)
```

8. 在列表推导式中使用匿名函数：

```python
my_list = [1, 2, 3]
squared_list = [lambda x: x**2 for x in my_list]
```

9. 在生成器表达式中使用匿名函数：

```python
my_list = [1, 2, 3]
squared_gen = (lambda x: x**2 for x in my_list)
```

10. 在字典推导式中使用匿名函数：

```python
my_dict = {x: lambda: x**2 for x in range(3)}
result = my_dict[2]()
```

这些只是一些使用匿名函数的高效代码片段，实际上还有许多其他技巧可供使用。在编写 Python 代码时，应该尽量利用语言特性来提高代码的可读性和效率。

