---
view-count: 2
---

## ❌ 伪高级工程师 · 反向清单（命中越多，风险越高）

### 1. **热衷造抽象，但说不清边界**

❗ 抽象很多 → 问「解决什么变化？」答不上来

---

### 2. **用模式代替思考**

❗ Strategy / Factory / Clean Architecture 成瘾  
→ 但需求 3 个月不变

---

### 3. **抽象不降低修改成本**

❗ 改一个需求 → 改 N 层代码  
→ 抽象失败，但本人无感

---

### 4. **把“复杂”当成“高级”**

❗ 代码难读 ≈ 自豪  
→ 实际是认知外包给别人

---

### 5. **命名空泛、逃避责任**

❗ Manager / Handler / Processor / Service  
→ 不敢明确说“我负责什么”

---

### 6. **系统边界随人而变**

❗ 今天在这层，明天在那层  
→ 架构不稳定，靠记忆维持

---

### 7. **优化非关键路径**

❗ 重构边角代码  
→ 核心流程依然脆弱

---

### 8. **对变化反应迟钝**

❗ 需求一变 → 架构全面崩  
→ 说明没识别变化轴

---

### 9. **代码 review 关注“形式”**

❗ 缩进 / 命名风格 / 范式  
→ 不问系统演化方向

---

### 10. **解释系统靠“故事”而非模型**

❗ 讲历史、背景、人  
→ 说不出抽象、边界、约束

---

## ✅ 真 · Staff / Principal 的反向特征（对照）

- 抽象**少但稳定**
    
- 一眼能指出**变化轴**
    
- 重构目标是：**让未来更便宜**
    
- 解释系统用：**模型、接口、依赖图**
    
- 能明确说：
    
    > **“这段代码现在不抽象，是刻意的”**
    

---

## 🧠 一句话鉴别法（极好用）

> **如果一个人写的抽象，  
> 不能让“未来的你”更轻松，  
> 那他只是在炫技。**

---

如果你愿意，我还能继续往下拆三层：

- 🔥 **为什么大厂最怕“伪 Principal”**
    
- 🧬 **真正 Staff Engineer 的思维闭环（4 步）**
    
- 🪞 **把这份清单反用在自我进化**
    

你挑一个，我继续下刀。


---

### 三、正确做法

- **自动化格式问题**：用 Prettier、ESLint、Black、gofmt 等工具自动统一风格，**不让人工审查处理这类问题**。
- **聚焦高价值反馈**：审查重点应放在：
	- 逻辑正确性
	- 边界条件与异常处理
	- 安全性（如 SQL 注入、XSS）
	- 可测试性与可维护性
	- 是否符合系统长期演进目标
- **建立共识规范**：团队提前约定命名、结构等规范，避免每次重复争论。

