**文件標題：軟體建構核心原則與實務簡報**

**文件日期：2023-10-27**

**來源文件：《代碼大全 第二版》摘錄**

**1. 簡介：什麼是軟體建構及其重要性**

- **什麼是軟體建構？**軟體建構是軟體開發過程中的核心活動，介於整體設計和系統測試之間。
- 它主要包括詳細設計、編碼、調試和單元測試。
- 也被稱為「實現」、「程式設計」或「編碼和調試」。雖然「編碼」一詞可能帶有將設計機械地翻譯成程式碼的含義，但「建構」更強調過程中的創造性和決策性活動。
- **引用：** "建構活動有時被稱作「實現」，它有時被叫作「編碼和調試」，有時也稱之為「程式設計」。" 以及 "關於「建構」的直覺概念是非常準確的，但它往往缺乏正確觀點。把建構活動放到與其相關活動的背景中，有助於我們在適當重視其它非建構工作的同時，把主要精力放在正確的任務上。"
- **軟體建構的重要性：**建構活動的質量對最終軟體質量有潛在影響。
- 對建構活動理解的好壞，是衡量程式設計師素質高低的關鍵。
- **引用：** "建構活動質量對軟體質量有潛在影響。" 以及 "在最後的分析中，對建構活動理解的好壞，決定了一個程式設計師素質的高低，這將在本書其餘部分論述。"
- 即使在計劃不周或匆忙的專案中，建構活動也是必不可少的改進軟體開發工作的方法。
- **引用：** "創建活動都是必不可少的。無論怎樣精簡，改進創建活動都是改進軟件開發工作的方法。"

**2. 利用隱喻加深對程式設計的理解**

- **隱喻的重要性：**軟體開發領域使用了豐富的形象隱喻（如病毒、臭蟲、炸彈等）來描述特定的軟體現象。
- 更廣泛的隱喻可以幫助加深對軟體開發的理解。
- **引用：** "想像一下。你走進一間乾淨整潔、溫度嚴格控制在68℉的房間，在這裡，你將會找到病毒、蠕蟲、臭蟲、炸彈、崩潰、火焰、扭曲的變形者、特洛伊木馬和致命錯誤，在其它領域中，你會遇到這種情況嗎？這些形象的隱喻描述了特定的軟件現象。"
- **如何使用軟體隱喻：**軟體隱喻更像是「一束搜索燈光，而不是一張地圖」，它提供啟發，指引尋找答案的方向，而不是硬性規定。
- 與數學演算法不同，隱喻並不提供一套固定規則或可預測的確定結果。
- **引用：** "軟件隱喻更像是一束搜索燈光，而不是一張地圖，它並不會告訴你到哪里去尋找答案；它只給你以啟發，教你如何尋找答案，而不是像數學算法一樣硬性規定出到哪里找出答案。"
- 重要的是理解軟體開發的各種模型（隱喻），因為它們定義了對軟體開發的理解。即使被較好的模型取代的舊模型也可能仍然發揮作用（例如牛頓力學）。
- **引用：** "事實上，很多被較好模型替代的舊模型仍然在發揮作用。例如，工程師們仍然在用牛頓力學進行工程計算，雖然它已經被相對論力學所取代。"
- **常見的軟體隱喻：建房子的隱喻：** 將軟體開發比作建造房子。強調前期設計的重要性，因為後期修改成本高昂（勞動力成本）。鼓勵利用現有的、已經做好的組件（高級語言特性、現有系統、已通過測試的子程序），而不是樣樣都自己動手。定制化（如定制別墅）的成本也更高，類似於一流軟體開發。
- **引用：** "建造一個軟件系統與其它需要耗費人力與財力的工程是一樣的。如果你要造一幢房子，在開始砌第一塊磚之前，你必須事先畫好建築圖與藍圖。在你開始澆鑄水泥之前，你必須讓人評審你的藍圖並獲得許可。沒有它們你不可能開始建造。"
- **智力工具箱的隱喻：** 將軟體技術和技巧視為工具箱裡的工具。優秀的程式設計師知道用什麼工具做什麼工作以及如何使用。強調不應將某種新技術（如面向對象設計）視為「上帝賜予的法寶」，而是應根據問題選擇適應的方法。
- **引用：** "把方法和技巧當作工具是很有益處的，因為這樣可以使我們對其有一個正確的態度。不要把新的「面向對象設計技術」當作上帝賜予的法寶，它不過是一件在某些場合下有用，而在某些場合下又無用的技術。"

**3. 軟體建構的先決條件**

- **先決條件的重要性：**優秀程式設計師的一個突出特點是他們採用高品質的過程來創建軟體，強調計劃的開始、中間和結束階段的質量。
- 在計劃開始時強調質量（計劃和要求設計高質量產品）比在結束時強調質量（只注重測試）更有效。
- 測試是質量控制策略的一部分，但它不能消除方向錯誤的工作，這些錯誤必須在測試開始之前，甚至在建構工作開始之前清除。
- **引用：** "優秀程序員的一個突出特點是他們採用高質量的過程來創建軟件。這種過程在計劃的開始、中間和末尾都強調高質量。" 以及 "事實上，測試只是全部質量控制策略的一部分。而且並不是最重要的部分。測試既不能消除在正確方向上的錯誤工作，也不能消除在錯誤方向上的正確工作的錯誤，這種錯誤必須在測試開始之前就清除掉，甚至在創建工作開始之前就要努力清除掉它們。"
- 忽略先決條件會導致浪費時間精力解決錯誤問題，懲罰是雙重的：真正問題未解決，且做了錯誤的工作。
- **引用：** "問題定義錯誤的後果是你可能浪費許多時間精力去解決了一個錯誤問題。這種懲罰往往是雙重的，因為真正的問題並沒有解決。"
- 強調準備工作（問題定義、需求分析、結構設計）對於有效程式設計至關重要。項目越大，所需的計劃工作量越大。
- 程式設計師有責任向管理人員和同事解釋先決條件準備工作的重要性。
- **引用：** "進行有效程序設計的關鍵之一就是認識到準備工作是非常重要的。在進行一項大的項目之前，事先做好計劃是明智的。項目越大，需要的計劃工作量也越大。" 以及 "程序员的份内工作之一便是向老闆和同事宣傳軟件的開發過程，包括在編程開始前從事先決條件準備工作的重要性。"
- **問題定義先決條件：**在建構工作開始前，必須清楚要解決的問題是什麼。
- 問題定義只描述問題本身，不涉及解決方法。應簡短且聽起來像一個問題。
- **引用：** "問題定義只描述要解決的問題是什麼，根本不涉及解決方法。它應該是一個簡短的說明，聽起來像一個問題。"
- 問題定義在需求分析之前進行。
- 問題定義應從用戶觀點出發，使用用戶語言，避免使用計算機技術術語（除非問題本身關於計算機）。
- 避免將問題定義為解決方案（例如，「我們需要優化數據入口系統」是糟糕的問題定義）。
- **需求分析先決條件：**需求詳細描述了軟體系統需要解決的問題，是找到問題答案的第一步。也被稱為「需求分析」、「需求定義」等。
- **為什麼要有正式的需求：** 明確的需求確保系統功能由用戶決定，而非程式設計師猜測；使得用戶可以評估需求；減少對用戶需求的猜測；減少開發過程中的變動；使開發過程更容易管理；並使得對軟體的測試成為可能。
- **引用：** "明確的需求是很重要的，因為：明確的需求可以保證是由用戶而不是程序員決定系統的功能。...明確的需求防止對用戶需求進行猜測。"
- **如何應對建構階段的需求變化：** 如果需求分析不夠好，應停止工作返回需求分析階段，就像開車方向不對時應停車看地圖一樣。
- 讓每個人都知道由於需求變化所付出的代價（時間和成本）。使用「變動後的進度和成本估計」來管理新的想法。
- **引用：** "如果你的需求分析不是很好，那麼，停止繼續工作，重新返回到需求分析階段。...因此，如果你發現方向不對，趕緊停下來檢查你的方向。" 以及 "對付這種人最簡單辦法就是對他說：「喂，先生，你的想法不錯，但是由於它不在需求文件之中，我想先做一個變動後的進度與成本估計，然後我們再決定是立刻就採用這個想法還是以後再說」。"
- **結構設計先決條件：**結構設計是在建構之前的設計階段，描述了系統各個部分如何協作解決問題。也稱為「頂層設計」、「高層設計」或「模組設計」。
- 結構設計定義了整個系統的結構。它應該描述程式的高層組織、關鍵數據結構、關鍵演算法、主要對象、輸入/輸出策略、用戶界面以及資源管理（內存使用估算）。
- **引用：** "結構設計定義了整個系統的結構。...它應該描述程序的高層組織、關鍵數據結構、關鍵算法、主要對象、輸入/輸出策略、用戶界面以及資源管理。"
- 應遵循數據守恆定律：每個進入的數據都應該出去，或者與其他數據一道出去。
- **引用：** "最後，應該遵循數據守恆定律：每一個進入的數據都應該出去，或者與其它數據一道出去，如果它不出去，那它就沒有必要進來。"
- 結構設計應有記錄並經過檢查，以便提供程式設計師所需的訊息，並為後期維護提供寶貴參考。應解釋選擇某個方案的原因以及未選擇其他方案的理由。
- **引用：** "如果結構設計依賴於某一特定演算法，那它應該描述或指出這一演算法。同主要數據結構一樣，結構設計中也應該指出考慮過的演算法方案，並指出選中最終方案的原因。"

**4. 建立子程序步驟與高品質子程序特點**

- **建立子程序步驟：**概述：建立子程序的一般步驟包括設計子程序、編寫程式碼、檢查子程序。
- 程式設計語言（PDL）：可以在高層次使用PDL來設計子程序，並將其作為編碼的指導。
- 設計子程序：在主要工作步驟完成後，可以在高層次PDL水平上編寫子程序。應考慮效率（速度和空間）、研究演算法和數據結構，以及重複使用好的程式碼。
- 子程序編碼：在PDL設計的基礎上進行編碼。
- 檢查子程序：在設計和實現後，檢查實現的軟體是否正確。這包括非正式檢查、收尾工作、同行評審和測試。
- **引用：** "在設計並實現了子程序之後，創建活動的第三個主要步驟是進行檢查，以確認所實現的軟件是正確的。"
- 如果發現程序中錯誤過多，應重新開發，而不是試圖修補。
- **引用：** "如果發現程序中的錯誤異乎尋常的多，那就重新開發一個，不要試圖修補它。修補往往意味着不充分的理解，而且肯定會在現在和將來產生更多的錯誤，而進行一個全新的設計將防止這一點。"
- **高品質子程序特點：生成子程序的原因：** 主要原因是加強可管理性（降低複雜性），其他原因包括節省空間、改進正確性、可靠性、可修改性、可理解性、可測試性、功能獨立性、抽象性、隱藏實現細節、隱藏數據結構、隱藏複雜邏輯、隱藏硬體細節、集中控制等。
- **引用：** "建立子程序最重要的原因是加強可管理性（即降低複雜性），其它原因還有節省空間、改進正確性、可靠性、可修改性等等。"
- **適當的子程序名稱：** 子程序的名稱應清楚地描述其功能。使用動賓詞組命名過程，使用返回值描述命名函數。名稱表明了子程序的質量。
- **引用：** "子程序的名稱表明了它的質量，如果名稱不好但卻是精確的，那麼說明它的設計也是非常令人遺憾的。"
- **強內聚性（Strong Cohesion）：** 子程序應只完成一項任務且完成得很好。這是判斷子程序是否能作為獨立單元使用的關鍵。不同程度的內聚性包括功能內聚性（最佳）、通訊內聚性、邏輯內聚性等。
- **引用：** "強調強內聚性和鬆散耦合的首要原因是它們提供了較高層次的抽象性，你可以認為一個具備這種特性的子程序運行是獨立的，這可以使你集中精力完成其它任務。"
- **鬆散耦合性（Loose Coupling）：** 子程序之間的聯繫應最小化、密切、可見和靈活。耦合度量兩個子程序相互依賴的程度。理想情況下，子程序應對其他子程序一無所知。
- **引用：** "子程序的耦合是不是鬆散的？兩個子程序之間的聯繫是不是小規模、密切、可見和靈活的？"
- **子程序長度：** 子程序的長度應由其功能和邏輯自然決定，而不是由人為標準決定。
- **防錯性程式設計（Defensive Programming）：** 包括使用斷言驗證假設、對非法輸入數據進行防護、確保程序終止良好、處理修改情況、便於啟用/禁用調試幫助、利用信息隱藏和鬆散耦合，以及檢查返回值。
- **引用：** "防錯性編程可以使錯誤更容易被發現和修復，對最終軟件的危害性顯著減小。"
- **參數傳遞問題：** 包括形式參數與實際參數匹配、參數排列合理、接口假設說明、參數數量控制（建議7個或更少）、僅傳遞結構化變數中需要的_部分_，以及確保每個輸入/輸出參數都被使用。

**5. 模組化設計**

- **模組化：內聚性與耦合性：** 模組化是將程序分解為稱為模組的獨立部分，以降低複雜性。模組設計的標準與子程序類似，也強調強內聚性和鬆散耦合性。
- **引用：** "模組化是將程序分解為稱為模組的獨立部分，以降低複雜性。衡量模組的標準與衡量子程序的標準相似：模組應該是強內聚性的和鬆散耦合性的。"
- **信息隱藏（Information Hiding）：** 模組設計最重要的原則之一。它指的是將實現細節（如數據結構、複雜邏輯、硬體細節、規則集合等）隱藏在模組內部，只暴露一個定義明確的接口。這樣，外部模組不需要知道內部細節，當內部細節變化時，不會影響外部模組。
- **引用：** "信息隱藏是模組設計最重要的原則之一。它指的是將實現細節隱藏在模組內部，只暴露一個定義明確的接口。這樣，當內部細節變化時，不會影響到外部模組。"
- 應預防未來可能發生的變動，設計系統時，改動範圍應與其可能性成反比。
- **引用：** "預防到改動。當考慮一個系統中潛在的改動時，應該按照使得改動範圍或大小與其改動可能性成反比的原則來設計系統。"
- 可能發生變動的領域包括：對應用程式的規則和策略有依賴的部分、硬體依賴、複雜數據、複雜邏輯、預計會改變的輸入/輸出格式等。
- **建立模組的理由：**即使不經常使用模組，人們通常也能憑直覺了解可以放入模組的數據和子程序類型。
- 適合使用模組的領域包括：用戶接口、對硬體有依賴的區域、作業系統接口、數據庫接口、輸入/輸出文件格式、預計會改變的數據結構、預計會改變的演算法、預計會改變的複雜邏輯、全局數據（通過存取子程序實現信息隱藏）。
- **引用：** "以下是一些適合使用模組的域：用戶接口、對硬體有依賴的區域、作業系統接口、數據庫接口、輸入/輸出文件格式、預計會改變的數據結構、預計會改變的演算法、預計會改變的複雜邏輯、全局數據。"
- 模組支持面向對象概念（抽象和封裝），但不完全支持繼承性。
- **任何語言中實現模組：** 即使某些語言沒有直接支持模組的結構，也可以通過編程約定、組織源代碼文件等方式來實現模組化和信息隱藏。一些語言（如Ada、C++）提供了更好的模組化支持。

**6. 結構設計方法與啟發過程**

- **結構化設計：**由系統組織（黑盒子、定義明確的子程序和模組）、開發設計策略、評估設計準則、明確的問題說明以及表達設計的工具（PDL、結構圖）組成。
- **引用：** "結構化設計是由以下部分組成的：系統組織...開發設計的策略...評估設計準則...關於問題的明確說明...表達設計的圖形和語言工具..."
- **選擇需進行模組化的要素：** 通過識別問題中可能變動的領域、複雜性高的部分以及可以重複使用的部分來確定模組。
- **自頂向下分解：** 一種流行的分解方法，從程序功能的粗略說明出發，逐步推進到每一項特定工作。通常從程序的「主要」子程序開始，逐步細化。應設計高層次，避免特定語言細節，暫時不指出下一層次設計細節（類似信息隱藏）。
- **引用：** "把程序分解為子程序的一種流行方法是自頂向下分解，也稱為自頂向下設計或逐步求精。...應將設計高層次，避免特定語言細節，並暫時不指出下一層次的設計細節（與信息隱含類似）。"
- **自底向上設計：** 從程序中的最底層（最原子化）的功能開始設計，然後將這些功能組合起來，逐步構建更高層次的功能。
- 這兩種方法不是相互矛盾的，設計是一個啟發過程，可以嘗試結合使用，並且是逐次迭代逼近的過程。
- **引用：** "這兩種方法并不是互相矛盾的。設計是一個啟發的過程，就是說沒有一種百試不爽的設計方法，它總是一個嘗試的過程。"
- **面向對象（Object-Oriented Design）：**通過分析實際問題，抽象出對象，並用程式語言表現。過程包括識別對象中的子對象及操作，並根據操作開發系統。
- 是一種設計對象或模組的方法，在較低層次上也是設計單個子程序的方法。
- **設計是一個啟發過程：**沒有一種萬能的設計方法，應根據問題選擇適應的方法。
- 不同的方法各有優點和缺點。
- 一些方法的障礙在於其複雜的術語。

**7. 使用數據**

- **數據生成：生成類型：** 對每種可能變動的數據使用不同的類型，類型名稱應面向客觀世界實體，而非程式語言類型。避免重新定義已定義類型。
- **說明數據：** 使用模板簡化數據說明，統一說明形式。對於支持隱式說明的語言，應採取補救措施。
- **初始化：** 每個子程序應檢查輸入參數有效性。在變數使用位置附近進行初始化，恰當初始化/重新初始化計數器和指標。編譯程序應無警告。
- **數據使用：避免「魔法數」（Magic Numbers）：** 使用命名常數代替程式碼中的直接數值，以提高可讀性、可修改性和可維護性。
- **引用：** "「魔法數」是在代碼中以未命名常數出現的數字。...用命名常數來代替它們，可以使程序更加易讀、易修改、易維護，從而降低程序出錯的可能性。"
- **處理零除錯誤：** 採取措施防止零除錯誤。
- **顯式類型轉換：** 明確進行類型轉換。
- **避免混合類型比較：** 盡量避免在同一表達式中混合不同類型變數進行比較。
- **整型數：**注意整型數相除的結果是否與預期一致。
- 避免整型數表達式溢出。
- **浮點數：**避免數量級相差過大的數之間加減運算。
- 系統性採取措施防止捨入誤差。
- 避免對浮點數進行相等比較。
- **字串：**處理字串時，應考慮字符串是空串還是NULL，字串長度限制，字符串溢出等問題。

**8. 變數命名**

- **變數命名要清晰：** 變數名稱是提高程式碼可讀性的最重要因素之一。應盡量使用具有表現力的名稱。
- **引用：** "程序中最重要的信息是變數名稱。程序中的許多內容（如控制結構）是通用的，但變數名稱是專門為你所編的程序而設立的。變數名稱是程序中變動最大、最能體現程序員個性的一個方面。"
- **引用：** "變數名稱應表達所有相關的內容，並避免與其它內容混淆。"
- **命名準則：**避免使用難懂或誤導性的名稱。
- 變數名稱應足夠長以表達其含義，但也不應過長。在局部範圍內可以使用較短名稱，但全局變數或模組變數應使用較長名稱。
- 避免僅省略一個字母的縮寫，並保持縮寫的連續性。
- 所有名稱都應容易發音。
- 邏輯變數名稱應充分表達其為真時的含義。
- 命名常數名稱應指向它們代表的實體，而非數值。
- **命名約定：**應使用命名約定來區分局部、模組和全局數據。
- 區分類型名稱、命名常數、枚舉類型和變數。
- 對於語言不強制區分的輸入參數，應使用約定進行標識。
- 命名約定應盡可能與程式語言的標準約定相容。
- 對名稱進行格式化以增強可讀性。

**9. 全局變數**

- **盡量減小變數作用域：** 這是提高程式碼可讀性、可理解性和可維護性的最重要步驟之一。應盡量使變數成為局部或模組變數，避免使用全局變數。
- **引用：** "盡量減小變數的作用域是你能作到的提高程序可讀性、可理解性和可維護性最重要的步驟之一。盡可能把變數聲明在其使用位置附近，並盡量縮小其作用域。"
- **引用：** "避免使用全局變數。"
- **避免使用全局數據的理由：**全局數據會引入不受歡迎的副作用（函數除了返回值，還改變了全局數據）。
- 全局數據降低程式碼的可讀性。
- 全局數據降低程式碼的可修改性。
- 全局數據降低程式碼的可維護性。
- 全局數據降低程式碼的可測試性。
- 全局數據增加錯誤產生的可能性。
- 全局數據阻止對函數的重複使用。
- 全局數據損害模組性和可管理性。
- **引用：** "使用全局數據最嚴重的問題之一是，任何一個子程序都可以修改它，而你無法確定是哪一個。"
- **使用全局數據的理由：**在極少數情況下，全局數據可能是必要的（例如，需要跨大量子程序存取的數據）。
- 消除「穿梭」數據（數據僅為了傳遞給另一個子程序而傳入某個子程序）。
- **如何降低使用全局數據的危險：**先使所有變數成為局部的，再根據需要改為全局。
- 區分全局和模組變數。
- 使用存取子程序（Accessor Subprograms）來存取全局數據，以實現信息隱藏和集中控制。這提高了程式碼的可讀性、可理解性和可維護性。
- **引用：** "如果全局數據確實不可避免的話，應通過存取子程序來對其進行存取操作。存取子程序不僅具備全局變數和全部功能，而且可以提高程序的可讀性、可理解性和可維護性。"

**10. 基本數據類型**

- 本章討論了使用各種特定基本數據類型（如常數、整型、浮點型、字串、布林值、枚舉類型、命名常數、數組、指標）時需要記住的許多規則和常見問題。提供了檢查表以確認是否考慮了所有常見問題。

**11. 複雜數據類型**

- 本章討論了自己建立的複雜數據類型，包括記錄與結構、表驅動方法和抽象數據類型（ADTs）。
- **表驅動方法（Table-Driven Methods）：** 一種查詢表而非使用邏輯結構（如if-then-else或case語句）來解決問題的技術。適用於從輸入信息到動作的轉換。通常比邏輯結構更易於修改和理解，因為規則集中在表中。
- **引用：** "表驅動方法是一種從輸入信息到動作的轉換，通過查詢表來解決問題的技術，而不是通過邏輯結構（如if-then-else或case語句）來解決問題。"
- **抽象數據類型（Abstract Data Types, ADTs）：** 是一種將數據及其操作集合在一起的概念。用戶通過定義明確的操作來存取數據，而無需知道數據的底層實現細節。這實現了信息隱藏，提高了程式碼的可變動性、可理解性和可維護性。
- **引用：** "抽象數據類型是一種將數據及其對這些數據所進行的操作集合在一起的數據類型，用戶通過定義明確的操作來對抽象數據類型進行存取，而無需知道它是如何實現的。"
- 可以將典型的計算機專業數據結構建為ADTs（如堆棧、表），也可以將常見的客觀世界實體（如文件、僱員）處理為ADTs，從更高的抽象水平處理問題。

**12. 控制結構**

- 討論了各種控制結構，包括順序語句、條件語句（if, case）和循環語句（for, while, loop-with-exit）。
- **循環語句：** 選擇循環類型（計數循環、條件循環、死循環）和控制循環的位置（開始、中間、結束）是關鍵。提供了選擇循環類型和控制循環的指導原則。
- **控制循環：** 討論了編寫循環時可能出現的錯誤（初始化、嵌套、中斷、增量錯誤、數組索引錯誤）並提供了避免這些錯誤的方法。強調在腦中或手工計算循環過程以幫助理解和發現問題。
- **引用：** "在編寫循環時會出哪些錯？當然包括以下錯誤：忽略了與循環有關的變數或累加器初始化、不正確的嵌套、不正確的循環中斷、忘記給循環變數一個增量或給錯了增量、用不正確的循環指標訪問數組元素。"
- **引用：** "高效的程序員總是在腦中或用手算一下，因為他們知道：這樣做可以幫助發現問題。低效率的程序員總是隨意地編寫，反覆修改到最後發現應該是怎樣做。"
- **使用循環控制變數：** 循環計數器通常應為整數，避免使用浮點數。使用有意義的變數名使循環嵌套易讀。
- 強調簡化循環以提高可讀性，技巧包括避免使用怪樣子循環、最小化循環次數、使進出口清晰、將內務程式碼放在一個地方。

**13. 少見的控制結構**

- 討論了一些不太常見的控制結構，可能包括goto語句等。

**14. 程式碼格式化與風格**

- **程式碼格式化：** 格式化的目的是顯示程式碼的邏輯結構、提高可讀性、可維護性。格式應保持一致。應避免過度縮排，複雜表達式應格式化以增強可讀性。
- **引用：** "格式化的本意是要顯示代碼的邏輯結構嗎？格式化的形式能始終一致嗎？格式化後使代碼易於維護嗎？格式化後改進了可讀性嗎？"
- **風格：** 程式碼風格涉及縮排、變數命名、註釋等個人化習慣。應清楚知道自己在處理敏感領域，使用「建議」而非教條「規則」或「標準」，並考慮使用自動格式化工具來規避個人風格衝突。
- **引用：** "程式設計計劃管理人員往往不太清楚個人心理等對程式設計有較大影響。如果你試圖要求遵守一定的程式設計習慣，你可能會激怒你的程式設計師。"
- **引用：** "使用「建議」要同時避免使用教條的「規則」或「標準」。"
- **引用：** "規避使用明確的控制。為了控制縮進風格或大括弧使用，在源代碼宣告完成之前要先經過整齊打印格式化程序運行。"

**15. 自我證明的程式碼與註釋**

- **自我證明的程式碼：** 好的程式碼本身應該足夠清晰易讀，不需要過多註釋。
- **註釋：**不是所有的註釋都有用，只有有效的註釋才能提高程式碼可讀性。
- **引用：** "好的註釋，其重點是“為什麼”而不是“是什麼”或“如何作”。"
- **註釋的種類：** 代碼的重複（無用）、代碼的解釋（在複雜情況下有用，但最好改進程式碼）、代碼中的標記（給開發者的提醒）、代碼的總結（總結一個塊的功能）、代碼的意圖（最有價值，解釋程式碼的目的）。
- **引用：** "重複的註釋，用不同的詞重申了代碼的內容。它沒有給讀者提供代碼的附加信息。...解釋性註釋，典型地用於解釋複雜的，有效的和靈敏的代碼段。...標記註釋并非是故意留在代碼中的註釋。它是給開發者的記錄，表示工作還未做。...總結性註釋，總結了一個代碼塊的功能，而不是逐行描述。這是有用的。...意圖性註釋，闡述了代碼的目標，而不是描述代碼的工作方式。"
- **編寫有效註釋的關鍵點：**保持註釋接近它們描述的程式碼，這樣更可能得到維護。
- 例程的頂部用一兩句註釋來描述其功能。
- 在輸入和輸出變數說明時進行描述。
- 使用統一的註釋風格，並使用標記（如特殊字符）以便工具提取不同種類的訊息。
- 註釋文件、模組和程序，描述其功能，並包含作者姓名、電話號碼、創建日期等信息。
- 描述全局變數的用途。
- 描述令人驚訝的程式碼。
- 刪掉或改進冗餘、自相矛盾的註釋。

**16. 開發工具**

- 討論了各種可以幫助提高程式設計效率和質量的工具，包括編輯器、編譯程序、多文件字串轉換程序、版本控制軟體、Make程序、測試工具、調試程序、執行顯示程序等。
- **編輯器：** 高效的編輯器應提供多種功能，如可程式設計的宏、對齊、搜索和替換、同時編輯多文件等。
- **引用：** "一個好的編輯程序應能提供許多功能，這將會大大地節省你的時間和精力。"
- **版本控制軟體（Version Control Software, SCM）：** 對於任何規模大於幾百行代碼的專案都是必要的。用於管理源代碼的變動歷史、協調團隊開發。
- **引用：** "版本控制軟件（有時被稱為軟件配置管理或SCM）對於任何規模大於幾百行代碼的項目都是必要的。"
- **Make程序：** 自動化編譯過程，確保只編譯需要重新編譯的文件，提高效率。
- **引用：** "如果你的軟件由多個源文件組成，你應使用制作或其它控制依賴軟件來確定哪些文件需要重新編譯。"
- **備份：** 定期對所有項目材料進行備份，並將備份轉移至安全處。應測試備份程序以確保恢復正常工作。

**17. 專案計劃與度量**

- **專案計劃：** 準確估計項目所需時間、人力、物力和財力是重要的。專案規模影響開發方法和先決條件。
- **度量：** 對開發過程進行度量比不度量要好，即使度量不很準確。度量能使你對軟體開發過程進行控制。應量化軟體開發方式，而不僅僅是主觀判斷。
- **引用：** "對開發過程進行度量比根本不度量要好，雖然度量並不很準確；也可能難以制定一個度量標準；它需要隨着時間能推移而不斷精化。但是它能使你能對軟件開發過程進行控制，而沒有度量則不行。"
- **有用的度量：** 包括程式碼行數（總行數、註釋行數）、總質量（錯誤數量、平均失效時間）、生產率（項目時間、修改次數）、可維護性（參數數量、局部變數數量）等。
- **評估和控制：** 更重要的是成功地利用各種資源以滿足計劃要求，而不是初始估計的準確性。
- **如果落後了怎麼辦：** 努力趕上（增加時間通常不明智）、減少功能、調整計劃、改進過程（例如，改進程式設計質量）。

**18. 軟體質量**

- **軟體質量目標：** 軟體質量有多種特性，包括正確性、可用性、效率、可靠性、完整性、適應性、精確性、堅固性等。不是所有質量保證目標都能同時實現，應確定優先級並讓團隊知道。
- **引用：** "你是否讓其他人明白項目的質量目標？你是否要求不同的外部和內部特征？"
- **錯誤檢查方法：** 各種錯誤檢查方法（如測試、檢查、普查）就其自身來說並不十分有效，應結合使用多種方法來確定不同類型的錯誤。
- **引用：** "各種錯誤檢查方法就其自身來說并不十分有效。僅用一種方法消除錯誤并非有效。成功的質量確保計劃使用幾種不同的方法，以確定不同類型的錯誤。"
- **質量保證步驟：** 在軟體開發過程中採取措施確保軟體質量。前期活動對產品質量有更大的影響，前期投入的時間將節省後期的時間和成本。

**19. 程式碼檢查與普查**

- **檢查（Inspections）：** 一種正式的錯誤發現技術，通常涉及一個團隊按照檢查表仔細檢查程式碼。其重點在於發現缺陷，而非糾錯。
- **引用：** "檢查是軟件創建的第二種正式的質量確保技術。這是一種由兩個或更多的人組成的小組（通常3到5人）對程序代碼作正式檢查。"
- 有效的檢查需要檢查員有足夠準備時間、會議富有成果且限制時間、協調者接受訓練、並收集錯誤數據用於改進檢查表。
- **普查（Walkthroughs）：** 一種較不正式的錯誤發現技術，通常由程式設計師向一個小組解釋其程式碼。
- **有效檢查法檢查表：** 強調檢查表應側重於常見錯誤區域，側重於缺陷檢查，檢查員有準備時間，參與者扮演不同角色，會議高效。

**20. 測試**

- **測試的藝術：** 從所有測試用例中找出最能發現錯誤的示例。應側重於提示不同點的用例，而非重複的用例。
- **引用：** "測試的藝術在于從所有測試用例中找出最能發現錯誤的示例來。...你應側重于從所有測試示例中找出能提示不同點的用例，而不是那些不斷地重複着的用例。"
- **基於結構的測試：** 應對程序中的每一條語句至少測試一次。目標是達到程式碼覆蓋（Code Coverage）或邏輯覆蓋（Logic Coverage）。
- **引用：** "基於結構的測試，其實是一個簡單概念。其意思是你應對你程序中的每一條語句至少測試一次..."
- **數據流分析：** 一種通過跟蹤數據從初始化到使用的路徑來生成測試用例的方法。
- **錯誤猜測（Error Guessing）：** 利用過去經驗猜測可能存在錯誤的地方並設計測試用例。
- **測試工具：** 包括程序框架生成器、結果比較工具、自動測試生成程序、記錄測試條件工具、區域監視器、符號調試程序、系統擾亂程序、缺陷數據庫等。
- **單元測試（Unit Testing）：** 程式設計師自己對單個子程序或模組進行測試。
- **系統測試：** 對整個集成系統進行測試。
- **錯誤數據收集與分析：** 收集錯誤數據（類型、位置、嚴重程度、發現時間、改正時間）並進行分析，以確定程式碼質量並改進開發過程。

**21. 調試**

- **調試作為學習機會：** 調試不僅是找到和修正錯誤，更是了解程序、錯誤類型、程式碼質量和解決問題方法的一次機會。
- **引用：** "調試是培植你自身進步的異常肥沃的土壤。它是所有創建道路的交叉路口（可讀性、代碼質量）。"
- **調試的誤區：** 靠猜測發現錯誤、不理解問題本質、不保存原始程式碼、修復症狀而非問題。
- **引用：** "使用以下幾種調試方法可能使程序員備受痛苦：靠猜測發現錯誤...使用以下幾種方法不會有助于你有效地調試：...保存初始源代碼...修改錯誤問題，而不是症狀。"
- **有效調試方法：** 使用科學方法建立假設、精煉測試用例、通過不同方法重現錯誤、產生更多數據、使用否定測試結果、縮小可疑程式碼區域、檢查最近修改的程式碼、逐步集成、懷疑以前出錯的子程序、耐心檢查、設定草率調試的時間上限、檢查一般錯誤、使用交談調試法、中斷思考問題。
- **改正錯誤方法：** 理解問題實質、理解整個程序、確診錯誤、放鬆情緒、保存初始源代碼、修改錯誤而非症狀、僅為某種原因修改程式碼、一次做一個修改、檢查和驗證修改、尋找相似錯誤。
- **符號調試程序：** 是一種工具，可以幫助單步調試程式碼、追蹤變數值，但不能代替思考。有效的調試是思考和好的調試程序的聯合使用。

**22. 集成**

- **集成策略：** 應採用遞增集成策略，而不是一次性集成所有部分。遞增集成有助於快速發現錯誤來源，減少錯誤定位時間。
- **引用：** "遞增集成策略，這是一種每次將程序的一部分或一段加入到程序中，而不是將所有的段一次性加入到程序中的方法。"
- **遞增集成策略的優點：** 易於故障診斷、減少所需的搭架程序、錯誤定位更快。
- **自頂向下集成（Top-Down Integration）：** 從程序結構分層的頂層開始集成，逐步加入下層模組。優點是大的概念性設計問題會很快暴露，並可能使得系統的一部分先盡快工作（如用戶接口）。缺點是可能直到最後才脫離複雜的硬體接口，且可能需要大量的接口。
- **自底向上集成（Bottom-Up Integration）：** 從程序結構分層的最底層開始集成，逐步加入上層模組。優點是早期硬體接口得到處理，且錯誤定位容易。缺點是直到最後才脫離高層系統的集成接口，且可能需要搭架程序（測試驅動程序）。
- **三明治集成（Sandwich Integration）：** 結合自頂向下和自底向上方法。
- **冒險定向集成（Risk-Oriented Integration）：** 優先集成風險最高的部分。
- **功能定向集成（Feature-Oriented Integration）：** 優先集成特定的功能塊。
- 這些方法是啟發性的，可以根據專案要求創造獨特的集成方法。

**23. 改進發佈法**

- **改進發佈法（Evolutionary Delivery）：** 一種迭代開發方法，通過一系列增量的、可用的產品發佈來開發系統。每次發佈都在前一次的基礎上增加功能或改進質量。
- **引用：** "在改進方法中，每一次釋放計劃是建立在前一次釋放基礎上的。...每一次新的釋放都能替換部分老系統並開發新的功能。"
- **優點：** 集成照顧自己（集成問題減少）、改進了用戶的參與和反饋、縮短了開發週期（用戶可以更快看到成果）、鼓勵團隊學習和改進過程。
- **引用：** "它的優點有：集成照顧自己，改進了用戶的參與，縮短了開發週期，改進了管理和控制，改進了團隊合作的紀律性，改進了團隊士氣，它鼓勵改進。"
- **缺點：** 需要更多的技術投資（產品需要多次保持清潔）、如果應用目標不明確，可能會為不確定的設計找藉口。如果應用目標明確，單次發佈可能更有效率。
- **引用：** "改進的公布法需要更多的技術投資。...如果開始時不十分了解應用目的，這也不是一個大缺點，不斷集成不斷釋放確保代碼群都朝同一方向移動。...如果應用目的很明確、多個釋放的經費可能是一種浪費..."

**24. 程式碼調整**

- **程式碼調整（Code Tuning）：** 在程式碼層面進行優化，以提高性能。通常不是提高程序性能最有效或最簡單的方法。
- **引用：** "它不是最有效的提高程序性能的辦法。程序設計、數據結構選擇和演算法選擇通常能產生更好的改進效果，它也不是最簡單的改進性能的方法，買一個新的硬件，或更好的編譯器更加簡單..."
- **程式碼調整的原因：** 可以產生令人驚訝的性能改進（即使只改動幾行程式碼）、掌握寫出高效程式碼的藝術是優秀程式設計師的必經之路。
- **引用：** "第一個吸引人的地方是這種方法似乎公開違抗自然規律。一個需要執行5X108 8 秒的程序，只調換幾行，就減小到執行速度為10 秒，這是難以置信的滿意結果。"
- **找到「糖漿」（性能瓶頸）：** 需要先測量程序執行時間，找到運行最慢的部分。不要在測量之前進行優化。
- **引用：** "找到『糖漿』（指程序中運行最慢的部分）後，你就可以對其進行優化了。首先，你必須測量以確保你所尋找的是運行最慢的部分。"
- **重複優化：** 一旦找到性能弱點，程式碼調整的效果會令人吃驚。即使已找到一種改進方法，仍要繼續探索其他方法，並將多種技術組合起來。
- **引用：** "一旦你找到了性能的弱點，用代碼調整改進性能的效果會使你吃驚，用一種技術方法你將很難獲得10 倍的改進，但你可以有效地將幾種技術組合起來..."
- **常用的程式碼調整技術：** 包括循環調整、使用更快演算法、避免系統調用、注意常用操作的耗費、精簡複雜表達式、使用索引、變換多維數組為一維、減少數組參考量、將常用值高速緩存等。

**25. 軟體優化**

- **軟體優化種類：** 本章重點討論在維護和擴充階段對現有程式碼進行的優化，而非在初始開發階段的優化。
- **軟體優化指南：升級（Upgrading）：** 在維護和擴充階段對現有軟體進行改進。應確保軟體質量隨著時間的推移而提高，而不是惡化。
- **引用：** "開發對提高你的程序質量是一個很好的機會，如果你想有所收益，你應很好地利用每一次機會。"
- **創建新的子程序：** 在修改程序時創建新的子程序是一種提高程序質量的方式。應以平滑結構的方式創建，而非打洞。
- **引用：** "當你修改程序時創建新的子程序的方法，對程序的質量有很大的影響。創建新子程序使用這種方式：你應用平滑結構的粗糙邊緣，而不要再在其上打洞。"
- **改變程序共享程式碼：** 當需要修改程序以支持新功能時，應考慮如何共享新舊程序中的公共部分。常見策略包括在低層建立新子程序供多處調用，或在高層共享程式碼而由低層處理差異。低層共享程式碼通常能獲得更多收益。

**26. 個人性格與軟體開發**

- **個人性格的影響：** 個人的性格特點（如聰明、謙虛、好奇、誠實、交流、合作、創造力、紀律、習慣、甚至一些負面特徵如懶惰）對軟體開發有較大影響。
- **引用：** "一些不受歡迎的特點也會影響你的程序設計質量：懶惰。"
- **聰明與謙虛：** 程式設計師應聰明，但同時也要謙虛，願意承認錯誤並從中學習。
- **引用：** "如果你認為自己聰明，而且你也確實聰明，你應記住還有其他同樣聰明的人。有聰明勁的程式設計師應該謙虛，否則他將會被證明是笨拙的。"
- **好奇心：** 對軟體系統、開發工具、程式語言、算法等保持好奇心，有助於不斷學習和改進。
- **誠實：** 對自己的能力、對程式碼的質量、對錯誤的發生應保持誠實。
- **交流和合作：** 軟體開發是團隊工作，良好的交流和合作至關重要。
- **創造力與紀律：** 創造力有助於提出新的解決方案，但程式設計師也需要紀律性來遵循約定和標準。
- **懶惰：** 有時「有用的」懶惰（避免重複工作）可以驅使人們創建更好的工具或抽象。
- **引用：** "對於一個好的程序員來說，懶惰是一個良好的品質。"
- **習慣：** 好的習慣（如良好的命名習慣、格式化習慣、測試習慣）有助於提高程式碼質量和開發效率。
- **如何提高個人技能：** 包括閱讀書籍、期刊、他人程式碼，讓高水平程式設計師評價自己的程式碼，閱讀手冊，參與會議和交流，不斷學習。
- **引用：** "閱讀他人代碼。...讓其他高水平程序員評價你的代碼質量。...閱讀手冊。...閱讀有關書籍和期刊。"
- **經驗：** 真正的經驗是通過不斷學習和反思錯誤累積的，而非僅僅是工作時間。
- **引用：** "如果一程序員在頭一、二年沒有學C 語言，第三年學也不會產生很大區別。這種類型的經驗和其工作能力沒有多大區別。...如果能堅持不斷地學習，你就能得到經驗，如果你並不想學到什麼，不管多少年你也學不到什麼。"

**27. 軟體開發方法的問題**

- **克服複雜性：** 軟體開發中一個主要挑戰是管理複雜性。
- **精選開發過程：** 應選擇適合專案的開發過程。
- **為人編寫程序，其次才是計算機：** 程式碼首先是寫給其他程式設計師（包括未來的自己）看的，其次才是給計算機執行。強調程式碼的可讀性和可理解性。
- **引用：** "為人編寫程序，其次才是計算機。"
- **注重約定使用：** 應了解約定的真正價值並正確利用它們。約定可以提高程式碼的可讀性、可維護性、可預測性，並彌補語言的不足。
- **引用：** "利用約定可使你和你的程序員同事交流更容易，而且可使你的程序更易於理解和修改。"
- **根據問題範圍程式設計：** 應在盡可能高的抽象級上工作，根據要解決的問題進行程式設計，而不是根據計算機細節。
- **引用：** "在最高可能的抽象級上工作。...在最高抽象上編程的一種方法是根據問題而不是計算機進行編程。"
- **當心飛來之禍：** 指由於不恰當的決策或外部因素導致的問題。
- **重複：** 有時需要重複工作以達到更好的結果。
- **不要固執己見：** 應願意接受他人的意見和不同的方法。

**28. 從何處獲取更多信息**

- 建議獲取更多軟體領域信息的途徑，包括圖書館、書籍、期刊、交流、閱讀他人程式碼等。