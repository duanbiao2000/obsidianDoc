---
title: Backend Architecture | toeverything/AFFiNE
source: https://deepwiki.com/toeverything/AFFiNE/3-backend-architecture
author:
  - "[[DeepWiki]]"
published: 
created: 2025-04-30
description: AFFiNE 的后端架构概览，基于 NestJS、GraphQL、Prisma、PostgreSQL 和 Rust 本地模块，重点介绍其 AI 系统和部署模型。
tags:
  - Creative/clippings
  - Tech/AI
---
## Anki


## LangChain 代理系统

[[github值得关注的开源项目|LangChain]] 代理系统提供了一个框架，允许使用大型语言模型 (LLM) 作为推理引擎来执行多步任务。代理可以调用工具、观察结果并迭代地做出决策，直到任务完成。这对于需要与外部环境交互或进行复杂推理的场景非常实用。

**核心组件:**

1.  **LLM/聊天模型:** 代理的“大脑”，负责推理和决策。
2.  **工具:** 代理用来与外部世界（如 API、数据库、文件系统）交互的函数。
3.  **编排框架:** 管理代理的执行流程和状态。
4.  **记忆/持久性:** 在多次交互中保持会话历史和状态。

**实现方法:**

*   **[[LangChain和LangGraph|LangGraph]] (推荐):** 基于图结构，提供更灵活、模块化的代理构建方式。定义了流程中的各种节点（如 LLM 节点、工具节点、条件节点）。
*   **AgentExecutor (遗留):** 适用于简单用例的直接实现方式。

**常见模式:**

*   **[[利用SCQRA模型分析解决复杂问题|ReAct]] (Reasoning + Action):** 代理通过思考（Thought）、选择行动（Action）、观察行动结果（Observation），然后得出最终答案（Answer）来逐步解决问题。

**[[WF_工具巧妙运用|工具集成]]:**

工具是代理执行外部操作的关键。可以通过多种方式创建工具，并将其绑定到 LLM，使模型知道何时以及如何使用这些工具。

**记忆:**

对于会话型代理，记忆（通过持久化实现，如使用 Checkpointer）允许代理在不同轮次的对话中记住上下文，从而实现连贯的交流。

**应用示例:**

代理系统可用于构建各种应用，包括：

*   **对话代理:** 能在需要时使用工具的聊天机器人。
*   **RAG 代理:** 与知识库交互以检索信息。
*   **SQL 代理:** 查询数据库。
*   **多工具代理:** 协调使用多种不同工具。

总之，LangChain 代理系统通过结合 LLM 的推理能力和外部工具的交互能力，使得构建能够处理复杂、动态任务的 AI 应用成为可能。

## Express.js 架构

[[github值得关注的开源项目|Express.js]] 是一个快速、简洁、极简的 Node.js Web 框架。它的核心理念是提供构建 Web 应用（单页应用、网站、API 等）所需的小型、强大的基础工具集，同时保持灵活性，不强制使用特定的 ORM 或模板引擎。

**核心理念:**

*   **极简主义:** 只专注于核心 Web 功能。
*   **不固执己见:** 不强制特定的项目结构或模式。
*   **灵活:** 易于与其他 Node.js 模块和中间件集成。
*   **性能导向:** 在 Node.js 原生 HTTP 功能之上保持最小开销。

**架构概览:**

Express.js 建立在 Node.js 的 HTTP 模块之上，采用模块化设计和职责分离。其核心通过原型继承扩展 Node.js 的请求和响应对象，并利用中间件管道处理请求。

**请求-响应生命周期:**

当一个请求到达 Express 应用时，会经过以下主要步骤：

1.  **应用调用:** 使用请求和响应对象调用 Express 应用实例。
2.  **请求/响应增强:** Express 为 Node.js 原生请求/响应对象添加额外属性和方法。
3.  **中间件处理:** 请求按顺序通过注册的中间件函数。
4.  **路由匹配:** 尝试将请求路径和方法与已定义的路由匹配。
5.  **处理程序执行:** 如果路由匹配，执行相应的路由处理函数。
6.  **响应生成:** 生成响应并发送回客户端。

**核心组件:**

1.  **Application 对象 (`app`):** 通过 `express()` 创建。它是应用的核心，充当 HTTP 请求处理程序、配置容器、中间件管理器、路由器，并负责启动服务器 (`app.listen()`)。它提供如 `app.use()` 添加中间件、`app.METHOD()` 定义路由等方法。
2.  **请求对象 (`req`):** 扩展自 Node.js 的 `http.IncomingMessage`。提供对请求数据（如 `req.params`、`req.query`、`req.body`）和头部信息的访问。
3.  **响应对象 (`res`):** 扩展自 Node.js 的 `http.ServerResponse`。提供发送各种类型响应（如 `res.send()`、`res.json()`）、设置状态码 (`res.status()`)、重定向 (`res.redirect()`) 等方法。`res.send()` 方法能够根据内容自动设置适当的响应类型。
4.  **中间件系统:** 函数形式为 `(req, res, next)`。它们按顺序执行，可以处理请求、修改对象、结束请求或调用 `next()` 将控制权传递给下一个中间件或路由处理程序。通过 `app.use()` 注册中间件。例如，`express.json()` 是常用的用于解析请求体的内置中间件。
5.  **路由系统:** 将特定的 HTTP 方法和 URL 路径映射到处理函数。通过在应用对象上调用对应 HTTP 方法的函数（如 `app.get()`、`app.post()`）来定义路由。路由器模块负责匹配路径、提取参数并执行处理程序。

总而言之，Express.js 的设计使其成为一个轻量且强大的 Web 框架，其核心在于模块化的组件和通过中间件及路由构建的请求处理管道。