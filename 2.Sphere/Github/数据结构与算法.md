---
tags:
  - Domain/Creativity/Github
  - Domain/Mindset/Atlas
  - System/DG/Seedling
categories:
  - Code
update: 2025-05-17 11:10
---

[Algorithm Visualizer](https://algorithm-visualizer.org/)
[GitHub - trekhleb/javascript-algorithms: 📝 Algorithms and data structures implemented in JavaScript with explanations a...](https://github.com/trekhleb/javascript-algorithms)
[GitHub - keon/algorithms: Minimal examples of data structures and algorithms in Python](https://github.com/keon/algorithms)

# 我的数据结构与算法作品集：核心概念与实践之路

**引言：**

数据结构与算法（DSA）是计算机科学的基石，是解决复杂问题、写出高效代码的“内功心法”。掌握 DSA 不仅是为了应对面试，更是为了培养清晰的逻辑思维、高效的问题解决能力。

这份《我的数据结构与算法作品集》是我的**个人学习地图、实践记录与知识沉淀**。它基于对 DSA 核心主题的理解，结合我的学习过程、刷题实践、项目应用以及个人反思而构建。我将把每一次对 DSA 概念的深入理解、每一个算法的实现、每一个问题的解决，都视为这份“作品”的一部分，持续地丰富和打磨它。

---

## 核心概念模块：数据组织与算法思想的本质

**模块目标：** 以直观易懂的方式（费曼式）把握数据结构的核心原理和经典算法的基本思想，建立扎实的理论基础。

### 1. 数据组织的本质：结构决定效率！

> [!INFO] **核心思想：** 数据结构就像数据的“书架设计”，不同的组织方式决定了存取、修改、删除等操作的效率。选择合适的数据结构是解决问题的关键第一步。
> [!QUESTION] **关键考量：** 根据具体应用场景（读多写少？频繁插入删除？需要快速查找某个值？）来权衡时间和空间复杂度，选择最适合的数据结构。

- [在此记录你对“结构决定效率”的个人理解和体会]
- **我的实践与关联作品：**
  - [[时间复杂度和空间复杂度分析]] (我对 O(n), O(log n) 等概念的理解笔记)
  - [链接到你在某个项目中因选择正确数据结构而提升效率的案例笔记]

### 2. 数组 vs 链表对决：连续与离散的权衡

> [!INFO] **核心思想：**
>
> - **数组：** 内存连续，随机访问快 $O(1)$，插入/删除慢 $O(n)$。像紧密排列的士兵方阵，定位快但调整队形慢。
> - **链表：** 内存离散，通过指针连接，插入/删除快 $O(1)$（已知前驱节点），随机访问慢 $O(n)$。像手拉手的小朋友，插入新人方便但找特定小朋友要挨个问。
>
> [!QUESTION] **何时使用：** 需要频繁随机访问用数组，需要频繁插入删除用链表（特别是在中间位置）。

- [在此记录你对数组和链表优劣势的理解和实践经验]
- **我的实践与关联作品：**
  - [链接到你用数组解决的 LeetCode 问题笔记或代码]
  - [链接到你用链表解决的 LeetCode 问题笔记或代码]
  - [[链表基础操作实现]] (我对单链表、双链表、循环链表基础操作的实现代码笔记)

### 3. 栈与队列的哲学：限定操作的序列结构

> [!INFO] **核心思想：**
>
> - **栈 (Stack)：** 后进先出 (LIFO)。操作像叠盘子，只能在顶部进出。用于函数调用栈、DFS、括号匹配等。
> - **队列 (Queue)：** 先进先出 (FIFO)。操作像排队买票，从队尾进，队头出。用于 BFS、任务调度等。
>
> [!QUESTION] **应用场景：** 需要“回溯”或处理嵌套结构的用栈，需要按顺序处理任务的用队列。

- [在此记录你对栈和队列的应用场景的理解，特别是它们如何简化特定问题]
- **我的实践与关联作品：**
  - [[栈在深度优先搜索 (DFS) 中的应用]] (DFS 模板与栈的关联分析笔记)
  - [[队列在广度优先搜索 (BFS) 中的应用]] (BFS 模板与队列的关联分析笔记)
  - [链接到使用栈或队列解决的实际问题或刷题记录]

### 4. 树的智慧：层级结构的威力

> [!INFO] **核心思想：** 树是非线性的层级结构，用于表示数据之间的层级或父子关系。
>
> - **二叉树：** 每个节点最多有两个子节点。二叉搜索树 (BST) 实现了高效的查找、插入和删除 $O(\log n)$ (平均)。平衡二叉树 (AVL, 红黑树) 保证了这些操作的最坏情况性能。
> - **B树/B+树：** 多叉树，数据库索引的基石，为磁盘存储优化。
>
> [!QUESTION] **应用场景：** 文件系统、组织架构、数据库索引、语法解析等。

- [在此记录你对不同树结构的理解，特别是 BST 的平衡重要性]
- **我的实践与关联作品：**
  - [[二叉树遍历方法总结]] (前序、中序、后序、层序遍历的递归与迭代实现笔记)
  - [[二叉搜索树基础操作]] (插入、删除、查找的实现代码与分析)
  - [链接到你用树结构解决的 LeetCode 问题或项目案例]

### 5. 图的强大表达力：万物互联的世界

> [!INFO] **核心思想：** 图由节点（顶点）和连接节点的边组成，用于表示任意复杂的关联关系。
>
> - **探索策略：** DFS (深度优先搜索，执着深入) 和 BFS (广度优先搜索，广泛撒网) 是遍历图的两种基本方法。
>
> [!QUESTION] **应用场景：** 社交网络、地图导航、依赖关系分析、电路设计等。

- [在此记录你对图结构建模实际问题的理解，以及 DFS/BFS 的直观区别]
- **我的实践与关联作品：**
  - [[图的表示方法]] (邻接矩阵 vs 邻接表实现与权衡笔记)
  - [[DFS 和 BFS 算法模板]] (包含代码实现和应用场景分析)
  - [[最短路径算法]] (Dijkstra, Floyd-Warshall 等算法学习笔记与实现)
  - [[最小生成树算法]] (Prim, Kruskal 等算法学习笔记与实现)

### 6. 搜索的艺术：快速找到你需要的数据

> [!INFO] **核心思想：** 高效搜索是数据结构价值的直接体现。
>
> - **二分查找：** 在有序数组中快速查找 $O(\log n)$。像查字典，每次排除一半。
> - **哈希表 (Hash Table)：** 通过哈希函数将键映射到桶，理想情况下查找、插入、删除都是 $O(1)$。是终极查找神器，但需要解决冲突（多个键映射到同一个桶）和动态扩容问题。
>
> [!QUESTION] **应用场景：** 查找元素、去重、计数、缓存实现等。

- [在此记录你对二分查找和哈希表的理解，特别是哈希冲突的解决方式]
- **我的实践与关联作品：**
  - [[二分查找算法实现与变体]] (标准二分、查找第一个/最后一个等于/大于/小于特定值的变体)
  - [[哈希表实现原理与冲突解决方法]] (链地址法、开放寻址法等分析)
  - [链接到你用哈希表解决的实际问题或刷题记录，比如两数之和]

### 7. 排序的本质：让数据井然有序

> [!INFO] **核心思想：** 将数据按照特定规则排列。
>
> - **比较排序：** 通过元素之间的比较来排序。常见算法如冒泡、选择、插入 ($O(n^2)$)，归并、快速 ($O(n \log n)$ 平均)。$O(n \log n)$ 是比较排序的理论下限。
> - **非比较排序：** 不通过比较，利用数据特性进行排序。如计数排序、桶排序、基数排序 ($O(n)$ 在特定条件下)。
>
> [!QUESTION] **何时使用：** 根据数据规模、是否部分有序、稳定性要求、内存限制等选择排序算法。

- [在此记录你对不同排序算法的理解，特别是它们的核心思想和适用场景]
- **我的实践与关联作品：**
  - [[经典排序算法实现]] (包含冒泡、选择、插入、归并、快速排序的 Python/JS 实现代码)
  - [[非比较排序算法]] (计数排序、桶排序、基数排序的学习笔记)
  - [链接到你对排序算法性能进行分析或比较的记录]

### 8. 动态规划魔法：化繁为简，避免重复劳动 [[../../2.Sphere/Github/动态规划魔法-DP-问题分解]]

> [!INFO] **核心思想：** **将大问题拆分成相互重叠的子问题**，通过**记录并复用子问题的解**来求解原问题。适用于具有**最优子结构**和**重叠子问题**性质的问题。
>
> > [!NOTE] **原子笔记 11：动态规划 - 拆解与复用子问题**
> > 核心原理：动态规划通过将原问题分解为相互重叠的子问题来求解。其关键在于识别子问题，并存储子问题的解（通常用数组或哈希表），避免重复计算。它适用于具有最优子结构和重叠子问题性质的问题。
> > 关联：[[24种算法模式]] - 动态规划（Dynamic Programming）
>
> [!QUESTION] **解题步骤：** 1. 定义状态 (dp 数组的含义)； 2. 找到状态转移方程 (如何从子问题推导原问题)； 3. 给出初始状态； 4. 确定计算顺序。

- [在此记录你对动态规划的理解，特别是如何识别 DP 问题和构建状态转移方程]
- **我的实践与关联作品：**
  - [[动态规划经典问题解析]] (背包问题、最长公共子序列、爬楼梯等问题的 DP 解法分析与代码)
  - [链接到你独立解决或深入研究的 DP 问题记录]

### 9. 贪心与回溯：局部最优与穷尽探索

> [!INFO] **核心思想：**
>
> - **贪心算法：** 每一步都做出当前看起来最优的选择，期望得到全局最优解。像短线炒股，关注当前。不回溯。
> - **回溯算法：** 一种通过尝试所有可能的路径来找到解的算法。像走迷宫，遇到死路就回退，尝试其他路径。常用于解决组合、排列、子集等问题。
>
> > [!NOTE] **原子笔记 12：贪心算法 - 关注当前最优**
> > 核心原理：贪心算法在每一步决策时，都采取当前看起来最优的选择，期望通过局部最优解的序列最终达到全局最优解。它不回溯，决策简单快速。但其正确性依赖于问题是否具有贪心选择性质和最优子结构，并非所有优化问题都适用。
> > 关联：[[24种算法模式]] - 贪心算法
>
> [!QUESTION] **适用性：** 贪心算法需要证明其正确性（具有贪心选择性质和最优子结构）。回溯是通用方法，但可能面临性能问题（指数级复杂度）。

- [在此记录你对贪心和回溯的理解，特别是如何判断一个问题是否适合用贪心，以及回溯的基本框架]
- **我的实践与关联作品：**
  - [[贪心算法经典问题]] (如零钱兑换、活动选择问题分析)
  - [[回溯算法模板与应用]] (组合、排列、子集问题的回溯解法)
  - [链接到你用贪心或回溯解决的实际问题或刷题记录]

### 10. 内存三剑客：栈、堆、寄存器的分工

> [!INFO] **核心思想：** 理解程序运行时数据在内存中的存放位置有助于理解算法的实现细节和性能。
>
> - **栈 (Stack)：** 函数调用信息（局部变量、返回地址）存放区域。由编译器自动管理，速度快，空间有限。
> - **堆 (Heap)：** 动态分配的内存区域。程序员手动管理（malloc/free, new/delete），空间大，速度相对慢，可能产生内存碎片。对象实例通常存放在堆上。
> - **寄存器 (Registers)：** CPU 内的高速缓存，存放当前正在执行的指令和数据。速度极快，空间最小。
>
> [!QUESTION] **关联：** DSA 中讨论的空间复杂度主要关注**堆**上的内存使用（动态分配的数据结构），而函数递归调用的深度会影响**栈**空间的使用。

- [在此记录你对内存分配和管理的理解，特别是它如何影响算法的实现和性能]
- **我的实践与关联作品：**
  - [[程序内存布局]] (更详细的程序内存区域划分笔记)
  - [[递归与栈]] (递归调用如何使用栈空间的分析)

---

## 学习资源与工具 (Learning Resources & Tools)

**模块目标：** 汇集并记录我在学习 DSA 过程中使用的外部资源，并记录使用体验和心得。

- [Algorithm Visualizer](https://algorithm-visualizer.org/) - 用来可视化算法过程，非常有帮助。
- [GitHub - trekhleb/javascript-algorithms](https://github.com/trekhleb/javascript-algorithms) - JavaScript 算法实现参考。
- [GitHub - keon/algorithms](https://github.com/keon/algorithms) - Python 算法实现参考。
- [在此添加你常用的刷题平台、教程、书籍、课程等链接]
  - 例如：[力扣 (LeetCode)](https://leetcode.cn/) - 我的刷题主战场
  - 例如：[[数据结构与算法 xx 书籍笔记]]
- [在此记录你使用这些工具或资源的心得体会]

---

## 实践记录与代码片段 (Practice Log & Code Snippets)

**模块目标：** 记录你解决的具体问题（刷题、项目中的算法实现），链接到对应的代码文件，并记录解题思路、遇到的困难和学到的东西。

- **问题：** [LeetCode 题号或问题描述] - 例如：[[LeetCode 1 - 两数之和]]
  - **使用概念：** [[哈希表实现原理与冲突解决方法]]
  - **解题思路：** [简述思路]
  - **遇到的困难：** [遇到的 Bug 或理解难点]
  - **解决方案/学到：** [如何解决的，学到了什么]
  - **我的代码：** [链接到你的代码文件]
- **问题：** [项目中的算法实现] - 例如：[[路径规划算法在xxx项目中的应用]]
  - **使用概念：** [[最短路径算法]]
  - **实现细节：** [简述实现过程]
  - **性能优化：** [是否进行了优化，如何优化]
  - **我的代码：** [链接到项目中的算法代码]
- [在此添加更多你的实践记录]

---

## 作品集的演进与反思 (Evolution & Reflection)

**模块目标：** 定期回顾这份“作品”，评估学习进展，记录新的感悟，规划未来的学习方向。

- **[YYYY-MM-DD] 第一次构建：** 梳理了 DSA 的核心主题，建立初步框架。
- **[YYYY-MM-DD] 重要更新：**
  - 填充了部分核心概念的解释和个人理解。
  - 增加了 [[LeetCode 1 - 两数之和]] 的实践记录。
  - 对 [[动态规划经典问题解析]] 笔记进行了更新和完善。
- **当前挑战：** 感觉对图算法的高级主题（如图切割、网络流）理解不够深入，需要重点学习。
- **下一步计划：**
  - 深入学习图算法，完成 [[最大流最小割]] 的学习笔记和代码实现。
  - 尝试用更优雅的方式重构 [[经典排序算法实现]] 中的部分代码。
  - 将某个小型项目中的算法部分提取出来，整理到实践记录中。
- **总的感悟：** DSA 的学习是一个持续的过程，理论结合实践才能真正掌握。这份作品集将是我的“内功修炼日志”。

---

通过以上框架，这份《数据结构与算法》笔记被转化为一份有结构的、有内容的、有个人实践记录的、持续演进的“作品”。它不仅包含了 DSA 的核心知识，更融入了你个人的学习轨迹、思考深度和实践成果，成为你技术成长道路上宝贵的资产。
