---
tags:
  - Creative/Github
  - Mindset/Atlas
categories:
  - Code
---
[Algorithm Visualizer](https://algorithm-visualizer.org/)
[GitHub - trekhleb/javascript-algorithms: 📝 Algorithms and data structures implemented in JavaScript with explanations a...](https://github.com/trekhleb/javascript-algorithms)
[GitHub - keon/algorithms: Minimal examples of data structures and algorithms in Python](https://github.com/keon/algorithms)

## 核心主题
让我用费曼式的语言为你讲述数据结构与算法的核心主题。以下是我整理的10大核心要点：

1. **数据组织的本质**
结构决定效率！就像图书馆的书架排列方式会影响找书速度一样，数据结构就是数据的"书架设计"。关键在于根据操作类型(查得多还是改得多)选择最优结构。

2. **数组 vs 链表对决**
数组像紧密排列的士兵方阵，随机定位速度快(O(1))但调整队形慢；链表像手拉手的小朋友，插入新人很方便(O(1))但找第100个孩子得挨个数(O(n))。

3. **栈与队列的哲学**
栈是"叠盘子"思维(LIFO，后进先出)——函数调用、回溯算法都用它；队列是"排队买票"(FIFO，先进先出)——BFS广度优先搜索的基础。

4. **树的智慧**
二叉树就像高效的二分查找器：每次比较都能砍掉一半可能性。B树则是数据库的脊梁，能高效处理海量数据。

5. **图的强大表达力**
从社交网络到交通路线，任何关联关系都能用图表示。关键在于掌握DFS(执着深入)和BFS(广泛撒网)两种探索策略。

6. **搜索的艺术**
二分查找(O(log n))就像字典查词，每次都排除一半错误答案。哈希表(O(1))则是终极查找神器，但需要足够大的"房间"(桶)避免拥挤。

7. **排序的本质**
比较排序最快能到O(n log n)，就像比赛分组淘汰赛。而非比较排序(如桶排序)在某些场景能实现O(n)，前提是知道数据分布特点。

8. **[[../../2.Sphere/Github/动态规划魔法-DP-问题分解]]**
把大问题拆成小问题，记住已经解决的子问题(备忘录)，避免重复计算。就像解数学题时记录中间步骤一样。

9. **贪心与回溯**
贪心算法像短线炒股，每次选择当前最优；回溯算法像试错探索，走不通就回退。各有利弊。

10. **内存三剑客**
理解栈(函数调用)、堆(动态内存)、寄存器(CPU直连)的区别，就像了解仓库、货架和收银台的分工。

记住核心逻辑：每种数据结构都是为了解决特定类型的问题而降生的工具。选择数据结构的本质是在时间(操作速度)和空间(内存占用)之间找到最佳平衡点。

需要我深入讲解哪个主题吗？我们可以像讨论物理学问题一样探讨这些概念。


---

**原子笔记 11：动态规划 - 拆解与复用子问题**
核心原理：动态规划通过将原问题分解为相互重叠的子问题来求解。其关键在于识别子问题，并存储子问题的解（通常用数组或哈希表），避免重复计算。它适用于具有最优子结构和重叠子问题性质的问题。
关联：[[24种算法模式]] - 动态规划（Dynamic Programming）

---

**原子笔记 12：贪心算法 - 关注当前最优**
核心原理：贪心算法在每一步决策时，都采取当前看起来最优的选择，期望通过局部最优解的序列最终达到全局最优解。它不回溯，决策简单快速。但其正确性依赖于问题是否具有贪心选择性质和最优子结构，并非所有优化问题都适用。
关联：[[24种算法模式]] - 贪心算法




