感謝你的補充要求！針對用戶的模糊輸入“如何快速獲取tweet具體用戶的歷史推文”以及新增的“輸出應該使用主流數據庫進行持久化”要求，我將更新需求規範文檔，明確加入主流數據庫持久化的需求。以下是結構化、工程可執行的更新版需求規範文檔，保持清晰且實用，符合系統分析師的嚴謹風格，並專注於持久化相關的改進。文檔將保留原有的五項結構（目標意图、輸入規範、輸出定義、約束與邊界、示例），並在相關部分融入數據庫持久化的要求。

---

# 需求規範文檔：快速獲取特定用戶的歷史推文（含數據庫持久化）

## 1. 目標意图（Intent）
用戶希望通過輸入特定Twitter/X用戶的用戶名或其他唯一標識，快速檢索該用戶的歷史推文，支持按關鍵詞、日期範圍等條件過濾，查詢結果需持久化存儲到主流數據庫中，以便後續分析、審計或跨會話復用。核心目標是提供高效、準確的推文檢索功能，結合可靠的數據持久化，滿足個人研究、市場分析或社交媒體監控等場景，確保數據可追溯和長期可用。

## 2. 輸入規範（Input）
系統應接收以下輸入信息，與原需求一致，無需新增輸入項，但需明確持久化相關的輸入處理：

| 輸入項            | 類型       | 來源                    | 格式要求                                                                 | 是否必填 |
|--------------------|------------|-------------------------|--------------------------------------------------------------------------|----------|
| 用戶標識          | 字符串     | 用戶手動輸入            | Twitter/X用戶名（例如“@username”或“username”）或用戶ID（數字字符串）      | 是       |
| 關鍵詞            | 字符串     | 用戶手動輸入            | 純文本，支持多關鍵詞（空格分隔，例如“AI machine learning”）               | 否       |
| 日期範圍          | 日期對     | 用戶手動輸入            | 開始日期和結束日期，格式為“YYYY-MM-DD”（例如“2023-01-01,2023-12-31”）   | 否       |
| 最大推文數        | 整數       | 用戶手動輸入            | 正整數，範圍1-1000，默認100                                             | 否       |
| API認證信息       | 對象       | 用戶配置文件或環境變量  | JSON對象，包含API Key、Access Token等（例如`{ "api_key": "xxx" }`）      | 是       |

- **格式要求**：
  - 字符串輸入需進行XSS防護，剔除非法字符（如`<`、`>`）。
  - 日期範圍若未提供，默認檢索最近30天的推文。
  - 用戶標識需驗證有效性（正則匹配用戶名格式或ID為數字）。
- **持久化相關處理**：
  - 所有輸入需記錄到數據庫的查詢日誌表（`query_log`），包括用戶標識、關鍵詞、日期範圍、查詢時間（ISO 8601格式）和查詢者身份（若有）。
  - 日誌表需支持審計，記錄每次查詢的唯一ID（UUID）。

## 3. 輸出定義（Output）
系統應返回以下結果，並將結果持久化到主流數據庫：

| 輸出項            | 格式       | 內容描述                                                                 | 性能/延遲要求                     |
|--------------------|------------|--------------------------------------------------------------------------|------------------------------------|
| 推文列表          | JSON數組   | 每條推文包含：ID、用戶名、內容、發布時間（ISO 8601格式）、轉發數、點贊數 | 首次查詢<2秒，緩存查詢<0.5秒     |
| 查詢狀態          | 字符串     | 成功（“success”）或失敗（“error”）及錯誤信息（如“無效用戶名”）          | 錯誤響應<0.1秒                    |
| 總數統計          | 整數       | 匹配的推文總數                                                          | -                                  |

- **輸出格式示例**：
  ```json
  {
    "status": "success",
    "total_count": 50,
    "tweets": [
      {
        "id": "1234567890123456789",
        "username": "username",
        "text": "This is a sample tweet about AI!",
        "created_at": "2023-06-15T12:00:00Z",
        "retweet_count": 10,
        "like_count": 25
      },
      ...
    ],
    "query_id": "e8e616e0-d894-4936-a3f5-391682ee794c"
  }
  ```
- **持久化要求**：
  - **數據庫選擇**：使用主流關聯型數據庫（如PostgreSQL或MySQL）進行持久化，優先PostgreSQL（因其JSONB支持和性能優勢）。
  - **表結構**：
    - **推文表（`tweets`）**：
      - `tweet_id`（字符串，主鍵，Twitter/X推文ID）
      - `username`（字符串，索引，用戶名）
      - `text`（文本，推文內容）
      - `created_at`（時間戳，發布時間）
      - `retweet_count`（整數，轉發數）
      - `like_count`（整數，點贊數）
      - `query_id`（字符串，外鍵，關聯查詢日誌）
      - `inserted_at`（時間戳，插入時間，默認當前時間）
    - **查詢日誌表（`query_log`）**：
      - `query_id`（字符串，主鍵，UUID）
      - `user_identifier`（字符串，用戶標識）
      - `keywords`（字符串，可空，查詢關鍵詞）
      - `date_range_start`（日期，可空，開始日期）
      - `date_range_end`（日期，可空，結束日期）
      - `max_tweets`（整數，最大推文數）
      - `query_time`（時間戳，查詢時間）
      - `status`（字符串，查詢狀態：success/error）
      - `error_message`（字符串，可空，錯誤信息）
  - **存儲邏輯**：
    - 查詢成功後，將推文列表和查詢元數據（輸入+狀態）插入數據庫。
    - 若推文已存在（`tweet_id`重複），更新`retweet_count`和`like_count`，避免重複存儲。
    - 查詢日誌每次插入新記錄，保留查詢歷史。
  - **查詢支持**：
    - 支持從數據庫直接查詢已存儲的推文（例如按`username`或`query_id`），響應時間<0.5秒。
    - 提供API端點（`/tweets/stored`）查詢歷史數據。
- **性能要求**：
  - 首次查詢（API+數據庫寫入）：2秒內完成。
  - 緩存或數據庫查詢：0.5秒內返回。
  - 數據庫寫入（批量插入100條）：0.2秒內完成。
- **其他要求**：
  - 推文按`created_at`降序排列。
  - 支持分頁（每頁100條），包含`next_cursor`。
  - 輸出支持JSON和CSV格式。
  - 數據庫操作需事務化，確保寫入一致性。

## 4. 約束與邊界（Constraints）
- **功能邊界**（無變化）：
  - 僅檢索公開用戶的公開推文，不支持私密賬戶或受限內容。
  - 不支持實時推文流，僅限歷史數據。
  - 最大檢索範圍受Twitter/X API限制（最近3200條推文或7天內數據，視API層級而定）。
- **技術約束**：
  - **數據庫選擇**：優先PostgreSQL（版本15+），備選MySQL（8.0+）。不支持NoSQL（如MongoDB），因數據結構為結構化且關聯查詢頻繁。
  - **數據庫性能**：
    - 推文表預計存儲規模：100萬條/年（假設日均1000次查詢，每次100條）。
    - 索引：`tweet_id`（主鍵）、`username`（查詢頻繁）、`created_at`（排序）。
    - 分區：按`inserted_at`按年分區，提升查詢和清理效率。
  - **API限制**：Twitter/X API v2，每15分鐘450次請求，系統需實現重試和緩存（Redis，TTL 24小時）。
  - **持久化約束**：
    - 數據保留期限：2年，超期數據自動歸檔或刪除。
    - 數據庫寫入需批量處理（每100條一批），降低I/O負載。
    - 提供數據庫遷移腳本（SQL），支持從MySQL到PostgreSQL切換。
- **安全約束**：
  - API認證信息加密存儲（AES-256）。
  - 數據庫訪問需角色控制（RBAC），僅授權用戶可查詢`query_log`。
  - 推文內容需過濾敏感詞（正則匹配），避免違規存儲。
- **法律與倫理**（無變化）：
  - 遵守Twitter/X使用條款，不得用於非法監控或數據濫用。
  - 需提示用戶僅用於合法目的。
- **依賴項**：
  - 外部API：Twitter/X API v2。
  - 數據庫：PostgreSQL（優先）或MySQL。
  - 庫：Axios（HTTP）、Sequelize/Knex（ORM）、Redis（緩存）、Day.js（日期）。
  - 工具：Flyway/Liquibase（數據庫遷移）。

## 5. 示例（Example I/O）
### 輸入示例
```json
{
  "user_identifier": "@elonmusk",
  "keywords": "AI Tesla",
  "date_range": {
    "start": "2023-01-01",
    "end": "2023-12-31"
  },
  "max_tweets": 100,
  "auth": {
    "api_key": "xxxx",
    "access_token": "yyyy"
  }
}
```

### 輸出示例（返回給用戶）
```json
{
  "status": "success",
  "total_count": 42,
  "query_id": "e8e616e0-d894-4936-a3f5-391682ee794c",
  "tweets": [
    {
      "id": "1234567890123456789",
      "username": "elonmusk",
      "text": "AI is the future of Tesla! 🚗 #AI #Tesla",
      "created_at": "2023-06-15T12:00:00Z",
      "retweet_count": 1500,
      "like_count": 5000
    },
    {
      "id": "9876543210987654321",
      "username": "elonmusk",
      "text": "Building AI to accelerate human discovery.",
      "created_at": "2023-03-10T09:30:00Z",
      "retweet_count": 2000,
      "like_count": 7500
    }
  ],
  "next_cursor": "abcdef123456"
}
```

### 數據庫存儲示例
- **推文表（`tweets`）**：
  ```sql
  INSERT INTO tweets (tweet_id, username, text, created_at, retweet_count, like_count, query_id, inserted_at)
  VALUES
    ('1234567890123456789', 'elonmusk', 'AI is the future of Tesla! 🚗 #AI #Tesla', '2023-06-15T12:00:00Z', 1500, 5000, 'e8e616e0-d894-4936-a3f5-391682ee794c', '2025-05-19T23:55:00Z'),
    ('9876543210987654321', 'elonmusk', 'Building AI to accelerate human discovery.', '2023-03-10T09:30:00Z', 2000, 7500, 'e8e616e0-d894-4936-a3f5-391682ee794c', '2025-05-19T23:55:00Z')
  ON CONFLICT (tweet_id) UPDATE SET retweet_count = EXCLUDED.retweet_count, like_count = EXCLUDED.like_count;
  ```
- **查詢日誌表（`query_log`）**：
  ```sql
  INSERT INTO query_log (query_id, user_identifier, keywords, date_range_start, date_range_end, max_tweets, query_time, status)
  VALUES
    ('e8e616e0-d894-4936-a3f5-391682ee794c', '@elonmusk', 'AI Tesla', '2023-01-01', '2023-12-31', 100, '2025-05-19T23:55:00Z', 'success');
  ```

### 歷史查詢示例
- **請求**：`GET /tweets/stored?query_id=e8e616e0-d894-4936-a3f5-391682ee794c`
- **響應**：
  ```json
  {
    "status": "success",
    "total_count": 42,
    "tweets": [
      {
        "id": "1234567890123456789",
        "username": "elonmusk",
        "text": "AI is the future of Tesla! 🚗 #AI #Tesla",
        "created_at": "2023-06-15T12:00:00Z",
        "retweet_count": 1500,
        "like_count": 5000
      },
      ...
    ]
  }
  ```

## 補充說明
- **實現建議**：
  - **數據庫設計**：
    - 使用PostgreSQL的JSONB字段（`tweets.metadata`）存儲額外推文信息（如媒體鏈接），提升靈活性。
    - 設置外鍵約束（`tweets.query_id` -> `query_log.query_id`），確保數據完整性。
    - 實現索引：`CREATE INDEX idx_tweets_username ON tweets(username);` 和 `CREATE INDEX idx_tweets_created_at ON tweets(created_at);`。
  - **持久化邏輯**：
    - 使用ORM（如Sequelize）處理批量插入，減少SQL拼接風險。
    - 實現事務（`BEGIN; INSERT; COMMIT;`），確保`query_log`和`tweets`同步。
    - 異常處理：若數據庫寫入失敗，回滾事務，返回錯誤響應。
  - **緩存與數據庫交互**：
    - 優先查Redis緩存（key格式同原需求），若命中則跳過API，直接從數據庫讀。
    - 數據庫查詢使用`SELECT ... LIMIT 100 OFFSET ?`實現分頁。
  - **API端點**：
    - 新增`/tweets/stored`（GET）：查詢歷史推文，支持`query_id`或`username`參數。
    - 更新`/tweets`（POST）：查詢並持久化，新增`query_id`返回值。
- **參考資料**：
  - PostgreSQL文檔（postgresql.org）：JSONB和分區表。
  - Twitter/X API v2文檔（developer.x.com）。
  - Sequelize文檔（sequelize.org）：批量插入和事務。
- **驗收標準**：
  - 輸入有效用戶名和關鍵詞，2秒內返回並存入數據庫。
  - 數據庫查詢（`/tweets/stored`）<0.5秒返回歷史推文。
  - 批量插入100條推文<0.2秒，無數據丟失。
  - 無效輸入返回清晰錯誤，數據庫無髒數據。
  - 事務失敗時回滾，查詢日誌和推文表保持一致。

## 下一步？
這版需求規範加了數據庫持久化，夠不夠清晰？想再加啥功能（比如數據分析報表）或改進某塊（比如NoSQL支持）？快說說，我繼續幫你打磨！

---


## TWEET-PULLER & STORAGE KIT

**(📦 包裝內含 - 概念性):**
*   需求規範 (📜)
*   數據庫設計圖 (💾📄)
*   流程圖示 (➡️🔄)

**(🛠️ 所需工具 - 不包含在包裝內):**
*   用戶名或ID (@👤 / 🔢)
*   Twitter/X API 認證密鑰 (🔒🔑)
*   電腦/伺服器 (💻/☁️)
*   數據庫系統 (🐘💾 / 🐬💾)
*   一些程序知識 (🐍🔧)
*   耐心 (🧘)

---

**步驟 1: 準備您的「零件」 (收集輸入)**

**(圖示: 一個人形圖示 (👤) 指向一堆小圖標)**

*   找到 用戶名 (@👤) **或** 用戶ID (🔢)
*   **(可選)** 找到 關鍵詞 (🔑)
*   **(可選)** 找到 日期範圍 (📅➡️📅)
*   **(可選)** 決定 最大數量 (🔢 max 1000)
*   找到您的 API 密鑰 (🔒🔑)

**(行動):**
*   將這些信息整理好。 (📦✅)
*   **警告**: 輸入信息不要包含奇怪符號。 (⚠️ 🚫 < >)

---

**步驟 2: 連接至「主供應商」 (呼叫 API)**

**(圖示: 您的電腦 (💻) 用一條線 (🔌) 連接到一個 Twitter/X 鳥標誌 (🐦X))**

*   使用 API 密鑰 (🔒🔑) 進行連接。
*   向供應商請求推文「零件包」。 (🙏 📦🐦)

**(行動):**
*   編寫代碼進行連接和請求。 (🐍✍️)

**(⚠️ 注意):**
*   供應商在短時間內只能提供有限數量的「零件包」。 (⚠️ 🐦X 450 / 15分鐘)
*   如果連接失敗，稍後重試。 (🔄♻️)
*   可以先檢查「本地倉庫」（緩存）看是否有現成的「零件包」。 (📦💨❓➡️✅跳到步驟 5)

---

**步驟 3: 接收推文「零件包」 (獲取數據)**

**(圖示: 從 Twitter/X 鳥標誌 (🐦X) 流出一個列表圖標 (📜) 包含小鳥圖標 (🐦))**

*   您將收到一個包含推文「零件」的列表。 (📜🐦)
*   每個推文「零件」都有自己的ID、內容、時間等標籤。 (ID, 文本, 📅, 轉發數, 點贊數...)

**(行動):**
*   檢查接收到的「零件包」是否完整。 (🔍✅)

---

**步驟 4: 組裝並儲存 (數據庫持久化)**

**(圖示: 📜🐦 圖標移動到一個數據庫圖標 (💾))**

*   您的任務是將這些「零件」安全地放入「長期儲存倉庫」。 (💾)
*   您需要兩個儲存區（表格）：
    *   **推文儲存區** (📁 tweets): 存放每個推文「零件」。
    *   **請求日誌** (📁 query_log): 記錄每次獲取「零件包」的過程。

**(行動):**
*   每次請求後，先在「請求日誌」中記錄您的請求信息。 (✍️ 📁 query_log)
*   將接收到的推文「零件」放入「推文儲存區」。 (📥 📁 tweets)
*   **重要**: 如果「儲存區」中已有這個「零件」(ID相同)，只需更新它的狀態標籤（如點贊數）。 (🔄👍) 不要放重複的「零件」。
*   最好一次放入多個「零件」，效率更高。 (📦📦📦👍)

**(參照圖示):**
*   儲存區結構圖示 (💾📄)

**(⚠️ 注意):**
*   選擇正確的儲存倉庫類型。 (✅🐘💾 或 ✅🐬💾) (🚫 其他奇怪類型)
*   請確保記錄和儲存過程同步完成，避免混亂。 (✅🔄❌)
*   這些「零件」只保存約 2 年。 (⚠️ 💾📅 - 2 年)
*   訪問儲存區需要特定權限。 (🔒👤)

---

**步驟 5: 提供最終「組裝結果」 (輸出給用戶)**

**(圖示: 從您的電腦 (💻) 流出一個顯示列表的屏幕 (✅📜🐦))**

*   向請求者展示獲取的推文列表和結果狀態。 (✅ / ❌ + 📜🐦)
*   同時給出一個本次組裝/儲存操作的唯一標識。 (🆔 例如: e8e6-...)

**(行動):**
*   根據內部流程，將結果打包成易讀的格式（如JSON）。 (📦 json)
*   **重要**: 告知請求者這個唯一標識 (🆔)，以便他們下次直接查詢「長期儲存倉庫」。

---

**步驟 6: 從「長期儲存倉庫」中直接獲取 (查詢數據庫)**

**(圖示: 一個人形圖示 (👤) 直接連接到數據庫圖標 (💾))**

*   下次如果您想再次查看已儲存的推文，可以直接訪問「長期儲存倉庫」。 (💾直接訪問)

**(行動):**
*   使用之前記錄的唯一標識 (🆔) 或用戶名 (@👤) 進行查詢。
*   直接從儲存區獲取列表。 (💾➡️📜🐦)

**(性能提示):**
*   從儲存區獲取速度更快。 (⏱️ < 0.5 秒)

---

**(總結 & 維護提示):**

**(圖示: 一個完整的系統圖標 (💻🔌🐦X💾) 和一些維護工具圖標)**

*   定期檢查連接和儲存區狀態。 (🔍✅)
*   定期整理儲存區（根據兩年期限）。 (🧹💾)
*   記錄任何組裝失敗的原因。 (✍️ 🐛❌)

---

**(完成! 🎉 您已成功組裝 TWEET-PULLER & STORAGE KIT!)**

**(圖示: 整個系統圖標閃閃發光，旁邊是個笑臉 😊)**

**(如有任何零件缺失或組裝困難，請查閱詳細需求文檔或尋求技術支持。)**