# Code Verbalization Prompt 库

> **核心理念**：用"代码白话化"思维，在 Prompt 中嵌入**Why → Trade-offs → How（非技术复述）**的完整设计思维链
> 
> 适用于：系统设计、代码审查、文档编写、知识沉淀

---

## 📁 目录结构

```
prompts/code_verbalization/
├── 01_ARCHITECTURE/
│   ├── system_design_verbalize/
│   │   ├── v1.0_20250915.md
│   │   └── v2.1_current.md          ⭐ 完整示例
│   └── README.md
│
├── 02_CODE_QUALITY/
│   ├── code_intent_extractor/
│   │   └── v1.2_current.md          ⭐ 完整示例
│   ├── design_pattern_detector/
│   │   └── v1.1_current.md
│   └── README.md
│
├── 03_DOCUMENTATION/
│   ├── why_driven_docstring/
│   │   └── v1.3_current.md
│   ├── non_tech_explanation/
│   │   └── v1.1_current.md
│   └── README.md
│
└── FRAMEWORK.md                     # 框架指南
```

---

# 实例 1：系统设计白话化

## 完整 Prompt（可直接复用）

```markdown
# 系统设计白话化器

**元数据** | v2.1 | 2025-12-14 | Claude/GPT-4 | #架构 #Why分析 #权衡

---

## 核心框架：4 层递进式分析

### 层 1：What（表面意思）
这个系统要做什么？核心目标和关键约束是什么？

### 层 2：Why（设计动机）★★★核心
为什么选这个架构而不是其他方案？背后的工程观是什么？

### 层 3：Trade-offs（取舍）
选择这个方案获得了什么，付出了什么代价？量化分析。

### 层 4：Non-tech（非技术复述）
用比喻和数字，讲给 CEO/CFO/产品经理听。

---

## 角色定位

你是资深系统架构师（Google 级别），擅长将复杂架构决策转化为清晰的商业语言。你的能力：

✓ 看穿设计本质：不讲"微服务是什么"，讲"为什么微服务能解决 X 问题"
✓ 量化权衡：用数据说话（ROI、延迟、成本）
✓ 跨界沟通：既能和工程师讨论实现细节，也能和管理层讨论商业价值

---

## 输入格式

```

【系统名】：[e.g., 电商推荐系统] 【架构现状】：[粘贴架构图、组件列表或文字描述] 【关键决策】：[e.g., 为什么用微服务而非单体？] 【受众】：[技术 / 管理 / 投资方]

````

---

## 输出结构

### **第 1 层：What - 系统意图**

```markdown
## 系统概览

**业务目标**：
- 一句话核心目标
- 关键成功指标 (KPI)

**技术约束**：
- 性能目标（延迟、吞吐）
- 可靠性目标（uptime）
- 成本约束

**核心组件**：
1. 组件 A：[职责] → [为什么需要]
2. 组件 B：[职责] → [为什么需要]
3. 组件 C：[职责] → [为什么需要]
````

**示例：**

```
**业务目标**：为 100M DAU 提供 < 200ms 的个性化推荐
**性能约束**：P99 延迟 500ms，99.95% uptime
**核心组件**：
1. 推荐引擎：计算用户推荐 → 快速迭代是核心竞争力
2. 特征存储：汇聚用户行为特征 → 支撑机器学习
3. 结果缓存：加速热点数据查询 → 降低成本和延迟
```

---

### **第 2 层：Why - 设计动机（★★★最重要）**

#### 对每个关键决策，用"三层法"分析

```markdown
## 核心决策 1：为什么选择微服务架构？

### 层 A：问题是什么？（背景）
- 当前单体的痛点是什么？
- 用数据说明痛点的严重性

**示例**：
```

单体架构下的困境：

- 推荐算法改进周期：2 周（一个完整发版周期）
- 每个算法改进都需要等待完整回归测试，2 周才能上线
- 结果：竞对日迭代，我们双周迭代，增长被压制

数据支撑：

- 推荐精度每提升 1%，转化率 +0.8%
- 快 1 周上线新算法，多赚 $100M × 0.8% = $800K
- 慢 = 直接的商业损失

```

### 层 B：为什么这个方案能解决？（动机）
- 这个架构的本质价值是什么？
- 用一句话概括核心设计哲学

**示例**：
```

微服务的本质：用架构映射组织结构

微服务的核心收益：独立演进

具体体现： ✓ 推荐团队可以独立部署推荐服务（不等待其他团队） ✓ 基础设施团队可以独立优化缓存层 ✓ 数据团队可以独立更新特征计算

结果：各团队并行工作，整体迭代速度 3x

Google 的工程观：在高速增长期，组织协作效率比单点技术优化更重要

```

### 层 C：为什么现在做？（时机）
- 这个决策的前置条件是什么？
- 什么时候不应该做微服务？

**示例**：
```

做微服务的前置条件： ✓ 团队规模 > 10 人（足够支撑多个服务） ✓ 产品迭代速度 > 周级（单体成为瓶颈） ✓ 基础设施成熟（有 K8s、服务网格等）

什么时候不应该做： ✗ 初创期（< 5 人团队）：沟通开销不值得 ✗ 产品已稳定：维护成本 > 迭代收益 ✗ 没有运维团队：运维复杂度会杀死你

这个公司现状：40 人团队，月迭代速度，已有运维基础 → 是做微服务的时机

````

---

## 第 3 层：Trade-offs - 量化权衡

### 权衡矩阵

| 架构选择 | 获得 | 失去 | 量化指标 | 适用场景 |
|---------|-----|-----|---------|---------|
| **微服务** | 迭代快 | 延迟↑ 复杂度↑ | 延迟 +50ms、成本 +$1M/年、迭代 3x 快 | 大团队、快速产品 |
| **单体** | 性能优 | 演进受阻 | 延迟最优、部署 10 分钟 | 小团队、稳定产品 |
| **三层缓存** | 成本最优 | 一致性复杂 | 平均延迟 < 10ms、成本 -60% | 热点数据明显 |
| **异步队列** | 故障隔离 | 数据延迟 | 可用性 99.95% → 99.99%、延迟 +3s | 非关键路径 |

### 具体权衡分析

```markdown
## 权衡分析：微服务 vs 单体

### 收益侧
````

✓ 推荐引擎迭代周期：2 周 → 1 天（14x 加速） → 每季度多试验 50+ 种算法，而不是 6 种 → 推荐精度每季度 +3%（单体情况下 +1%） → 年度 GMV 增长多 $50M

✓ 独立扩展：热点服务单独 scale → 推荐服务在流量峰值可扩展 10x（支付服务 2x） → 避免过度配置（省成本）

✓ 故障隔离 → 推荐故障 != 支付故障 → 系统可用性 99.9% → 99.95%（年宕机从 9 小时 → 4 小时）

```

### 成本侧
```

✗ 基础设施成本：$1M/年

- 原因：从 5 台单体服务器 → 50 台微服务（通信、监控开销）

✗ 网络延迟：0.1ms → 10ms（100x） → 这重要吗？取决于用户是否能感知 → 推荐服务 200ms → 250ms，用户无感知 ✓ → 但累加所有服务，总延迟可能 500ms → 1s ✗（用户有感知） → 需要用缓存抵消（额外复杂度）

✗ 运维复杂度：监控 1 个应用 → 20 个服务 + 交互 → 需要学 Kubernetes、服务网格、链路追踪 → 新工程师入职成本 +3 个月

✗ 调试困难：单进程调试 → 跨服务调试 → 排查问题从几分钟 → 几小时

````

### ROI 计算

```markdown
### 3 年 ROI 分析（Google 视角）

**假设条件**：
- 年营收：$100M
- 推荐系统贡献率：5%（$5M）
- 微服务额外成本：$1M/年
- 产品迭代周期：从 2 周 → 1 天

**年度效益**：
1. 推荐精度提升：
   - 单体：12 次迭代/年，每次 +1% → 总 +12%（假设）
   - 微服务：260 次迭代/年，但边际效应递减，总 +18%（保守）
   - 额外收益：($5M × 6% 增量) = $300K

2. 故障减少：
   - 宕机从 9 小时/年 → 4 小时/年
   - 每小时宕机损失 $50K → 节省 $250K

3. 团队生产力：
   - 工程师不再等待发版，生产力 +15% → 节省 1 人工资 $300K

**年度成本**：
- 基础设施：$1M
- 新技术学习：$200K（3 人时间成本）

**年度 ROI**：($300K + $250K + $300K - $1M - $200K) / $1.2M = **-8%**（第 1 年亏）

**3 年累积 ROI**：($850K × 3 - $1.2M × 3) / ($1.2M × 3) = **-17%**

→ **结论**：从纯 ROI 看，微服务不值得！

**但重新考虑隐形价值**：
- 快速迭代能力 = 竞争力（很难量化）
- 人才吸引（优秀工程师喜欢现代架构）
- 风险抵消（单体宕机影响 100%，微服务最多 10%）

→ **最终决策**：做微服务，因为短期 ROI 外的长期战略价值更重要
````

---

## 第 4 层：Non-tech - 非技术复述

### 给不同角色讲解

#### 给 CEO 讲：

```
"微服务的本质是：用架构换时间。

我们投资 $1M 的额外成本，换来推荐团队的迭代速度 14 倍。

在电商竞争中，谁的推荐算法更聪明，谁就赢。微服务让我们有时间每天试验新想法，竞对两周一次。

这就是我们能在推荐精度上超越竞对的原因。"
```

#### 给 CFO 讲（聚焦数字）：

```
"投入 $1M/年 基础设施，换来 $300K 的直接营收增长，加上 $250K 的宕机损失减少。

短期 ROI 是负的（-8%），但从 3 年看，投资这种'工程能力'是对的，因为：
- 电商行业利润率 5-10%，改进 1% 转化率等于打开一条新的营收线
- 微服务给了我们 14 倍的实验速度，统计上更容易找到那 1%
- 宕机每减少 1 小时都直接是利润

这不是成本，是'竞争力投资'。"
```

#### 给产品经理讲：

```
"微服务意味着：你的每个想法都能 24 小时内上线验证，而不用等两周。

比如你想试试'性别偏好'因素对推荐的影响 → 在微服务下，推荐团队 24 小时内就能 A/B 测试。

结果快速反馈给产品，可以立即迭代下一个想法。

在微服务前，这个周期是 2 周。这就是为什么大公司都用微服务——它让产品创新速度快 14 倍。"
```

#### 给新工程师讲（用比喻）：

```
**单体架构 = 一个大厨房**
- 优点：简单，一个老板决策快
- 缺点：菜品多了，各个岗位互相干扰。主厨想改菜谱得等其他人都配合

**微服务 = 连锁餐厅集团**
- 优点：北京店想上新菜，不用等上海店同意。各店独立试验
- 缺点：管理变复杂了。需要总部来协调供应链

我们的架构就是"连锁集团"模式。这样的代价就是——你需要学会分布式系统。
但收益是：你有机会试验，而不是被卡在大厨房里。
```

---

## 使用场景

|场景|用法|输出用途|
|---|---|---|
|**架构评审**|系统 Design Doc 前|确保团队理解"为什么"而非仅"是什么"|
|**新员工入职**|第 1 周技术介绍|快速理解系统决策逻辑，避免重复提问|
|**融资 Pitch**|技术可行性说明|向投资方解释"为什么这个架构能支撑增长"|
|**技术债务讨论**|是否重构的决策依据|量化现状架构的 ROI，决策升级时机|

---

## 版本演进

### v2.1 ⭐ 当前

- 新增"三层法"（问题 → 方案 → 时机）分析 Why
- 新增 3 年 ROI 计算示例
- 优化非技术复述的多角色输出

### v2.0 (2025-11-20)

- 引入权衡矩阵（量化权衡）

### v1.0 (2025-09-15)

- 初版：基础架构白话化

---

## 失败案例

### 案例：权衡分析流于表面

**失败表现**：

```
"微服务的优点：解耦、独立扩展
微服务的缺点：复杂度高、学习曲线陡"
```

**问题**：谁都能说出这些，没有帮助决策

**改进**（v2.0）：

```
必须用数据量化：
- "复杂度高" → 具体高多少？
  答：监控 1 个应用 → 20 个应用，学习成本 +3 个月/工程师

- "独立扩展" → 实际能省多少钱？
  答：按需扩展推荐服务（10x）而非全部服务（3x），省 40% 基础设施成本

```

---

## 快速复用

1. **打开这个 Prompt**
2. **填入你的系统信息**：
    - 【系统名】、【架构现状】、【关键决策】
3. **粘贴到 Claude / GPT-4**
4. **获得完整分析**：What → Why → Trade-offs → Non-tech

````

---

# 实例 2：代码意图提取器（精简版）

## 完整 Prompt（可直接复用）

```markdown
# 代码意图提取器

**元数据** | v1.2 | 2025-12-14 | Claude/GPT-4 | #代码审查 #Why分析

---

## 核心价值

**问题**：代码审查时，Reviewer 看不出"为什么这样写"，只能看"它做了什么"

**解决**：用"三层法"提取代码背后的设计意图

````

代码（What） ↓ 意图（Why）← ★ 关键：设计者的思考过程 ↓ 风险（Risk）

```

---

## 角色

你是资深 Code Reviewer，能从代码中看出：
- 这段代码解决了什么问题（Why）
- 为什么选择这个实现方式而不是其他（Trade-offs）
- 这样写有什么隐藏风险（Risk）

---

## 输入格式

```

【语言】：Python / Go / Java / ... 【代码】：[粘贴代码片段，通常 10-50 行] 【上下文】：[这段代码的业务背景]

```

---

## 输出结构（三层）

### 第 1 层：What（表面）

```

一句话说明这段代码做了什么。

```

**示例**：
```

这段代码根据用户年龄和购买金额，返回不同的折扣系数。

```

### 第 2 层：Why（设计意图）★★★核心

问三个问题：

#### a) 为什么需要这个逻辑？
- 业务背景是什么？
- 用数据证明这个需求的重要性

**示例**：
```

数据显示：

- 未成年用户（< 18）的转化率只有 2%（远低于成人 8%）
- 原因分析：未成年用户购买力低，不舍得花钱
- 解决方案：对未成年用户提供更激进的折扣，刺激转化

目标：

- 未成年用户转化率 2% → 5%（+150%）
- 成人用户保持 8%（不破坏已有的定价策略）

```

#### b) 为什么这些分界点（18, 100, 50）？

**示例**：
```

18 = 法律界定的成人年龄（不能随意改）

100 元的分界点（成人购买满 100 打折 10%）：

- 分析：90% 的成人用户单笔购买 < 100
- 决策：设置在 100 的目的是"筛选出高价值用户"并奖励他们
- 数据：满 100 的用户 LTV（终身价值）是普通用户的 3 倍
- 结论：只奖励高价值用户，成本最低

50 元的分界点（未成年购买满 50 打折 5%）：

- 原因：未成年用户的"消费能力天花板"大约就在 50 元
- 策略：在他们承受范围内尽早刺激转化

```

#### c) 为什么不用其他方案？

**示例**：
```

方案 A（当前）：基于年龄的硬分界 ✓ 简单，容易理解 ✗ 粗糙，没有考虑"真实消费力"（一个富裕的 17 岁 vs 贫困的 18 岁）

方案 B：基于历史消费金额 ✓ 精准（用历史消费预测行为） ✗ 冷启动问题（新用户没有历史数据） ✗ 复杂度高（需要查询历史数据）

方案 C：基于地理位置的购买力模型 ✓ 最精准 ✗ 太复杂，当前还用不起

决策理由： 在"精准度"和"简单性"的权衡中，现在选择方案 A（年龄分界） 因为：未成年用户量还不够大，投资复杂方案不值

但在 "未成年用户 > 20% 后"，考虑升级到方案 B（历史消费）

````

### 第 3 层：Risk（风险）

```markdown
### 这样写的风险是什么？

**风险 1：转账年龄作为唯一标准**
- 风险：18 岁官方生日时，折扣突然从 5% → 10%
- 后果：用户可能感到突兀（体验不连贯）
- 缓解：考虑加入"过渡"逻辑（18-20 岁用 7%，平滑过渡）

**风险 2：没有考虑边界情况**
- 年龄为 null？消费金额为 0？
- 当前代码会返回 0（默认不打折）
- 是否合理？取决于业务需求
  - 如果是"无效数据返回 0"→ ✓ 合理
  - 如果应该"报错 alert"→ ✗ 有 bug

**风险 3：没有预留扩展空间**
- 现在的条件是"年龄 + 金额"
- 如果未来要加"VIP 等级"或"地理位置"呢？
- 当前写法会变成 nested if 地狱

改进建议：
```python
# 当前（难以维护）
if age >= 18 and amount > 100:
    return 0.1
elif age < 18 and amount > 50:
    return 0.05

# 建议（易于维护）
DISCOUNT_RULES = [
    Rule(condition={'age': '>=18', 'amount': '>100'}, discount=0.1),
    Rule(condition={'age': '<18', 'amount': '>50'}, discount=0.05),
]
return apply_rules(DISCOUNT_RULES, user)
````

```

---

## 使用场景

| 场景 | 用法 |
|------|-----|
| **代码审查** | 当 Reviewer 看不懂"为什么这样写"时 |
| **新人 Onboarding** | 快速理解已有代码的设计意图 |
| **重构论证** | 确定改进方向之前，先理解现有设计的原因 |
| **知识沉淀** | 将代码决策记录为文档 |

---

## 版本演进

### v1.2 ⭐ 当前
- 新增"为什么不用其他方案"对比分析
- 新增具体风险案例和改进建议

### v1.1 (2025-11-15)
- 支持 Python/Go/Java 三种语言

### v1.0 (2025-10-01)
- 初版

---

## 快速复用

1. 复制上面的 Prompt
2. 粘贴代码片段
3. 回答三个问题：Why / Why not / Risk
```

---

## 🎓 框架总结：Code Verbalization 的 4 个关键问题

|层级|问题|作用|示例|
|---|---|---|---|
|**What**|这段代码/架构做了什么？|确保理解表面意思|"微服务让推荐独立部署"|
|**Why**|为什么这样做而不是那样？|★★★ 核心：理解设计者的思考|"为什么微服务？因为需要快速迭代推荐算法"|
|**Trade-offs**|获得了什么，失去了什么？|量化决策，避免盲目选择|"获得：迭代快 14x；失去：延迟 +50ms、成本 +$1M/年"|
|**Non-tech**|用小学生能懂的话讲|跨界沟通，形成共识|"就像餐厅从一个大厨房变成连锁集团，灵活但复杂"|

---

## 💾 在 Git 中使用

### 目录结构示例

```
prompts/code_verbalization/
│
├── 01_ARCHITECTURE/
│   ├── system_design_verbalize/
│   │   ├── v1.0_20250915.md
│   │   ├── v2.0_20251120.md
│   │   └── v2.1_current.md ← 每次更新后改这个名字
│   │
│   └── README.md
│       # 该分类下所有 Prompt 的索引和使用指南
│
├── 02_CODE_QUALITY/
│   ├── code_intent_extractor/
│   │   ├── v1.0_20251001.md
│   │   ├── v1.1_20251115.md
│   │   └── v1.2_current.md
│   │
│   └── README.md
│
└── INDEX.md ← 全局快速查询表
    # 按场景 / 应用工具分类
```

### Git 工作流

```bash
# 新增 Prompt
git add prompts/02_CODE_QUALITY/code_intent_extractor/v1.2_current.md
git commit -m "✨ code_intent_extractor v1.2：新增'方案对比'分析"

# 查看演进历史
git log --oneline prompts/02_CODE_QUALITY/code_intent_extractor/

# 对比两个版本的差异
git diff v1.1_current.md v1.2_current.md
```

---

## 🚀 今天就开始

### Step 1：保存两个核心 Prompt（10 分钟）

```
prompts/
├── 01_ARCHITECTURE/
│   └── system_design_verbalize/
│       └── v1.0_current.md        ← 复制"实例 1"的正文
└── 02_CODE_QUALITY/
    └── code_intent_extractor/
        └── v1.0_current.md        ← 复制"实例 2"的正文
```

### Step 2：在 Git 中初始化（5 分钟）

```bash
cd prompts
git init
git add .
git commit -m "🎯 初始化 Code Verbalization Prompt 库"
```

### Step 3：日常使用（每次 3 分钟）

**使用时**：

```
打开 v1.0_current.md
复制正文内容 → 粘贴到 Claude / GPT-4
输入你的系统/代码信息 → 获得完整分析（What → Why → Trade-offs → Non-tech）
```

### Step 4：迭代优化（月度）

遇到输出不满意的情况：

```bash
# 复制当前版本为新版本
cp v1.0_current.md v1.1_20251220.md

# 在 v1.1 中修改 Prompt
# 比如：加强"Trade-offs 量化"部分

# 对比测试
# 用同一个案例跑 v1.0 和 v1.1，看效果

# 满意后重命名
mv v1.1_20251220.md v1.1_current.md

# 提交到 Git
git add .
git commit -m "📈 code_intent_extractor v1.1：强化 Trade-offs 量化分析"
```

---

## 📊 效果示例：从"表面理解"到"深度理解"

### ❌ 低质量代码审查（没用 Code Verbalization）

```
Reviewer：为什么这里用 if-else 而不是 switch？

Author：因为条件比较复杂...

Reviewer：嗯，看起来没问题，approve
```

→ 评审深度：30%，信息交流：0%，收获：0%

---

### ✅ 高质量代码审查（用 Code Verbalization）

```
Reviewer 用"code_intent_extractor"分析代码：

"这段代码的 Why 是：
- 未成年用户（<18）转化率低（2% vs 8%）
- 策略是'激进折扣刺激转化'而不是'培养品牌忠诚度'
- 所以这些分界点（18, 100, 50）是有数据支撑的

但我看到的风险：
- 18 岁官方生日时折扣突变（体验不连贯）
- 建议加入过渡逻辑"

Author：确实，我原来没想到这个。让我加个平滑过渡...
```

→ 评审深度：80%，信息交流：100%，收获：关键改进

---

## 🎯 核心要点回顾

你现在有的是一套**开发级别的 Prompt 管理体系**，核心特点：

✅ **不是"怎么用"而是"为什么这样设计"**

- 每个 Prompt 都清楚地说明 Why 和 Trade-offs
- 帮助团队理解设计思维，而非仅仅使用工具

✅ **极简无代码**

- 纯 Markdown，Git 天然版本控制
- 复制粘贴即用，不需要学编程

✅ **可复用于多个 AI 应用**

- 同一个 Prompt 兼容 Claude / GPT-4 / Gemini
- 每个版本的改进历史完整保留

✅ **支持深度迭代**

- 记录每次 Prompt 改进的动机
- 量化效果（理解深度 +30%、代码审查质量 ⭐⭐⭐⭐）
- 支持 A/B 测试（对比两个版本）

✅ **Google 级工程思维**

- 强调"为什么"优于"是什么"
- 量化 Trade-offs 而非感性讨论
- 非技术复述确保跨界理解

---

## 📚 下一步扩展方向

当上面两个 Prompt 用熟了，可以继承这个框架创建：

1. **`03_DOCUMENTATION/why_driven_docstring`**
    
    - 将"为什么这个函数要这样设计"写进 docstring
2. **`04_LEARNING_SYNTHESIS/concept_deep_dive`**
    
    - 从一个技术概念出发，用 Why → Trade-offs → Non-tech 深度讲解
3. **Team 共享库**
    
    - 最优秀的 Prompt 上传到内部 GitLab
    - 建立 Code Verbalization 的最佳实践库

---

## 🔗 与之前的 Markdown 目录结构整合

这份 Code Verbalization 库应该放在你的整体 Prompt 管理系统中：

```
prompts/
├── 00_META/
│   └── FRAMEWORK.md ← 新增：Code Verbalization 框架指南
│
├── 01_DOCUMENTATION/
│   ├── doc_depth_analyzer/
│   │   └── v2.1_current.md
│   └── why_driven_docstring/           ← 新方向
│       └── v1.0_current.md
│
├── code_verbalization/                  ← 本库
│   ├── 01_ARCHITECTURE/
│   │   └── system_design_verbalize/
│   │       └── v2.1_current.md
│   ├── 02_CODE_QUALITY/
│   │   └── code_intent_extractor/
│   │       └── v1.2_current.md
│   └── ...
│
└── ...其他分类
```

---

**现在你拥有的是一套完整的、有版本管理的、可深度迭代的、企业级的 Prompt 管理系统。** 🚀