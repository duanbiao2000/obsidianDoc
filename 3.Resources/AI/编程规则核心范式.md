---
view-count: 7
---

★ 模块Why Header→统一5行说明  
★ 重大决策→轻量ADR记录  
★ Prompt结构化→YAML/JSON模板  

★ 所有外部行为→统一Tool接口  
★ Agent拆分→Planner/Executor/Critic  
△ 接口优先→先定义types再实现  

★ 每个Agent/Prompt→Eval套件必备  
★ 日志结构化→统一schema打点  
△ Tool需支持mock→离线测试方便  

★ 关键数据集→schema+版本+pipeline  
★ 跨服务数据→Data Contract强校验  
△ 上下文附带数据新鲜度/置信度/来源  

★ PR模板→Why+接口影响+测试/Eval+数据源  
★ 周度复盘→失败样例→ADR+Prompt改+Eval增  
★ 独立仓库→Prompt&Agent模式样例库

## ★ LLM工程化四规则落地

- ★ 规则1→Why Header+ADR+Prompt Schema  
- ★ 规则2→Tool接口+Agent微组件  
- ★ 规则3→Eval套件+结构化日志  
- ★ 规则4→数据版本化+数据契约  
- ❗ 从原则到实施的具体形式  

---

## ★ 规则1落地：上下文可消费化

### Why Header强制模板

```
Purpose: 做什么
Why now: 为什么现在做
Key tradeoffs: 核心权衡
Invariants: 不变式约束
Owner: 责任团队
```

- ★ 5行固定结构→AI可批量抽取  
- ★ PR模板+lint规则→无header不合并  
- △ 前瞻：自动生成系统设计知识图谱  

### ADR轻量化

- ★ 模板：Context→Decision→Alternatives→Consequences  
- ★ 存放：docs/adr/NNN-title.md  
- △ PR必须链接对应ADR  
- ❗ 不搞长文档→精简可执行  

### Prompt工件化

```yaml
name: classify_support_ticket
intent: route tickets to correct queue
constraints:
  - never guess product if confidence < 0.6
failure_modes:
  - hallucinated product names
```

- ★ Prompt=结构化数据 vs 散落字符串  
- △ 统一schema→批量重构可能  
- △ 注释化约束+失败模式  

---

## ★ 规则2落地：接口抽象化

### 统一Tool接口

```ts
interface Tool<Input, Output> {
  name: string;
  description: string;
  schema: ZodSchema<Input>;
  execute(input: Input, ctx: ToolContext): Promise<Output>;
}
```

- ★ 所有外部行为→Tool实例  
- ★ Agent只和Tool打交道→不认识具体实现  
- △ AI理解Tool列表+schema→自动规划调用  
- ❗ 避免大orchestrator+if/else一坨  

### Agent微组件拆分

- ★ Planner→产出Tool序列+调用计划  
- ★ Executor→执行LLM+Tool调用  
- ★ Critic/Reflector→评估+重试决策  
- △ 每个独立模块→接口稳定内部可替换  
- △ 前瞻：AI自动生成实现填充  

### 接口优先开发流程

- ★ PR先写接口定义→Review边界清晰度  
- ★ 接口稳定后→填实现+测试  
- △ 为AI生成实现预留标准接口  

---

## ★ 规则3落地：Eval+可观测

### Eval套件一等公民

- ★ 每个Agent/Prompt→必有eval case集  
- ★ 结构化存储：
  ```json
  {
    "input": {...},
    "expected_behavior": {...},
    "score_fn": "..."
  }
  ```
- △ 本地→快速跑小子集  
- △ CI→全量/抽样关键case  
- ❗ 没Evals不算上线  

### 日志结构化schema

```json
{
  "request_id": "...",
  "agent": "support_router",
  "step": "tool_call",
  "prompt_name": "classify_issue",
  "tool": "lookup_customer_profile",
  "input": {...},
  "output": {...},
  "latency_ms": 120,
  "error": null
}
```

- ★ 统一logger打点→强制所有agent步骤  
- △ 按agent/step聚类→失败模式分析  
- △ 为AI诊断工具→提供训练数据  

### 测试性内嵌设计

- ★ Tool接口→必须支持mock/fake实现  
- ★ Agent逻辑与LLM调用分离  
- △ 测试时→固定响应mock LLM  
- △ 离线测试Agent逻辑→无需真实调用  

---

## ★ 规则4落地：数据系统化

### 数据版本化必需品

- ★ 关键数据集→schema+版本号+生成管道  
- ★ 新实验=新数据版本+新代码版本  
- △ JSON Schema/Protobuf/BigQuery schema  
- △ 可回溯→重跑历史实验  

### 数据契约化

- ★ 跨团队/服务数据交换→明确契约  
- ★ 定义：字段含义+可空性+值域范围  
- △ 入口强校验→Zod/JSON Schema  
- ❗ 脏数据→LLM诡异行为根源  

### 数据质量信号显式传递

- ★ 上下文包含：
  - 数据新鲜度(小时/天)  
  - 置信度/缺失率  
  - 来源标注  
- △ Agent结合质量信号→更稳健推理  
- △ 数据太旧→建议人工确认  

---

## ★ 团队流程嵌入机制

### PR模板升级(强制项)

- ★ Why Header→规则1  
- ★ 接口影响分析→规则2  
- ★ 测试/Evals链接→规则3  
- ★ 数据源+schema→规则4  
- ❗ 从墙上价值观→可执行流程  

### 每周Agent事后复盘

- ★ 只看：失败样例按日志聚合  
- ★ 分类：Prompt设计/工具边界/数据问题  
- ★ 输出：
  - 1条ADR  
  - 1个Prompt模板改动  
  - 1个eval case新增  
- △ 小批量迭代→持续改进  

### Prompt & Agent Patterns仓库

- ★ 不放业务代码→只放模式  
- ★ 内容：
  - Prompt模板(intent+constraints+失败模式)  
  - Agent结构示例(Planner/Executor/Wrapper)  
  - 对应eval套件样例  
- △ 新成员起跑线  
- △ 未来AI工具参考库  

---

## △ 具体实施工具链

- △ Why Header→ESLint/TSDoc规则  
- △ ADR→Markdown模板+索引  
- △ Prompt Schema→YAML/JSON+验证器  
- △ Tool接口→Zod Schema定义  
- △ Eval套件→JSON cases+统一runner  
- △ 结构化日志→统一logger SDK  
- △ 数据版本→DVC/Git LFS/云存储  

---

## ★ 与前述架构模式类比

- ★ Why Header ≈ tRPC AppRouter类型导出(契约层)  
- ★ Tool接口 ≈ Shadcn组件接口标准化  
- ★ Agent微组件 ≈ RSC/Client Component分层  
- ★ Eval套件 ≈ 测试即规范思维  
- ★ 结构化日志 ≈ Web Vitals监控数据  
- △ 数据契约 ≈ API类型安全边界  
- △ Prompt Schema ≈ Copilot任务→模型映射  
- △ Pattern仓库 ≈ 知识库脊柱/神经结构  

---

## ★ LLM系统特有挑战

- ❗ 输出空间太大→人肉检查无效  
- ❗ 上下文丢失→后人只能猜  
- ❗ Prompt当字符串→批量重构不可能  
- ❗ 大orchestrator一坨→无人敢动  
- ❗ 脏数据指数级放大诡异行为  
- △ 非确定性→需Eval套件覆盖  
- △ 多模型多版本→需严格版本化  

---

## △ 可迁移工程模式

- △ 固定格式header→机器可解析文档  
- △ 接口优先→支持自动生成实现  
- △ 行为工件化→Prompt/Eval/Log schema化  
- △ 质量信号显式化→系统自诊断能力  
- △ 小批量复盘→持续模式提炼  
- △ Pattern仓库→跨项目复用加速  

---

## ★ 实施优先级建议

- ★ 第1周：PR模板+Why Header lint  
- ★ 第2周：Tool接口标准化+示例  
- ★ 第3周：结构化日志+统一logger  
- ★ 第4周：Eval套件模板+CI集成  
- △ 第2月：数据契约+版本化流程  
- △ 第3月：Pattern仓库建立  
- △ 持续：每周复盘机制  

---

## ❗ 核心反常识

- ❗ 文档≠Word→结构化schema才可消费  
- ❗ 测试≠单元测试→Eval套件更关键  
- ❗ 抽象≠性能损失→是AI可操作前提  
- ❗ 日志≠console.log→结构化才可分析  
- ❗ Prompt≠字符串→是可版本化工件  

---

## ★ 成功标志(6个月后)

- ★ 新成员看Why Header→理解模块<5分钟  
- ★ 改Prompt→自动跑Eval→CI自动阻断退化  
- ★ 失败case→按日志聚合→自动分类  
- ★ 新工具接入→遵循Tool接口→Agent自动识别  
- ★ 数据问题→质量信号预警→人工介入  
- △ Pattern仓库→成为团队首查资源  

---

## ★ 终极压缩

- ★ 规则1→Why/ADR/Schema固定格式  
- ★ 规则2→Tool接口+Agent微组件+接口优先  
- ★ 规则3→Eval一等公民+结构化日志+可mock  
- ★ 规则4→数据版本+契约+质量信号  
- ★ 流程嵌入→PR模板+周复盘+Pattern库  
- ❗ 为AI可消费→所有工件结构化  
- ★ LLM系统→输出空间大→Eval必需品