---
view-count: 9
---

# 系统架构核心笔记 (Core Architecture Notes)

## 模块 I：分布式消息 (EDA & Distributed Messaging)
**目标**：解耦、削峰、最终一致性。

### 1. 核心原语 (Primitives)
*   **EDA (Event-Driven)**: 发布/订阅模式 $\to$ 空间/时间解耦。
*   **CAP 定理**: 分布式铁律。P (分区容错) 必选 $\to$ 权衡 CP (强一致) 或 AP (高可用)。
    *   *生产实践*：99% 场景选 **AP + 最终一致性**。
*   **Saga 模式**: 长事务拆解 $\to$ T1...Tn (本地事务链) + C1...Cn (补偿链)。
*   **幂等性 (Idempotency)**: $f(f(x)) = f(x)$。
    *   *实现*：数据库唯一索引 (RequestID) / Redis SETNX。

### 2. 生产级配置 (Production Config)
*   **可靠性 (Reliability)**:
    *   `Producer`: `delivery_mode=PERSISTENT` (持久化)。
    *   `Consumer`: `auto_ack=False` (手动确认) + `prefetch_count=1` (QoS/背压)。
    *   `Failure`: `dead_letter_exchange` (死信队列) $\to$ 人工介入/延迟重试。

### 3. 陷阱 (Anti-Patterns)
*   **发送即成功**: 错误。$\to$ 必须监听 Broker 的 `Publisher Confirm`。
*   **强一致性执念**: 错误。$\to$ 接受短暂延迟，通过对账/补偿保证最终一致。
*   **队列作为数据库**: 错误。$\to$ 消息队列用于传输，不做复杂查询。

---

## 模块 II：MLOps (AI Production Pipeline)
**目标**：消除“实验室”与“生产环境”的熵增。

### 1. 生命周期 (Lifecycle)
*   **版本三位一体**: `Code` (Git) + `Data` (DVC) + `Model` (MLflow) = 可复现。
*   **漂移 (Drift)**:
    *   **Data Drift**: $P_{train}(X) \neq P_{serve}(X)$ (输入分布变了)。
    *   **Model Drift**: $P(Y|X)$ 衰减 (概念变了)。
    *   *对策*: 监控分布距离 (KL散度) $\to$ 触发自动重训管道。

### 2. 部署策略 (Deployment)
*   **架构**: Training Pipeline $\to$ Model Registry $\to$ Serving API (K8s).
*   **安全发布**:
    1.  **Shadow Mode**: 上线但不返回结果，仅对比新旧模型输出。
    2.  **Canary**: 1% 流量 $\to$ 逐步全量。
*   **监控**: 业务指标 (Conversion Rate) > 技术指标 (Latency) > 模型指标 (Accuracy)。

### 3. 陷阱 (Anti-Patterns)
*   **Training-Serving Skew**: 训练用批量特征，预测用实时特征。$\to$ 必须上 **Feature Store**。
*   **静态模型**: 假设世界不变。$\to$ 模型必须是**易腐品**，需定期刷新。

---

## 模块 III：高性能异步 (High-Perf Async)
**目标**：榨干单核 CPU 等待时间 (I/O Wait)。

### 1. 决策矩阵 (Decision Matrix)
| 场景 | 瓶颈 | 方案 | 关键词 |
| :--- | :--- | :--- | :--- |
| **HTTP/DB/Net** | I/O 等待 | **Asyncio** (协程) | `await`, `aiohttp`, EventLoop |
| **数据计算/ML** | CPU 计算 | **Multiprocessing** | `ProcessPoolExecutor`, GIL Bypass |
| **混合场景** | I/O + Legacy | **Async + ThreadPool** | `run_in_executor` |

### 2. 核心代码骨架 (Skeleton)
```python
# 黄金法则: 1. 永不阻塞EventLoop 2. 复用Session
async def main():
    # 连接池复用 (Critical)
    async with aiohttp.ClientSession() as session:
        tasks = [fetch(session, url) for url in urls]
        # 并发控制 (Scatter-Gather)
        results = await asyncio.gather(*tasks, return_exceptions=True)

# 异常防御
try:
    # 必须设置超时，防止僵尸任务
    await asyncio.wait_for(task, timeout=5.0)
except asyncio.TimeoutError:
    handle_timeout()
```

### 3. 陷阱 (Anti-Patterns)
*   **在 async 中 `time.sleep()`**: 致命。$\to$ 阻塞整个线程，必须用 `await asyncio.sleep()`。
*   **CPU 密集型用 async**: 无效。$\to$ 依然受 GIL 限制，必须用多进程。
*   **忽视背压**: 无限并发 $\to$ 内存爆炸/下游崩溃。$\to$ 用 `asyncio.Semaphore` 限制并发数。
