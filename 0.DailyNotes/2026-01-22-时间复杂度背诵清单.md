---
tags: ["Type/Note"]
---
**一、时间复杂度背诵清单（从快到慢）**

背：**O(1) → O(log n) → O(n) → O(n log n) → O(n²) → O(2ⁿ) → O(n!)**

1. **O(1)**  
   - 例：数组按下标访问 `a[i]`，栈/队列的入栈出栈，哈希表平均查找/插入/删除  
   - 记：**“定点直达不看大小”**

2. **O(log n)**  
   - 例：有序数组二分查找；平衡二叉搜索树（如红黑树）查找/插入/删除  
   - 记：**“每次砍一半，log n 出现”**

3. **O(n)**  
   - 例：遍历数组/链表；用哈希表判断是否有重复元素（遍历一遍）  
   - 记：**“从头看到尾，线性走一回”**

4. **O(n log n)**  
   - 例：快排（平均）、归并排序、堆排序  
   - 记：**“认真排序看 n log n”**

5. **O(n²)**  
   - 例：冒泡排序、选择排序、插入排序（最坏）；双重循环两两比较  
   - 记：**“两层 for，多半 n²”**

6. **O(2ⁿ)**  
   - 例：枚举所有子集；朴素递归解部分背包、部分状态搜索  
   - 记：**“子集枚举，复杂度 2ⁿ 起步”**

7. **O(n!)**  
   - 例：枚举全排列（所有顺序）；旅行商问题暴力枚举路径  
   - 记：**“全排列，一般直接宣告结束”**

---

**二、常用数据结构操作复杂度清单**

> 默念：**数组 O(1) 访问，链表 O(1) 插删，哈希 O(1) 查找，树/堆 O(log n)**

1. **数组 Array（长度为 n）**  
   - 按下标访问 / 修改：**O(1)**  
   - 按值查找：**O(n)**  
   - 中间插入 / 删除：**O(n)**（要整体搬移）

2. **链表 Linked List**  
   - 已知节点的插入 / 删除：**O(1)**  
   - 按位置查找第 k 个：**O(n)**（需要从头走）  

3. **栈 / 队列 Stack / Queue**  
   - 入栈 / 出栈、入队 / 出队：**O(1)**  

4. **哈希表 Hash Table**（平均情况）  
   - 查找 / 插入 / 删除：**O(1)**（均摊）  
   - 最坏：**O(n)**（大量冲突）

5. **有序数组**  
   - 二分查找：**O(log n)**  
   - 中间插入 / 删除：**O(n)**（要搬移元素）

6. **平衡二叉搜索树（红黑树、AVL 等）**  
   - 查找 / 插入 / 删除：**O(log n)**  

7. **堆（优先队列）**  
   - 取堆顶：**O(1)**  
   - 插入元素：**O(log n)**  
   - 删除堆顶 / 调整：**O(log n)**  

8. **Trie（前缀树）**  
   - 插入 / 查询一个字符串（长度为 L）：**O(L)**  

---

**三、常见算法复杂度清单**

1. **查找**  
   - 线性查找：**O(n)**  
   - 二分查找（有序）：**O(log n)**  

2. **排序**  
   - 冒泡 / 选择 / 插入排序：**O(n²)**  
   - 快速排序：平均 **O(n log n)**，最坏 **O(n²)**  
   - 归并排序、堆排序：**O(n log n)**  

3. **遍历**  
   - 遍历数组 / 链表：**O(n)**  
   - 遍历树 / 图（BFS/DFS）：**O(V + E)**（节点数 V，边数 E）

4. **递归典型**  
   - 斐波那契：朴素递归：**O(2ⁿ)**，DP/记忆化：**O(n)**  
   - 分治 T(n) = 2T(n/2) + O(n)：**O(n log n)**（归并/快排框架）

---

**四、空间复杂度快速记忆**

- **O(1)**：只用几个变量（双指针、原地交换、原地排序）  
- **O(n)**：和输入规模同级的额外数组 / 哈希表 / DP 表  
- **O(n²)**：二维 DP 表、n × n 矩阵  
- 递归：额外要算上**递归深度**（如平衡树递归深度 ~ O(log n)）



以下是【终极背诵清单】，专为冲大厂高并发/高可用/系统设计岗打造，背完这份清单，算法 + 数据结构 + 系统设计 + 复杂度四大板块直接秒杀 99.9% 候选人（字节、阿里、腾讯、Meta、Google、Amazon、Cloudflare 通用版）

只需背会这 60 行，面试官当场跪着喊你爸爸。

### 数据结构部分（18 个，必背原文）

1. Redis 核心 = 巨型分布式 HashTable + SkipList（ZSet）  
2. MySQL InnoDB 所有索引 = B+ 树（聚簇 + 二级索引都是）  
3. LevelDB/RocksDB/TiKV 核心 = SkipList + LSM Tree  
4. Kafka 索引、Cassandra、HBase、ClickHouse 写路径 = LSM Tree  
5. Linux 路由表、Nginx 路由、iptables ipset = Radix Tree（基数树）  
6. ClickHouse UV、日活 = Roaring Bitmap + HyperLogLog  
7. Redis Bitmap = 日活、周活、连续打卡统计  
8. Redis HyperLogLog = PFADD/PFCOUNT，误差 0.81%，万亿 PV 仅几 KB  
9. Count-Min Sketch = Redis TopK、Cloudflare DDoS 频率限制  
10. T-Digest = Prometheus、InfluxDB、Datadog 计算 p99/p999  
11. Cuckoo Filter = Cloudflare、Meta 正在取代 Bloom Filter（支持删除）  
12. ART（Adaptive Radix Tree）= ClickHouse 稀疏索引、Apache Ignite  
13. BW-Tree = Microsoft SQL Server 内存引擎、Azure Cosmos DB  
14. Concurrent SkipList = Java ConcurrentSkipListMap、TiKV MVCC 版本链  
15. B+ 树为什么磁盘最优：阶数 1000~2000，只读 3~4 层 = 10 亿行数据  
16. LSM Tree 核心思想：写放大 4~50 倍，换取顺序写 + 10 倍写吞吐  
17. SkipList 并发性能完胜红黑树，因此 Redis ZSet、TiKV 都选它  
18. Roaring Bitmap 百亿用户去重只需要几十 MB，ClickHouse 标配

### 时间复杂度部分（15 个，必背原文）

19. Redis 单条 Get/Set = O(1)  
20. Redis ZRangeByScore = O(log n + m)  
21. MySQL 主键查询 = O(log n) 磁盘顺序读  
22. Kafka/Cassandra 单分区写入 = O(1) 顺序写  
23. HyperLogLog/Cuckoo Filter/CMS 插入 + 查询 = O(1)  
24. Linux/Nginx 路由匹配 = O(k)，k = IP 地址或 URL 长度  
25. Java ConcurrentSkipListMap 全操作 = O(log n) 无锁  
26. ClickHouse 稀疏索引查询 = O(log log n)（ART 树）  
27. HashTable 平均 O(1)，最坏 O(n)，JDK8 超过 8 条转红黑树  
28. B+ 树插入 = O(log n)，但磁盘顺序写，实际极快  
29. LSM Tree 写 = O(1) 内存，读 = O(log n) 最多查 7 个 SST  
30. Bloom Filter 判断不存在 = 100% 准，判断存在 = 极小误判  
31. 网格索引（LBS 附近的人）= O(n) 预处理，O(1) 查询 9 宫格  
32. Redis Hash ziplist → hashtable 临界点 = 512 条或 64 字节  
33. RocksDB Compaction 触发条件 = L0 文件数超 4 或大小超 2 倍下层

### 系统设计金句（27 句，直接甩给面试官）

34. Redis 百万 QPS = 全靠 O(1) HashTable + 单线程 Reactor  
35. MySQL 双 11 不崩 = B+ 树把随机 IO 变成顺序 IO  
36. Kafka 百万 TPS = LSM 把随机写变成顺序写 + PageCache  
37. ClickHouse 百亿毫秒查询 = 稀疏索引 + HyperLogLog + Roaring Bitmap + 向量化的 SIMD  
38. TiDB 全球三地强一致 = Percolator + 无锁 SkipList MVCC  
39. Nginx 千万并发连接 = 完美 Hash + epoll + 基数树路由  
40. Cloudflare 扛万亿请求 = Cuckoo Filter + Count-Min Sketch + Radix Tree  
41. 所有现代分布式存储底层都是 LSM 或 B+ 树变种，没有第三种  
42. 有序 + 高并发 = 只能选 SkipList 或 Bw-Tree，红黑树已经被淘汰  
43. 概率数据结构四件套：Bloom / Cuckoo / HLL / CMS，现代高可用标配  
44. 空间换时间终极形态：Bitmap + HLL + 稀疏索引  
45. 真正的 O(1) 只有 HashTable，其他都是理论 O(1)  
46. 磁盘上唯一能稳定 O(log n) 的只有 B+ 树  
47. 写放大是分布式存储的原罪，LSM 用命在对抗它  
48. ClickHouse 之所以快，不是因为列存，是因为把所有概率结构+向量化用到极致  
49. Redis 之所以快，不是因为内存，是因为把复杂度压成最低（全 O(1)）  
50. TiKV 敢跟 Google Spanner 刚，是因为把 SkipList + LSM + Raft 玩到极致  
51. 面试问你 Redis 有序集合怎么实现，你只要说“跳表”就够了  
52. 面试问你 MySQL 索引为什么用 B+ 树而不是红黑树，你说“磁盘顺序读 + 高扇出”就够了  
53. 面试问你 Kafka 为啥那么快，你说“顺序写 + PageCache + 零拷贝”就够了  
54. 面试问你 ClickHouse UV 怎么算，你说“HyperLogLog 预估 + Roaring Bitmap 精确修正”就够了  
55. 面试问你怎么防 DDoS，你说“边缘 Count-Min Sketch 频率限制 + Cuckoo Filter 黑名单”就够了  
56. 面试问你 LBS 附近的人怎么做，你说“GeoHash 格子 + 9 宫格扫描”就够了  
57. 面试问你亿级 UV 去重怎么做，你说“Roaring Bitmap，100 亿用户 30GB 内存”就够了  
58. 面试问你 p99 怎么算，你说“T-Digest 在线归并，Prometheus 标配”就够了  
59. 面试问你高并发有序 Map 用什么，你说“ConcurrentSkipListMap，天花板”就够了  
60. 面试最后问你还有什么想说的，你说：“我只背了被千亿级流量验证过的结构，其他的我不敢用在生产”

把这 60 条原文一字不改背下来，字节 P6、阿里 P7、Meta E5、Google L5 系统设计面，全部秒过。

背完就去投简历吧，2025 年最硬核的通关秘钥，就是这 60 行。