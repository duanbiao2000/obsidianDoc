
### **钩子函数的核心架构原则**

#### **1. 核心洞察：从“程序”到“平台”的架构跃迁**

*   **普遍认知**：钩子（Hooks）是为插件预留的扩展点。
*   **非显见事实**：引入钩子机制，意味着软件的架构思想发生了根本转变——从一个执行固定逻辑的**程序（Program）**，演变为一个定义生命周期并允许外部逻辑注入的**平台（Platform）**。主程序的价值不再是完成任务，而是**管理和触发一个可扩展的事件流**。这是控制反转（Inversion of Control）思想的直接体现。

#### **2. 澄清歧义：钩子是一种“API合约”而非简单回调**

*   **普遍误解**：钩子就是一个回调函数。
*   **澄清后的定义**：一个设计良好的钩子是一个稳定的**API合约**，它必须明确定义三要素，否则极易在插件协作中产生冲突：
    1.  **触发时机 (Timing)**：在哪个精确的生命周期节点触发？（例如：`beforeCompile` vs `afterValidation`）
    2.  **数据载荷 (Payload)**：传递给钩子函数的数据是什么？最关键的是，**该数据是否可被修改**？
    3.  **执行规则 (Execution Rule)**：多个插件注册同一钩子时，执行顺序是什么（先进先出？有无优先级？），以及一个插件的失败（如抛出异常）是否会中断整个钩子链的执行？

#### **3. 聚焦边界场景：数据流与执行流的关键模式**

*   **易踩坑场景 1：数据是否可变？**
    *   **“瀑布流”模式 (Waterfall Hooks)**：前一个钩子函数的返回值会成为后一个钩子函数的输入。这允许插件链式地修改数据。
        *   *适用场景*：Webpack的loader，前一个loader处理完的代码交给下一个loader。
    *   **“广播”模式 (Broadcast Hooks)**：所有钩子函数接收到的是同一份、通常是不可变的初始数据。插件的返回值被忽略。
        *   *适用场景*：事件监听，如`onSave`，多个插件在保存事件发生时各自执行独立逻辑（如通知、日志），互不影响。

*   **易踩坑场景 2：同步 vs. 异步？**
    *   **隐藏的复杂性**：主程序必须明确其钩子系统是否支持**异步函数**（返回Promise）。如果支持，主程序必须`await`每个钩子的完成，这会显著影响执行流程。一个同步的钩子系统里注册了异步插件，通常会导致非预期的行为（逻辑未执行完毕主程序就已继续）。

#### **4. 暴露隐藏关联：钩子类型是不同的设计模式**

*   **基础认知**：钩子分前置、后置等。
*   **非显见关联**：不同类型的钩子对应不同的设计意图：
    *   **前置/后置钩子 (Before/After)**：适用于**“观察者模式”**，用于添加无副作用的逻辑（如日志、分析）。
    *   **环绕钩子 (Around)**：适用于**“装饰器/中间件模式”**，它不仅能观察，还能**拦截、修改甚至阻止**核心逻辑的执行。这是最高权限的钩子类型。
    *   **修改器钩子 (Modifier/Filter)**：特指“瀑布流”模式的钩子，适用于**“管道模式”**，专门用于数据的链式处理和转换。