---
aliases:
date: 2025-09-16 23:18
source:
  - https://app.daily.dev/upvoted
update: 2026-01-07 16:37
rating:
view-count: 10
related:
  - "[[元编程理论入门]]"
  - "[[风险管理]]"
  - "[[2025-12-31-系统设计与架构模式]]"
---

# 代码认知负荷：高效工程的底层度量

## 1. 核心逻辑：认知负荷 = 1 / 代码质量

代码的本质是**给人看的文档**，其次才是机器指令。

- **金律**：减少开发者在理解逻辑时所需的心智跳转次数。
- **反例**：Linus Torvalds 抨击 `make_u32_from_two_u16()`，因其隐藏了直观的位运算，增加了无效抽象。

## 2. 模式对比矩阵 (Comparison)

| 维度       | 传统模式 (DRY 优先)               | 现代模式 (认知局部性优先)                 | ROI 洞察                |
| :------- | :-------------------------- | :----------------------------- | :-------------------- |
| **核心准则** | Don't Repeat Yourself (不重复) | Pace, Repetition, You (PRY)    | 适度重复优于晦涩的抽象。          |
| **代码组织** | 深度分层、逻辑拆分                   | **认知局部性** (Cognitive Locality) | 将相关逻辑放在一起，减少切屏。       |
| **抽象阈值** | 见重复即重构                      | 仅在降低复杂度时重构                     | 抽象是有税的，每层抽象消耗 1 个认知块。 |

## 3. 效能数据矩阵 (Actionable Data)

| 指标        | 关键基准            | 决策指南 (Actionable)               |
| :-------- | :-------------- | :------------------------------ |
| **工作记忆**  | **4 - 7 信息块**   | 超过 7 个变量/抽象层的函数必须拆解或重构。         |
| **开发速度**  | **2 小时 vs 2 周** | 采用低负载方法 2 小时出 MVP；过度工程化需 2 周。   |
| **AI 杠杆** | **80/20 原则**    | AI 生成 80% 模板代码；人类负责 20% 的架构与审计。 |
| **时效收益**  | **-1 小时/天**     | 使用 Copilot 平均每日节省 1 小时重复劳动。     |

## 4. 行动指南：低负荷开发 3 步走 (Execution)

1. **保持局部性 (Locality)**：
   - 拒绝“为了拆分而拆分”。确保一个功能的输入、处理、输出在物理距离上尽可能靠近。
2. **削减抽象税 (De-abstracting)**：
   - 问：“这个 Helper 函数是否真的让逻辑更清晰，还是只是隐藏了细节？”
   - 如果一行原生代码能说清，就不封装。
3. **敏捷 MVP 交付**：
   - 聚焦 20% 的核心 Feature。
   - **标准**：独立开发者 2 周内必须获得付费用户或明确反馈。

## 5. 决策指南：卡片自检 (Scenario)

- **场景 A：准备重构一段重复代码**
  - *判定*：如果抽象后需要跨 3 个文件才能看懂逻辑，**保持重复**。
- **场景 B：利用 AI 辅助编程**
  - *协议*：将 80% 的 CRUD 交给 Copilot，强制留出 1 小时/天进行**架构深度思考**。

---

### 质量自检

- **压缩率**：约 65% (剔除冗余修辞，转化为指令集)
- **层级**：2 层 (核心逻辑/对比矩阵/数据矩阵/行动指南/决策指南)
- **5秒测试**：一眼可见“4-7 信息块”约束与“认知局部性”原则。

**关联笔记**

- [[作品意识]]
- [[阶段性成果驱动的学习路径]]
- [[系统设计：规模化与权衡指南]]
