以下通过一个具体场景展示 PRD 和 Spec 的核心区别：

## 场景：为电商平台增加"优惠券领取"功能

***

### PRD 示例（产品需求文档）

**问题陈述**  
用户在购物时缺乏领券入口，导致优惠券使用率低（当前仅 15%）。商家反馈希望提高优惠券的曝光和领取效率。

**目标**  
- 提升优惠券领取率至 40%
- 增加用户下单转化率 8%
- 提高用户活跃度

**用户场景**  
小李浏览商品详情页时，看到"限时领券"提示，点击后直接领取满 200 减 30 的优惠券，结账时自动抵扣。

**核心功能**  
- 商品页展示可用优惠券入口
- 一键领取功能
- 用户优惠券列表查看
- 结算时自动匹配最优优惠券

**成功指标**  
- 优惠券领取率 ≥ 40%
- 使用优惠券的订单占比 ≥ 25%
- 用户人均领券数量 ≥ 2 张/月

**时间规划**  
- V1.0：基础领取+使用流程（2周）
- V2.0：个性化推荐（4周后）

***

### Spec 示例（技术规格说明书）

**功能：优惠券一键领取**

**接口定义**

```
POST /api/v1/coupons/claim
Request Body:
{
  "coupon_id": "string",
  "user_id": "string"
}

Response:
{
  "success": true,
  "data": {
    "coupon_code": "SAVE30",
    "expire_at": "2025-12-31T23:59:59Z"
  }
}

错误码：
- 4001: 优惠券已领完
- 4002: 用户已领取过
- 4003: 不满足领取条件
```

**数据模型**

```
user_coupons 表：
- id (bigint, primary key)
- user_id (bigint, index)
- coupon_id (bigint)
- status (enum: unused/used/expired)
- claim_time (timestamp)
- expire_time (timestamp)
```

**业务逻辑**

领取流程：
1. 校验用户登录状态
2. 检查优惠券库存 > 0
3. 查询用户是否已领取（unique constraint: user_id + coupon_id）
4. 扣减库存（使用 Redis 分布式锁）
5. 写入 user_coupons 表
6. 返回成功结果

异常处理：
- 库存不足：返回 4001，前端展示"已抢光"
- 重复领取：返回 4002，前端展示"您已领过"
- 接口超时：3秒后返回 504，引导用户重试

**前端交互**

商品详情页：
- 显示位置：价格下方，醒目标签样式
- 点击"立即领取"按钮 → 调用接口
- 成功：Toast 提示"领取成功"+ 按钮变灰显示"已领取"
- 失败：根据错误码显示对应文案

**性能要求**
- 接口响应时间 < 200ms（P95）
- 支持并发 1000 QPS
- 库存扣减保证强一致性

***

## 核心区别对比

**PRD 回答的问题：**
- ❓ 为什么做？（提升优惠券使用率）
- 🎯 给谁做？（价格敏感型用户）
- 📊 如何衡量成功？（领取率 40%）

**Spec 回答的问题：**
- ⚙️ 接口怎么设计？（POST /api/v1/coupons/claim）
- 💾 数据怎么存储？（user_coupons 表结构）
- 🔧 边界情况怎么处理？（库存为 0、重复领取）

***

## 实际工作流程

**阶段 1：产品经理编写 PRD**  
在 Figma 中设计原型 → 标注核心流程 → 输出 PRD 文档

**阶段 2：技术团队拆解 Spec**  
基于 PRD 开评审会 → 前后端定义接口（Swagger 文档）→ 确定数据表设计

**阶段 3：并行开发**  
- 前端依据 Figma 原型 + Swagger 接口开发
- 后端依据 Spec 实现业务逻辑
- 测试依据 Spec 编写测试用例

这个例子清晰展示了：**PRD 聚焦"做什么和为什么"，Spec 聚焦"怎么做和实现细节"**。二者配合才能确保产品从构思到上线的顺利交付。

***

需要我进一步解释 PRD 或 Spec 的具体章节写作技巧吗？

