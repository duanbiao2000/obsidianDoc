---
aliases: null
date: 2025-11-26 11:03
tags: null
collections: null
source: null
rating: null
related: null
---

该仓库文档中提到了多种测试类型，包括：

- **单元测试 (Unit Testing)**: 强调了基础的测试原则和模式，比如测试应关注公共方法和可观察行为，而不是内部实现细节，这与单元测试的理念相符。
- **集成测试 (Integration Testing)**: 文档中多次提到集成测试，尤其是在 [Backend Testing](#javascriptnodejs-testing-best-practices-guide-core-testing-principles-and-patterns) 部分，强调了在微服务架构下集成测试的重要性。
- **组件测试 (Component Testing)**: 被认为是单元测试和端到端测试之间的平衡点，侧重于微服务的 API，使用真实依赖（如内存数据库）但模拟外部服务。[`Supertest`](%2Fgoldbergyoni%2Fjavascript-testing-best-practices%2Freadme.md#L793) 在此情境下被提及作为测试 Express API 的工具。详情可查阅 [Advanced Testing Techniques](#javascriptnodejs-testing-best-practices-guide-advanced-testing-techniques) 和 [Backend Testing](#javascriptnodejs-testing-best-practices-guide-core-testing-principles-and-patterns)。
- **端到端测试 (End-to-End Testing - E2E Testing)**: 尤其在 [Frontend Testing Considerations](#javascriptnodejs-testing-best-practices-guide-frontend-testing-considerations) 中提到，建议E2E测试数量要少，并利用一些技巧来提高效率，如重复使用登录凭据和进行冒烟测试。
- **契约测试 (Contract Testing)**: 使用 [`PACT`](%2Fgoldbergyoni%2Fjavascript-testing-best-practices%2Freadme.md#L805) 等框架确保服务之间的 API 兼容性，避免微服务架构中的破坏性变更。可查看 [Advanced Testing Techniques](#javascriptnodejs-testing-best-practices-guide-advanced-testing-techniques)。
- **基于属性的测试 (Property-based Testing)**: 利用工具（如 [`js-verify`](%2Fgoldbergyoni%2Fjavascript-testing-best-practices%2Freadme.md#L433)、[`testcheck-js`](%2Fgoldbergyoni%2Fjavascript-testing-best-practices%2Freadme.md#L433) 或 [`fast-check`](%2Fgoldbergyoni%2Fjavascript-testing-best-practices%2Freadme.md#L444)）自动生成多种输入组合，以全面测试组件的行为，从而发现手动测试可能遗漏的边缘情况。在 [Advanced Testing Techniques](#javascriptnodejs-testing-best-practices-guide-advanced-testing-techniques) 中有详细说明。
- **变异测试 (Mutation Testing)**: 一种评估测试套件逻辑鲁棒性的高级技术，通过引入小的合成错误（变异）来检查测试是否能检测到这些错误。在 [Measuring and Improving Test Effectiveness](#javascriptnodejs-testing-best-practices-guide-measuring-and-improving-test-effectiveness) 中有提及。
- **视觉回归测试 (Visual Regression Testing)**: 自动化工具用于检测用户界面在不同浏览器或设备上的意外视觉变化或中断，确保视觉完整性。在 [Frontend Testing Considerations](#javascriptnodejs-testing-best-practices-guide-frontend-testing-considerations) 中有提及。
- **混沌工程 (Chaos Engineering)**: 通过故意引入故障或混乱条件来测试应用程序的弹性，例如使用 [`node-chaos`](%2Fgoldbergyoni%2Fjavascript-testing-best-practices%2Freadme.md#L905) 模拟内存过载、事件循环阻塞等问题。可查看 [Advanced Testing Techniques](#javascriptnodejs-testing-best-practices-guide-advanced-testing-techniques)。
- **冒烟测试 (Smoke Testing)**: 在 [Frontend Testing Considerations](#javascriptnodejs-testing-best-practices-guide-frontend-testing-considerations) 中提到，作为 E2E 测试的一种形式，建议进行一个最小的、覆盖关键页面的冒烟测试。
- **静态分析 (Static Analysis)**: 使用 Sonarqube 和 Code Climate 等工具在 CI/CD 流水线中检测代码质量问题和“代码异味”。在 [`readme-es.md`](%2Fgoldbergyoni%2Fjavascript-testing-best-practices%2Freadme.md#L35) 和 [`readme-pl.md`](%2Fgoldbergyoni%2Fjavascript-testing-best-practices%2Freadme.md#L34) 中有提及。

**JavaScript/Node.js 测试最佳实践仓库页面简要总结：**

- 本页面是关于 JavaScript 和 Node.js 应用测试最佳实践的详尽指南，覆盖了后端、前端测试、持续集成（CI/CD）、代码质量评估和社区贡献流程。

- **核心原则和模式：**

  - 鼓励使用「安排-执行-断言」（AAA）模式组织测试，并采用具描述性的命名。

  - 强调黑盒测试（只针对公共接口），并建议合理使用替身（stubs、spies 优于 mocks）。

  - 提倡测试可维护性、可读性和精简（Lean Testing）。

- **高级测试技术：**

  - 包括属性测试、组件测试、契约测试、混沌工程、视觉回归测试和静态分析等。

  - 推荐工具如 Stryker（变异测试）、PACT（契约测试）、Supertest（API 测试）、fast-check（属性测试）、SonarQube/Code Climate（静态分析）、Applitools/Percy（视觉回归）等。

- **前端测试实践：**

  - 建议将 UI 与功能分离，用稳定的 HTML 属性（如 data-test-id）查询元素，采用自动化视觉回归工具保障 UI 一致性。

  - E2E 测试数量建议较少，重用登录操作并做冒烟测试以提升效率。

- **评估和提升测试有效性：**

  - 用代码覆盖率（建议 80% 以上）、变异测试等方法检测和补全测试盲区，持续提升测试套件质量。

- **CI/CD 流水线及质量门控：**

  - 详细介绍在 CI/CD 中自动化质量检查，如构建、Lint 校验、静态分析、依赖升级及矩阵测试。

  - 鼓励本地模拟 CI 流程，缩短反馈环节，加速开发周期。

- **社区贡献与多语言支持：**

  - 支持英/中/法/日等多语言，贡献翻译需满足规定的质量门槛，贡献者获得署名和公开认可。

- **涵盖的测试类型：**

  - 单元测试、集成测试、组件测试、端到端（E2E）测试、契约测试、属性测试、变异测试、视觉回归测试、混沌工程、冒烟测试、静态分析等。

本页面为开发者和测试人员构建高效、可靠的 JavaScript/Node.js 测试体系，提供了原则、方法、实用工具和标准化贡献流程，适合提升应用质量和团队协作。[codewiki](https://codewiki.google/github.com/goldbergyoni/javascript-testing-best-practices)​

1. <https://codewiki.google/github.com/goldbergyoni/javascript-testing-best-practices>

---

## 核心总结

我为您整理了完整的对比，重点是这三个维度：

### **1. 本质区别**

|             | **Stub**  | **Spy**     | **Mock** |
| ----------- | --------- | ----------- | -------- |
| **比喻**      | 木偶（只返回答案） | 监听器（保留真实行为） | 演员（完全受控） |
| **对原对象的改动** | 完全替换      | 包装但保留       | 完全替换     |
| **能验证调用吗**  | ❌         | ✅           | ✅        |
| **执行真实逻辑吗** | ❌         | ✅           | ❌        |

### **2. 实战选择标准**

根据您的 5 年经验，记住这个决策流：

```
需要验证"调用"吗？
  ├─ NO → Stub（最快、最稳定）
  └─ YES → 需要真实结果吗？
           ├─ YES → Spy（推荐）
           └─ NO → Mock（谨慎用）
```

### **3. 最关键的点**

**Mock 的危险**：当您 mock 多个依赖时，测试变得与实现紧耦合。改了调用顺序或参数格式，测试就断裂——即使功能完全正常。

**Spy 的优势**：保留真实行为意味着您在测试"真实的依赖交互"，而不是"测试您对交互的假设"。

**在 Google 的应用**：对于大型项目，建议目标比例是 70% Stub + 25% Spy + 5% Mock。这样测试既快速又稳定。

有具体的测试用例想从这个角度重构吗？
