---
view-count: 5
---
## 1. 核心逻辑：控制反转 (Inversion of Control, IoC)

**系统失效模式 (Manual Wiring)：**
- **耦合爆炸**：对象内部直接 `new` 依赖，导致修改底层类需重构整个依赖链。
- **测试锁定**：硬编码依赖导致无法注入 Mock 对象，单元测试困难。
- **管理熵增**：手动管理 $N$ 个对象的生命周期与组装顺序，复杂度呈 $O(N^2)$ 增长。

**优化目标：**
将依赖的“创建权”与“生命周期管理”外包给容器，实现组装逻辑与业务逻辑的解耦。

## 2. 协议架构：DI 容器算法 (The DI Algorithm)

| 阶段 | 操作 (Operator) | 逻辑职能 |
| :--- | :--- | :--- |
| **1. 注册 (Register)** | `Type -> Implementation` | 建立元数据映射表，定义单例 (Singleton) 或瞬时 (Transient) 属性。 |
| **2. 反射 (Reflect)** | `inspect.signature` | 利用类型注解 (Type Hints) 提取构造函数的依赖参数。 |
| **3. 递归 (Resolve)** | `Recursive Instantiation` | 递归解析依赖图 (Dependency Graph)；若依赖未实例化则进入深度搜索。 |
| **4. 注入 (Inject)** | `**kwargs` | 将解析出的实例作为参数注入构造函数，返回顶层对象。 |

## 3. 实现矩阵：核心组件 (Core Components)

| 组件 | 核心代码逻辑 | 执行协议 |
| :--- | :--- | :--- |
| **`DIContainer`** | `Dict[Type, Factory]` | 存储类型到实现类/工厂函数的映射。 |
| **`_instantiate`** | `递归调用 resolve()` | 自动遍历构造函数参数，直至触达叶子节点（无依赖类）。 |
| **`Singleton`** | `_instances[Type]` | 缓存已创建的实例，确保全局唯一性。 |
| **`Factory`** | `lambda: CustomObj(...)` | 绕过自动解析，支持注入配置参数或动态逻辑。 |

## 4. 执行指南 (Execution Protocol)

### **代码约束 (Constraints)**
- **类型透明**：构造函数参数必须有明确的类型注解（如 `db: DatabaseConnection`）。
- **零依赖入侵**：业务类不应引用容器 API，保持代码的纯净与可移植性。
- **单例优先**：无状态服务（Service/Repo）优先注册为单例，降低内存开销。

### **性能优化 (Performance)**
- **预热加载**：在系统启动时解析关键路径的依赖，避免运行时首次调用的延迟。
- **延迟加载**：非核心功能使用工厂函数包装，实现按需解析。

## 5. 快速逻辑验证 (Distilled Implementation)

```python
# 核心逻辑伪代码：递归解析
def resolve(interface_type):
    # 1. 检查缓存 (Singleton)
    if interface_type in _instances: return _instances[interface_type]
    
    # 2. 获取参数签名
    params = inspect.signature(cls.__init__).parameters
    
    # 3. 递归解析子依赖
    deps = {name: resolve(p.annotation) for name, p in params.items()}
    
    # 4. 实例化并返回
    instance = cls(**deps)
    return instance
```

## 关联笔记
- [[Python代码注释规范自适应提示词]] (类型注解与语义增强实践) [^1]
- [[原则驱动行动]] (KISS/DRY 原则在系统解耦中的应用) [^2]
- [[Go开发者实战指南]] (L3 工程化中的架构模式对比) [^3]
- [[文档化Planning]] (复杂系统选型的决策逻辑) [^4]

