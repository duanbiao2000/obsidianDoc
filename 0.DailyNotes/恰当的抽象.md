---
aliases:
  - Proper Abstractions
date: 2025-11-05 11:37
tags:
source:
  - https://github.com/duanbiao2000/claude-flow/blob/main/.claude/agents/core/reviewer.md
update:
rating:
related:
---

在代码审核中，**Proper Abstractions（恰当的抽象）** 是衡量代码质量的核心标准之一，指通过合理的抽象设计，将复杂逻辑简化、隔离关注点、降低耦合度，同时保持代码的可理解性、可复用性和可扩展性。

简单说，**好的抽象能“隐藏不必要的细节，暴露必要的接口”**，让使用者无需关心内部实现，只需通过明确的接口即可完成操作。

### 代码审核中判断“抽象是否恰当”的核心维度

#### 1. **单一职责：抽象是否聚焦于一个明确的目标？**

- **反面案例**：一个名为 `UserHandler` 的类，既处理用户登录逻辑，又负责数据库连接、日志打印，甚至包含前端表单验证——抽象边界模糊，职责混乱。
- **审核要点**：每个抽象（类、函数、模块）是否只做一件事？是否能用一句话清晰描述其职责？

#### 2. **接口与实现分离：是否暴露“what”而非“how”？**

- **核心原则**：抽象应定义“做什么”（接口、方法签名），而非“怎么做”（具体实现）。
- **正面案例**：

```typescript
// 抽象接口（只定义“要做什么”）  
interface PaymentProcessor {  
process(amount: number): Promise<boolean>;  
}  
  
// 具体实现（隐藏“怎么做”的细节）  
class WechatPayProcessor implements PaymentProcessor {  
async process(amount: number): Promise<boolean> {  
// 微信支付的具体逻辑（加密、调用API等细节被隐藏）  
}  
}  
```

- **审核要点**：使用者是否只需依赖抽象接口，而非具体实现？是否能轻松替换不同实现（如从微信支付切换到支付宝支付）？

#### 3. **避免过度抽象与重复抽象**

- **过度抽象**：为简单逻辑强行添加多层抽象（如一个单步计算函数拆分为“策略接口+抽象类+具体实现”），导致代码冗余、理解成本上升。
- 例：一个仅用于格式化日期的函数，无需设计成“日期格式化策略模式”。
- **重复抽象**：多个抽象解决相同问题（如项目中同时存在 `HttpUtil`、`RequestHelper`、`ApiClient` 三个功能重叠的网络工具类）。
- **审核要点**：抽象是否“刚刚好”？是否存在可合并的重复抽象，或可简化的过度设计？

#### 4. **命名与意图匹配：抽象的命名是否清晰表达其用途？**

- **反面案例**：一个名为 `DataProcessor` 的类，实际功能是解析Excel文件——命名模糊，未体现核心职责。
- **正面案例**：`ExcelParser`（明确处理Excel解析）、`JwtTokenGenerator`（明确生成JWT令牌）。
- **审核要点**：通过抽象的名称，能否快速理解其功能和适用场景？

#### 5. **隔离变化点：抽象是否将“易变部分”与“稳定部分”分离？**

- **核心思想**：系统中经常变化的逻辑（如第三方API调用、业务规则）应被抽象封装，而稳定的核心逻辑（如流程控制）依赖抽象接口。
- **正面案例**：

```typescript
// 稳定的核心流程（不依赖具体实现）  
function handleOrderPayment(processor: PaymentProcessor, amount: number) {  
// 固定的支付前检查逻辑（稳定）  
return processor.process(amount); // 调用抽象接口，不关心具体支付方式（易变）  
}  
```

- **审核要点**：当需求变化（如更换支付方式、修改数据存储）时，是否只需修改抽象的实现，而非大量修改依赖它的代码？

### 代码审核中常见的“抽象不当”问题及改进

| 问题场景   | 问题描述                                              | 改进方向                                                      |
| ------ | ------------------------------------------------- | --------------------------------------------------------- |
| 硬编码逻辑  | 直接在业务代码中写死具体值（如 `if (type === 'wechat') { ... }`） | 抽象为策略模式，用接口统一不同类型的处理逻辑                                    |
| 超大函数/类 | 一个函数包含数百行代码，处理从数据获取到渲染的全流程                        | 按职责拆分为多个小函数/类（如 `DataFetcher`、`DataFormatter`、`Renderer`） |
| 重复代码块  | 多个地方出现相同的“参数校验+日志+异常处理”逻辑                         | 抽象为装饰器（Decorator）或工具函数（如 `withValidation`、`withLogging`）  |
| 暴露内部状态 | 类通过 `public` 字段直接暴露内部数据，导致外部可随意修改                 | 用 `private` 隐藏状态，仅通过 `getter`/`setter` 或方法暴露必要操作          |

### 总结

代码审核中关注“Proper Abstractions”，本质是判断代码是否具备“高内聚、低耦合”的特性：

- **内聚**：抽象内部的逻辑是否紧密相关、目标一致。
- **耦合**：抽象之间的依赖是否基于接口而非实现，是否能独立修改。

好的抽象就像“黑盒”——使用者只需知道“输入什么、输出什么”，无需关心内部细节，这也是大规模协作和长期维护的基础。
