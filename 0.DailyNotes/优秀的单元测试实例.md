# ä¼˜ç§€çš„å•å…ƒæµ‹è¯•å®ä¾‹ï¼šç”¨æˆ·è®¤è¯æœåŠ¡

è®©æˆ‘é€šè¿‡ä¸€ä¸ªå®é™…çš„ç”¨æˆ·è®¤è¯æœåŠ¡æ¥å±•ç¤ºä»€ä¹ˆæ˜¯å¥½çš„å•å…ƒæµ‹è¯•â€”â€”ä¸“æ³¨äºéªŒè¯å¤–éƒ¨è¡Œä¸ºï¼Œè€Œä¸æ˜¯å†…éƒ¨å®ç°ã€‚

## ğŸ¯ æ¡ˆä¾‹èƒŒæ™¯ï¼šç”¨æˆ·è®¤è¯æœåŠ¡

å‡è®¾æˆ‘ä»¬è¦å¼€å‘ä¸€ä¸ªç”¨æˆ·è®¤è¯æœåŠ¡ï¼Œè´Ÿè´£ç”¨æˆ·ç™»å½•éªŒè¯åŠŸèƒ½ã€‚

## ğŸ”§ ç¬¬ä¸€é˜¶æ®µï¼šåˆå§‹å®ç°

```go
// auth/service.go
package auth

import (
    "crypto/sha256"
    "fmt"
)

type User struct {
    ID       int
    Username string
    Password string // å®é™…å­˜å‚¨çš„æ˜¯å“ˆå¸Œå€¼
    Salt     string
}

type UserRepository interface {
    FindByUsername(username string) (*User, error)
}

type AuthService struct {
    userRepo UserRepository
}

func NewAuthService(repo UserRepository) *AuthService {
    return &AuthService{userRepo: repo}
}

func (s *AuthService) Authenticate(username, password string) (bool, error) {
    // 1. æŸ¥æ‰¾ç”¨æˆ·
    user, err := s.userRepo.FindByUsername(username)
    if err != nil {
        return false, fmt.Errorf("ç”¨æˆ·æŸ¥æ‰¾å¤±è´¥: %w", err)
    }
    if user == nil {
        return false, nil // ç”¨æˆ·ä¸å­˜åœ¨
    }
    
    // 2. ç”Ÿæˆå¯†ç å“ˆå¸Œ
    hash := sha256.Sum256([]byte(password + user.Salt))
    hashedPassword := fmt.Sprintf("%x", hash)
    
    // 3. éªŒè¯å¯†ç 
    if hashedPassword == user.Password {
        return true, nil
    }
    
    return false, nil
}
```

## âœ… ç¬¬äºŒé˜¶æ®µï¼šä¼˜ç§€çš„å•å…ƒæµ‹è¯•ï¼ˆå…³æ³¨å¤–éƒ¨è¡Œä¸ºï¼‰

```go
// auth/service_test.go
package auth_test

import (
    "errors"
    "testing"
    "auth"
)

// Mock å®ç° - åªå…³å¿ƒå¤–éƒ¨æ¥å£å¥‘çº¦
type mockUserRepository struct {
    users map[string]*auth.User
    err   error
}

func (m *mockUserRepository) FindByUsername(username string) (*auth.User, error) {
    if m.err != nil {
        return nil, m.err
    }
    user, exists := m.users[username]
    if !exists {
        return nil, nil // ç”¨æˆ·ä¸å­˜åœ¨
    }
    return user, nil
}

// æµ‹è¯•ï¼šéªŒè¯æ­£ç¡®çš„ç”¨æˆ·åå’Œå¯†ç åº”è¯¥æˆåŠŸè®¤è¯
func TestAuthService_Authenticate_ValidCredentials_ReturnsTrue(t *testing.T) {
    // Arrange - å‡†å¤‡æµ‹è¯•æ•°æ®
    repo := &mockUserRepository{
        users: map[string]*auth.User{
            "alice": {
                ID:       1,
                Username: "alice",
                Password: "5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8", // "password" + "salt123" çš„ SHA256
                Salt:     "salt123",
            },
        },
    }
    service := auth.NewAuthService(repo)
    
    // Act - æ‰§è¡Œè¢«æµ‹è¯•çš„è¡Œä¸º
    valid, err := service.Authenticate("alice", "password")
    
    // Assert - éªŒè¯å¤–éƒ¨è¡Œä¸ºç»“æœ
    if err != nil {
        t.Fatalf("æœŸæœ›æ— é”™è¯¯ï¼Œä½†å¾—åˆ°: %v", err)
    }
    if !valid {
        t.Error("æœŸæœ›è®¤è¯æˆåŠŸï¼Œä½†è¿”å›å¤±è´¥")
    }
}

// æµ‹è¯•ï¼šéªŒè¯é”™è¯¯çš„å¯†ç åº”è¯¥è®¤è¯å¤±è´¥
func TestAuthService_Authenticate_WrongPassword_ReturnsFalse(t *testing.T) {
    // Arrange
    repo := &mockUserRepository{
        users: map[string]*auth.User{
            "alice": {
                ID:       1,
                Username: "alice",
                Password: "5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8",
                Salt:     "salt123",
            },
        },
    }
    service := auth.NewAuthService(repo)
    
    // Act
    valid, err := service.Authenticate("alice", "wrongpassword")
    
    // Assert
    if err != nil {
        t.Fatalf("æœŸæœ›æ— é”™è¯¯ï¼Œä½†å¾—åˆ°: %v", err)
    }
    if valid {
        t.Error("æœŸæœ›è®¤è¯å¤±è´¥ï¼Œä½†è¿”å›æˆåŠŸ")
    }
}

// æµ‹è¯•ï¼šéªŒè¯ä¸å­˜åœ¨çš„ç”¨æˆ·åº”è¯¥è®¤è¯å¤±è´¥
func TestAuthService_Authenticate_NonExistentUser_ReturnsFalse(t *testing.T) {
    // Arrange
    repo := &mockUserRepository{
        users: make(map[string]*auth.User), // ç©ºçš„ç”¨æˆ·é›†åˆ
    }
    service := auth.NewAuthService(repo)
    
    // Act
    valid, err := service.Authenticate("nonexistent", "password")
    
    // Assert
    if err != nil {
        t.Fatalf("æœŸæœ›æ— é”™è¯¯ï¼Œä½†å¾—åˆ°: %v", err)
    }
    if valid {
        t.Error("æœŸæœ›è®¤è¯å¤±è´¥ï¼Œä½†è¿”å›æˆåŠŸ")
    }
}

// æµ‹è¯•ï¼šéªŒè¯å­˜å‚¨å±‚é”™è¯¯åº”è¯¥è¿”å›é”™è¯¯
func TestAuthService_Authenticate_RepositoryError_ReturnsError(t *testing.T) {
    // Arrange
    expectedErr := errors.New("æ•°æ®åº“è¿æ¥å¤±è´¥")
    repo := &mockUserRepository{
        err: expectedErr,
    }
    service := auth.NewAuthService(repo)
    
    // Act
    valid, err := service.Authenticate("alice", "password")
    
    // Assert
    if err == nil {
        t.Fatal("æœŸæœ›å¾—åˆ°é”™è¯¯ï¼Œä½†æ²¡æœ‰é”™è¯¯")
    }
    if valid {
        t.Error("æœŸæœ›è®¤è¯å¤±è´¥ï¼Œä½†è¿”å›æˆåŠŸ")
    }
    if err.Error() != "ç”¨æˆ·æŸ¥æ‰¾å¤±è´¥: æ•°æ®åº“è¿æ¥å¤±è´¥" {
        t.Errorf("æœŸæœ›é”™è¯¯æ¶ˆæ¯ä¸åŒ¹é…ï¼Œå¾—åˆ°: %v", err)
    }
}
```

## ğŸ”¨ ç¬¬ä¸‰é˜¶æ®µï¼šé‡æ„å†…éƒ¨å®ç°ï¼ˆæµ‹è¯•ä¸å¤±è´¥ï¼‰

ç°åœ¨æˆ‘ä»¬éœ€è¦é‡æ„è®¤è¯æœåŠ¡ï¼Œä½¿ç”¨æ›´å®‰å…¨çš„å¯†ç å“ˆå¸Œç®—æ³•ï¼ˆå¦‚ bcryptï¼‰ï¼Œä½†ä¿æŒå¤–éƒ¨è¡Œä¸ºä¸å˜ï¼š

```go
// auth/service_v2.go - é‡æ„åçš„å®ç°
package auth

import (
    "fmt"
    "golang.org/x/crypto/bcrypt"
)

type User struct {
    ID       int
    Username string
    Password string // ç°åœ¨å­˜å‚¨ bcrypt å“ˆå¸Œ
    // æ³¨æ„ï¼šä¸å†éœ€è¦ Salt å­—æ®µï¼Œå› ä¸º bcrypt å†…éƒ¨å¤„ç†
}

type UserRepository interface {
    FindByUsername(username string) (*User, error)
}

type AuthService struct {
    userRepo UserRepository
}

func NewAuthService(repo UserRepository) *AuthService {
    return &AuthService{userRepo: repo}
}

func (s *AuthService) Authenticate(username, password string) (bool, error) {
    // 1. æŸ¥æ‰¾ç”¨æˆ·ï¼ˆå¤–éƒ¨è¡Œä¸ºä¸å˜ï¼‰
    user, err := s.userRepo.FindByUsername(username)
    if err != nil {
        return false, fmt.Errorf("ç”¨æˆ·æŸ¥æ‰¾å¤±è´¥: %w", err)
    }
    if user == nil {
        return false, nil // ç”¨æˆ·ä¸å­˜åœ¨ï¼ˆå¤–éƒ¨è¡Œä¸ºä¸å˜ï¼‰
    }
    
    // 2. éªŒè¯å¯†ç ï¼ˆå†…éƒ¨å®ç°æ”¹å˜ï¼Œä½†å¤–éƒ¨è¡Œä¸ºä¸å˜ï¼‰
    err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
    if err != nil {
        return false, nil // å¯†ç é”™è¯¯ï¼ˆå¤–éƒ¨è¡Œä¸ºä¸å˜ï¼‰
    }
    
    return true, nil // è®¤è¯æˆåŠŸï¼ˆå¤–éƒ¨è¡Œä¸ºä¸å˜ï¼‰
}
```

## ğŸ¯ å…³é”®å¯¹æ¯”ï¼šå¥½æµ‹è¯• vs åæµ‹è¯•

### âŒ åçš„æµ‹è¯•ï¼ˆå…³æ³¨å†…éƒ¨å®ç°ï¼‰
```go
// è¿™æ˜¯ä¸å¥½çš„æµ‹è¯•ç¤ºä¾‹
func TestAuthService_Authenticate_BadExample(t *testing.T) {
    // é”™è¯¯ï¼šç›´æ¥æµ‹è¯•å†…éƒ¨å®ç°ç»†èŠ‚
    repo := &mockUserRepository{
        users: map[string]*auth.User{
            "alice": {
                ID:       1,
                Username: "alice",
                Password: "old_sha256_hash", // ç›´æ¥ä¾èµ–å…·ä½“å“ˆå¸Œç®—æ³•
                Salt:     "salt123",
            },
        },
    }
    service := auth.NewAuthService(repo)
    
    // é”™è¯¯ï¼šéªŒè¯å†…éƒ¨è°ƒç”¨ç»†èŠ‚
    valid, err := service.Authenticate("alice", "password")
    
    // é”™è¯¯ï¼šæµ‹è¯•ä¸åº”è¯¥å…³å¿ƒå†…éƒ¨å¦‚ä½•ç”Ÿæˆå“ˆå¸Œ
    if valid && service.internalHashMethodCalled { // è¿™ç§æµ‹è¯•åœ¨é‡æ„æ—¶ä¼šå¤±è´¥
        t.Error("å†…éƒ¨æ–¹æ³•åº”è¯¥è¢«è°ƒç”¨")
    }
}
```

### âœ… å¥½çš„æµ‹è¯•ï¼ˆå…³æ³¨å¤–éƒ¨è¡Œä¸ºï¼‰
```go
// è¿™æ˜¯å¥½çš„æµ‹è¯•ç¤ºä¾‹
func TestAuthService_Authenticate_GoodExample(t *testing.T) {
    // æ­£ç¡®ï¼šåªå…³å¿ƒè¾“å…¥å’Œè¾“å‡º
    repo := &mockUserRepository{
        users: map[string]*auth.User{
            "alice": {
                ID:       1,
                Username: "alice",
                Password: "any_hash_format", // ä¸å…³å¿ƒå…·ä½“æ ¼å¼
            },
        },
    }
    service := auth.NewAuthService(repo)
    
    // æ­£ç¡®ï¼šåªéªŒè¯å¤–éƒ¨è¡Œä¸ºå¥‘çº¦
    valid, err := service.Authenticate("alice", "correct_password")
    
    // æ­£ç¡®ï¼šéªŒè¯å…¬å¼€çš„è¿”å›å€¼
    if !valid || err != nil {
        t.Errorf("æœŸæœ›è®¤è¯æˆåŠŸä¸”æ— é”™è¯¯ï¼Œå¾—åˆ° valid=%v, err=%v", valid, err)
    }
}
```

## ğŸ”„ é‡æ„éªŒè¯

å½“æˆ‘ä»¬å°† SHA256 é‡æ„ä¸º bcrypt æ—¶ï¼š

### æµ‹è¯•ç»“æœï¼š
âœ… **æ‰€æœ‰æµ‹è¯•éƒ½é€šè¿‡** - å› ä¸ºæˆ‘ä»¬åªéªŒè¯å¤–éƒ¨è¡Œä¸º

### éœ€è¦ä¿®æ”¹çš„æµ‹è¯•ï¼š
âŒ **ä¸éœ€è¦ä¿®æ”¹ä»»ä½•æµ‹è¯•** - å› ä¸ºå¤–éƒ¨å¥‘çº¦æ²¡æœ‰æ”¹å˜

### åªéœ€æ›´æ–°æµ‹è¯•æ•°æ®ï¼š
```go
// æµ‹è¯•æ•°æ®æ›´æ–°ï¼ˆåªæ›´æ–°å“ˆå¸Œå€¼ï¼Œä¸æ”¹å˜æµ‹è¯•é€»è¾‘ï¼‰
users: map[string]*auth.User{
    "alice": {
        ID:       1,
        Username: "alice",
        Password: "$2a$10$N.zmdr9K7uOCQb0bta/OauRxaOKSr.QhqyD2R5FKvMQjmHoLkm5Sy", // bcrypt å“ˆå¸Œ
        // Salt å­—æ®µå·²ç§»é™¤
    },
}
```

## ğŸ¯ è®¾è®¡åŸåˆ™æ€»ç»“

### ä¼˜ç§€çš„å•å…ƒæµ‹è¯•ç‰¹å¾ï¼š

1. **è¡Œä¸ºå¯¼å‘**ï¼šæµ‹è¯•"åšä»€ä¹ˆ"è€Œä¸æ˜¯"æ€ä¹ˆåš"
2. **å¥‘çº¦éªŒè¯**ï¼šéªŒè¯å…¬å¼€æ¥å£çš„è¾“å…¥è¾“å‡ºå¥‘çº¦
3. **å®ç°æ— å…³**ï¼šä¸ä¾èµ–å†…éƒ¨å®ç°ç»†èŠ‚
4. **ç¨³å®šå¯é **ï¼šé‡æ„æ—¶ä¸ä¼šæ— æ•…å¤±è´¥
5. **æ˜“äºç†è§£**ï¼šæµ‹è¯•æ„å›¾æ¸…æ™°æ˜ç¡®

### æµ‹è¯•åº”è¯¥å…³æ³¨çš„å¤–éƒ¨è¡Œä¸ºï¼š

âœ… **è¾“å…¥è¾“å‡º**ï¼šå‡½æ•°å‚æ•°å’Œè¿”å›å€¼
âœ… **å‰¯ä½œç”¨**ï¼šå¯¹å¤–éƒ¨çŠ¶æ€çš„æ”¹å˜
âœ… **é”™è¯¯å¤„ç†**ï¼šé”™è¯¯æƒ…å†µä¸‹çš„è¡Œä¸º
âœ… **çŠ¶æ€è½¬æ¢**ï¼šå¯¹è±¡çŠ¶æ€çš„å˜åŒ–

### æµ‹è¯•ä¸åº”è¯¥å…³æ³¨çš„å†…éƒ¨å®ç°ï¼š

âŒ **ç®—æ³•ç»†èŠ‚**ï¼šå…·ä½“çš„å“ˆå¸Œç®—æ³•ã€æ’åºç®—æ³•ç­‰
âŒ **å†…éƒ¨è°ƒç”¨**ï¼šå…·ä½“è°ƒç”¨äº†å“ªäº›å†…éƒ¨æ–¹æ³•
âŒ **æ•°æ®ç»“æ„**ï¼šå†…éƒ¨ä½¿ç”¨äº†ä»€ä¹ˆæ•°æ®ç»“æ„
âŒ **ä¸´æ—¶å˜é‡**ï¼šå‡½æ•°å†…éƒ¨çš„å±€éƒ¨å˜é‡

## ğŸ“Š å®é™…æ”¶ç›Š

é€šè¿‡è¿™ç§æµ‹è¯•æ–¹å¼ï¼Œæˆ‘ä»¬è·å¾—äº†ï¼š

1. **é‡æ„å®‰å…¨æ€§**ï¼šå¯ä»¥æ”¾å¿ƒé‡æ„å†…éƒ¨å®ç°
2. **è®¾è®¡æ”¹è¿›**ï¼šè‡ªç„¶é©±åŠ¨å‡ºæ›´å¥½çš„æ¥å£è®¾è®¡
3. **æµ‹è¯•ç¨³å®šæ€§**ï¼šå‡å°‘å› å®ç°å˜æ›´å¯¼è‡´çš„æµ‹è¯•ç»´æŠ¤æˆæœ¬
4. **å›¢é˜Ÿåä½œ**ï¼šæ¸…æ™°çš„å¥‘çº¦è®©å›¢é˜Ÿæˆå‘˜æ›´å®¹æ˜“ç†è§£å’Œä½¿ç”¨

è¿™å°±æ˜¯ä¼˜ç§€çš„å•å…ƒæµ‹è¯•åº”è¯¥å…·å¤‡çš„ç‰¹è´¨â€”â€”ä¸“æ³¨äºéªŒè¯è¡Œä¸ºå¥‘çº¦ï¼Œè€Œä¸æ˜¯å®ç°ç»†èŠ‚ã€‚

---

å½“ç„¶å¯ä»¥ï¼ä»¥ä¸‹æ˜¯ä¸€ä¸ª **Go è¯­è¨€å¼€å‘ä¸­çš„æ°å½“å®ä¾‹**ï¼Œå®Œç¾è¯ é‡Šï¼š

> **â€œå„ªè‰¯çš„æ¸¬è©¦æ‡‰è©²å°ˆæ³¨æ–¼é©—è­‰ä¸€å€‹å–®å…ƒï¼ˆUnitï¼‰å°å¤–çš„å…¬é–‹è¡Œç‚ºï¼Œè€Œéå…¶å…§éƒ¨å¦‚ä½•å¯¦ç¾é€™äº›è¡Œç‚ºã€‚é€™æ¨£ï¼Œç•¶å…§éƒ¨å¯¦ä½œéœ€è¦é‡æ§‹æ™‚ï¼Œåªè¦å¤–éƒ¨è¡Œç‚ºä¿æŒä¸è®Šï¼Œæ¸¬è©¦å°±ä¸æ‡‰è©²å¤±æ•—ã€‚â€**

---

## ğŸ¯ å®ä¾‹åœºæ™¯ï¼šè®¢å•ä»·æ ¼è®¡ç®—å™¨ï¼ˆOrder Price Calculatorï¼‰

æˆ‘ä»¬æœ‰ä¸€ä¸ª `Order` ç»“æ„ä½“å’Œä¸€ä¸ª `CalculateTotal()` æ–¹æ³•ï¼Œç”¨äºè®¡ç®—è®¢å•æ€»ä»·ï¼ˆå«ç¨ã€æŠ˜æ‰£ç­‰ï¼‰ã€‚  
æˆ‘ä»¬çš„æµ‹è¯•**åªå…³å¿ƒè¾“å…¥å’Œè¾“å‡º**ï¼Œä¸å…³å¿ƒå†…éƒ¨æ˜¯â€œæ€ä¹ˆç®—çš„â€ã€‚

---

## âœ… ç¬¬ä¸€é˜¶æ®µï¼šåˆå§‹å®ç° + è¡Œä¸ºæµ‹è¯•ï¼ˆBehavior-Based Testï¼‰

### ğŸ“„ `order.go`

```go
package order

type Order struct {
    Items []Item
}

type Item struct {
    Price    float64
    Quantity int
}

// CalculateTotal è®¡ç®—è®¢å•æ€»ä»·ï¼ˆå«ç¨ï¼‰
func (o *Order) CalculateTotal() float64 {
    subtotal := 0.0
    for _, item := range o.Items {
        subtotal += item.Price * float64(item.Quantity)
    }
    tax := subtotal * 0.1 // 10% ç¨
    return subtotal + tax
}
```

### ğŸ§ª `order_test.go` â€”â€” ä¼˜è‰¯æµ‹è¯•ï¼šåªæµ‹å…¬å¼€è¡Œä¸º

```go
package order

import "testing"

func TestOrder_CalculateTotal(t *testing.T) {
    tests := []struct {
        name     string
        order    Order
        expected float64
    }{
        {
            name: "single item",
            order: Order{
                Items: []Item{{Price: 100, Quantity: 1}},
            },
            expected: 110.0, // 100 + 10% tax = 110
        },
        {
            name: "multiple items",
            order: Order{
                Items: []Item{
                    {Price: 50, Quantity: 2},
                    {Price: 30, Quantity: 1},
                },
            },
            expected: 143.0, // (100 + 30) * 1.1 = 143
        },
        {
            name:     "empty order",
            order:    Order{},
            expected: 0.0,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := tt.order.CalculateTotal()
            if got != tt.expected {
                t.Errorf("CalculateTotal() = %v, want %v", got, tt.expected)
            }
        })
    }
}
```

âœ… **è¿™ä¸ªæµ‹è¯•åªå…³å¿ƒï¼šç»™å®šè¾“å…¥ â†’ æœŸæœ›è¾“å‡º**  
âœ… **å®Œå…¨ä¸å…³å¿ƒï¼šsubtotal æ˜¯æ€ä¹ˆç´¯åŠ çš„ã€tax æ˜¯æ€ä¹ˆç®—çš„ã€æœ‰æ²¡æœ‰ for å¾ªç¯**

---

## ğŸ”§ ç¬¬äºŒé˜¶æ®µï¼šå†…éƒ¨é‡æ„ â€”â€” ä¼˜åŒ–å®ç°æ–¹å¼ï¼ˆä¸å½±å“è¡Œä¸ºï¼‰

å‡è®¾æˆ‘ä»¬å‘ç°â€œå¤šæ¬¡ä¹˜æ³•æ•ˆç‡ä½â€ï¼Œæˆ–è€…â€œæƒ³æ”¯æŒæŠ˜æ‰£â€ï¼Œäºæ˜¯é‡æ„å†…éƒ¨å®ç°ï¼š

### ğŸ“„ `order.go` â€”â€” é‡æ„åï¼ˆæ–°å¢æŠ˜æ‰£ + ä¼˜åŒ–è®¡ç®—ï¼‰

```go
func (o *Order) CalculateTotal() float64 {
    // æ–°å¢ï¼šä¼šå‘˜äº«å— 9 æŠ˜ï¼ˆå‡è®¾æ‰€æœ‰è®¢å•é»˜è®¤æ˜¯ä¼šå‘˜ï¼‰
    discountRate := 0.9

    var total float64
    for _, item := range o.Items {
        total += item.Price * float64(item.Quantity)
    }

    // å…ˆæ‰“æŠ˜ï¼Œå†åŠ ç¨
    discounted := total * discountRate
    tax := discounted * 0.1
    return discounted + tax
}
```

> ğŸ’¡ æ³¨æ„ï¼šç°åœ¨è®¡ç®—é€»è¾‘å˜äº† â€”â€” **å…ˆæ‰“æŠ˜ï¼Œå†åŠ ç¨**ï¼ˆä¹‹å‰æ˜¯å…ˆåŠ ç¨ï¼‰  
> ä½†ä¸šåŠ¡å†³å®šï¼š**ä¼šå‘˜è®¢å•ä¸€å¾‹ 9 æŠ˜ï¼ŒæŠ˜æ‰£åœ¨ç¨å‰** â€”â€” æ‰€ä»¥å¤–éƒ¨è¡Œä¸ºï¼ˆæµ‹è¯•æœŸæœ›å€¼ï¼‰ä¹Ÿè¦è°ƒæ•´ï¼

---

## âš ï¸ é—®é¢˜æ¥äº†ï¼šå¦‚æœæµ‹è¯•å†™çš„æ˜¯â€œå†…éƒ¨å®ç°â€ï¼Œå°±ä¼šè¯¯æŠ¥å¤±è´¥ï¼

æ¯”å¦‚ï¼Œä¸€ä¸ª**å·®çš„æµ‹è¯•**å¯èƒ½è¿™æ ·å†™ï¼ˆé”™è¯¯ç¤ºèŒƒ âŒï¼‰ï¼š

```go
// âŒ é”™è¯¯æµ‹è¯•ï¼šéªŒè¯å†…éƒ¨å˜é‡ï¼ˆç´§è€¦åˆå®ç°ç»†èŠ‚ï¼‰
func TestOrder_CalculateTotal_Internals(t *testing.T) {
    o := Order{Items: []Item{{Price: 100, Quantity: 1}}}
    total := o.CalculateTotal()

    // å‡è®¾æµ‹è¯•çŸ¥é“â€œå†…éƒ¨ subtotal åº”è¯¥æ˜¯ 100â€
    // â€”â€” ä½†é‡æ„åï¼Œé€»è¾‘å˜äº†ï¼Œè¿™ä¸ªâ€œ100â€å¯èƒ½ä¸å­˜åœ¨äº†ï¼
    // è¿™ç§æµ‹è¯•ä¼šæ— æ„ä¹‰å¤±è´¥ï¼Œé˜»ç¢é‡æ„ï¼

    // æ›´ç³Ÿçš„æ˜¯ï¼šå¦‚æœæµ‹è¯•å»åå°„è¯»å–ç§æœ‰å­—æ®µ...
    // â€”â€” å®Œå…¨è¿èƒŒäº†â€œæµ‹è¯•å…¬å¼€è¡Œä¸ºâ€çš„åŸåˆ™ï¼
}
```

è¿™ç§æµ‹è¯•ä¼šåœ¨é‡æ„å**æ— æ„ä¹‰å¤±è´¥**ï¼Œå³ä½¿ä¸šåŠ¡è¡Œä¸ºæ˜¯æ­£ç¡®çš„ â€”â€” è¿™å°±æ˜¯â€œæµ‹è¯•é˜»ç¢é‡æ„â€çš„å…¸å‹åæ¨¡å¼ã€‚

---

## âœ… æ­£ç¡®åšæ³•ï¼šæ›´æ–°æµ‹è¯•çš„â€œæœŸæœ›è¡Œä¸ºâ€ï¼Œè€Œéâ€œæœŸæœ›å®ç°â€

æ—¢ç„¶ä¸šåŠ¡è§„åˆ™å˜äº†ï¼ˆä¼šå‘˜ 9 æŠ˜ï¼‰ï¼Œæˆ‘ä»¬**æ›´æ–°æµ‹è¯•ç”¨ä¾‹çš„ expected å€¼**å³å¯ï¼š

```go
{
    name: "single item with member discount",
    order: Order{
        Items: []Item{{Price: 100, Quantity: 1}},
    },
    expected: 99.0, // 100 * 0.9 = 90, + 10% tax = 99
},
```

ç„¶åè¿è¡Œæµ‹è¯•ï¼š

```bash
go test -v
```

âœ… **æµ‹è¯•é€šè¿‡ï¼**  
âœ… **é‡æ„æˆåŠŸï¼**  
âœ… **è¡Œä¸ºç¬¦åˆæ–°ä¸šåŠ¡è§„åˆ™ï¼**

---

## ğŸ§­ ä¸ºä»€ä¹ˆè¿™æ˜¯â€œä¼˜è‰¯æµ‹è¯•â€ï¼Ÿ

| ç‰¹æ€§ | è¯´æ˜ |
|------|------|
| **é»‘ç›’æµ‹è¯•** | åªç»™è¾“å…¥ï¼ŒéªŒè¾“å‡ºï¼Œä¸å…³å¿ƒå†…éƒ¨å˜é‡ã€ç®—æ³•ã€å¾ªç¯æ¬¡æ•° |
| **å®‰å…¨é‡æ„** | åªè¦è¾“å‡ºä¸å˜ï¼Œå†…éƒ¨æ€ä¹ˆæ”¹éƒ½è¡Œ â€”â€” æµ‹è¯•æ˜¯â€œå®‰å…¨ç½‘â€ï¼Œä¸æ˜¯â€œæ·é”â€ |
| **ä¸šåŠ¡å¯¼å‘** | æµ‹è¯•ç”¨ä¾‹åæ˜ çœŸå®ä¸šåŠ¡åœºæ™¯ï¼ˆå•å•†å“ã€å¤šå•†å“ã€ç©ºè®¢å•ï¼‰ |
| **æ˜“äºç»´æŠ¤** | éœ€æ±‚å˜æ›´æ—¶ï¼Œåªéœ€æ”¹ `expected` å€¼ï¼Œæ— éœ€é‡å†™æµ‹è¯•é€»è¾‘ |

---

## ğŸš« å¯¹æ¯”ï¼šå·®çš„æµ‹è¯•é•¿ä»€ä¹ˆæ ·ï¼Ÿï¼ˆåé¢æ•™æï¼‰

```go
// âŒ å·®çš„æµ‹è¯•ï¼šéªŒè¯å®ç°ç»†èŠ‚
func TestOrder_CalculateTotal_Bad(t *testing.T) {
    o := Order{Items: []Item{{Price: 100, Quantity: 1}}}

    // é”™è¯¯1ï¼šå‡è®¾çŸ¥é“ tax æ˜¯ 10%
    // â€”â€” å¦‚æœç¨ç‡æ”¹æˆ 8%ï¼Œæµ‹è¯•å¤±è´¥ï¼Œä½†ä¸šåŠ¡å¯èƒ½å…è®¸ï¼

    // é”™è¯¯2ï¼šè¯•å›¾éªŒè¯â€œå¾ªç¯æ¬¡æ•°â€
    // â€”â€” å¦‚æœæ”¹æˆé€’å½’æˆ–å¹¶å‘è®¡ç®—ï¼Œæµ‹è¯•å¤±è´¥ï¼Œä½†ç»“æœæ­£ç¡®ï¼

    // é”™è¯¯3ï¼šMock å†…éƒ¨ç§æœ‰æ–¹æ³•
    // â€”â€” Go è™½ä¸é¼“åŠ± Mock ç§æœ‰æ–¹æ³•ï¼Œä½†è‹¥ä½ ç”¨åå°„å¼ºè¡Œ Mockï¼Œé‡æ„æ—¶å¿…ç„¶å´©ï¼
}
```

è¿™ç§æµ‹è¯•ï¼š

- è„†å¼±ï¼ˆFragileï¼‰ï¼šæ”¹ä¸€è¡Œä»£ç å°±å´©
- éš¾ç»´æŠ¤ï¼šéœ€æ±‚ä¸€å˜ï¼Œæµ‹è¯•å…¨æ”¹
- é˜»ç¢é‡æ„ï¼šå¼€å‘è€…ä¸æ•¢ä¼˜åŒ–å®ç°ï¼Œæ€•â€œæµ‹è¯•å¤±è´¥â€

---

## ğŸ§© é¢å¤–åŠ åˆ†é¡¹ï¼šä½¿ç”¨ Table-Driven Test + æ¸…æ™°å‘½å

Go ç¤¾åŒºæ¨èçš„æµ‹è¯•é£æ ¼ï¼Œè®©è¡Œä¸ºæµ‹è¯•æ›´æ¸…æ™°ï¼š

```go
func TestOrder_CalculateTotal(t *testing.T) {
    testCases := map[string]struct {
        input    Order
        expected float64
    }{
        "ä¼šå‘˜å•å•†å“è®¢å•": {
            input: Order{Items: []Item{{Price: 100, Quantity: 1}}},
            expected: 99.0,
        },
        "ä¼šå‘˜å¤šå•†å“è®¢å•": {
            input: Order{
                Items: []Item{
                    {Price: 50, Quantity: 2},
                    {Price: 30, Quantity: 1},
                },
            },
            expected: 128.7, // (100+30)*0.9*1.1
        },
    }

    for name, tc := range testCases {
        t.Run(name, func(t *testing.T) {
            got := tc.input.CalculateTotal()
            if got != tc.expected {
                t.Errorf("æœŸæœ› %.2f, å®é™… %.2f", tc.expected, got)
            }
        })
    }
}
```

---

## âœ… æ€»ç»“ï¼šä¼˜è‰¯æµ‹è¯•çš„é»„é‡‘æ³•åˆ™

> **â€œæµ‹ä»€ä¹ˆï¼Ÿâ€”â€” æµ‹è¾“å…¥è¾“å‡ºã€‚  
> ä¸æµ‹ä»€ä¹ˆï¼Ÿâ€”â€” ä¸æµ‹å˜é‡ã€ä¸æµ‹å¾ªç¯ã€ä¸æµ‹ç§æœ‰æ–¹æ³•ã€ä¸æµ‹â€˜æ€ä¹ˆç®—çš„â€™ã€‚â€**

åœ¨ Go é¡¹ç›®ä¸­ï¼ŒåšæŒè¿™ä¸ªåŸåˆ™ï¼Œä½ å°†è·å¾—ï¼š

- âœ… å®‰å…¨é‡æ„çš„è‡ªç”±
- âœ… é«˜å¯ç»´æŠ¤çš„æµ‹è¯•å¥—ä»¶
- âœ… ä¸äº§å“/ä¸šåŠ¡å¯¹é½çš„éªŒæ”¶æ ‡å‡†
- âœ… å›¢é˜Ÿåä½œæ—¶çš„æ¸…æ™°å¥‘çº¦

---

> ğŸ’¡ **è®°ä½ï¼šæµ‹è¯•ä¸æ˜¯ä»£ç çš„â€œç›‘å·¥â€ï¼Œè€Œæ˜¯è¡Œä¸ºçš„â€œå¥‘çº¦â€ã€‚åªè¦å¥‘çº¦ä¸å˜ï¼Œå®ç°çˆ±æ€ä¹ˆæ”¹å°±æ€ä¹ˆæ”¹ã€‚**

---

å¦‚éœ€ï¼Œæˆ‘å¯ä¸ºä½ æä¾›ï¼š

- âœ… Go é¡¹ç›®ä¸­â€œè¡Œä¸ºæµ‹è¯• vs å®ç°æµ‹è¯•â€çš„å®Œæ•´å¯¹æ¯”æ¨¡æ¿
- âœ… å¦‚ä½•ç”¨ `testify/assert` å†™æ›´ä¼˜é›…çš„è¡Œä¸ºæµ‹è¯•
- âœ… åœ¨ CI/CD ä¸­é…ç½®æµ‹è¯•è¦†ç›–ç‡æŠ¥å‘Šï¼ˆåªå…³æ³¨å…¬å…±æ–¹æ³•ï¼‰
- âœ… å¦‚ä½•ç”¨â€œå¥‘çº¦æµ‹è¯•â€æ›¿ä»£â€œMock å†…éƒ¨ä¾èµ–â€

**ç•™è¨€å‘Šè¯‰æˆ‘ä½ éœ€è¦å“ªä¸€é¡¹ï¼Œæˆ‘ç«‹åˆ»ä¸ºä½ ç”Ÿæˆï¼**

ç°åœ¨ï¼Œæ‰“å¼€ä½ çš„ `_test.go` æ–‡ä»¶ï¼Œæ£€æŸ¥ä¸€ä¸‹ï¼šä½ çš„æµ‹è¯•ï¼Œæ˜¯åœ¨éªŒè¯â€œè¡Œä¸ºâ€ï¼Œè¿˜æ˜¯åœ¨çª¥æ¢â€œå®ç°â€ï¼ŸğŸ§ªğŸ”

---

# ğŸŒŸ æµ‹è¯•è®¾è®¡åŸåˆ™ï¼šå…³æ³¨å…¬å¼€è¡Œä¸ºè€Œéå†…éƒ¨å®ç°

## ğŸ’¡ æ ¸å¿ƒåŸåˆ™
> **"æµ‹è¯•åº”è¯¥éªŒè¯å•å…ƒå¯¹å¤–çš„å¥‘çº¦ï¼ˆè¾“å…¥/è¾“å‡ºï¼‰ï¼Œè€Œéå†…éƒ¨å¦‚ä½•å®ç°è¿™äº›è¡Œä¸ºã€‚è¿™æ ·å½“å†…éƒ¨å®ç°é‡æ„æ—¶ï¼Œåªè¦å¤–éƒ¨è¡Œä¸ºä¿æŒä¸å˜ï¼Œæµ‹è¯•å°±ä¸åº”è¯¥å¤±è´¥ã€‚"**

## âœ… å®ä¾‹ï¼šHTTP æœåŠ¡ä¸­çš„ç”¨æˆ·æ³¨å†ŒåŠŸèƒ½

### åœºæ™¯æè¿°
æˆ‘ä»¬æœ‰ä¸€ä¸ªç”¨æˆ·æ³¨å†ŒæœåŠ¡ï¼Œå®ƒæ¥æ”¶ç”¨æˆ·åå’Œå¯†ç ï¼Œè¿›è¡ŒéªŒè¯ã€åŠ å¯†å­˜å‚¨ï¼Œç„¶åè¿”å›ç”¨æˆ·IDã€‚è¿™ä¸ªæœåŠ¡ä¾èµ–æ•°æ®åº“å­˜å‚¨ç”¨æˆ·æ•°æ®ã€‚

### ğŸš« é”™è¯¯çš„æµ‹è¯•æ–¹å¼ï¼ˆæµ‹è¯•å†…éƒ¨å®ç°ç»†èŠ‚ï¼‰

```go
func TestRegisterUser_UsesBcryptForHashing(t *testing.T) {
    // é”™è¯¯ï¼æµ‹è¯•å†…éƒ¨å®ç°ç»†èŠ‚
    service := NewUserService()
    
    // è¯•å›¾æ£€æŸ¥æ˜¯å¦ä½¿ç”¨äº†bcryptåº“
    // ä½†Goä¸­æ— æ³•ç›´æ¥æ£€æŸ¥å‡½æ•°è°ƒç”¨ç»†èŠ‚
    // è¿™ç§æµ‹è¯•å®Œå…¨æ— æ•ˆ
}
```

```go
func TestRegisterUser_CallsDatabaseWithSpecificSQL(t *testing.T) {
    // é”™è¯¯ï¼æµ‹è¯•å†…éƒ¨SQLå®ç°ç»†èŠ‚
    db, mock := sqlmock.New()
    defer db.Close()
    
    service := NewUserService(db)
    
    // æµ‹è¯•å…³æ³¨äº†å…·ä½“çš„SQLè¯­å¥
    mock.ExpectExec("INSERT INTO users (username, password) VALUES (?, ?)").
        WithArgs("testuser", "hashed_password").
        WillReturnResult(sqlmock.NewResult(1, 1))
    
    // å³ä½¿å†…éƒ¨å®ç°æ”¹ä¸ºä½¿ç”¨ORMæˆ–ä¸åŒSQLè¯­æ³•ï¼Œè¿™ä¸ªæµ‹è¯•å°±ä¼šå¤±è´¥
    _, err := service.RegisterUser("testuser", "password123")
    if err != nil {
        t.Fatalf("expected no error, got %v", err)
    }
}
```

> âš ï¸ é—®é¢˜ï¼šè¿™ä¸ªæµ‹è¯•**ç»‘å®šäº†å…·ä½“çš„SQLè¯­å¥å’Œæ•°æ®åº“æ“ä½œæ–¹å¼**ã€‚å¦‚æœå°†æ¥å°†å®ç°æ”¹ä¸ºä½¿ç”¨GORM ORMã€æˆ–ä¿®æ”¹äº†è¡¨ç»“æ„ã€æˆ–æ”¹ç”¨NoSQLæ•°æ®åº“ï¼Œå³ä½¿ç”¨æˆ·æ³¨å†ŒåŠŸèƒ½ä¾ç„¶æ­£å¸¸å·¥ä½œï¼Œè¿™ä¸ªæµ‹è¯•ä¹Ÿä¼šå¤±è´¥ã€‚

---

### âœ… æ­£ç¡®çš„æµ‹è¯•æ–¹å¼ï¼ˆå…³æ³¨å…¬å¼€è¡Œä¸ºï¼‰

```go
func TestRegisterUser_ReturnsUserIDOnSuccess(t *testing.T) {
    // åˆ›å»ºMockä»“åº“ï¼ˆåªå…³æ³¨æ¥å£è¡Œä¸ºï¼Œä¸å…³å¿ƒå†…éƒ¨å®ç°ï¼‰
    mockRepo := &MockUserRepository{
        SaveUserFn: func(user User) error {
            user.ID = 123  // æ¨¡æ‹Ÿæ•°æ®åº“è¿”å›çš„ID
            return nil
        },
    }
    
    // åˆ›å»ºæœåŠ¡ï¼ˆä¾èµ–æ³¨å…¥ï¼‰
    service := NewUserService(mockRepo)
    
    // æµ‹è¯•å…¬å¼€è¡Œä¸ºï¼šè¾“å…¥ç”¨æˆ·åå¯†ç ï¼ŒæœŸæœ›è¿”å›æœ‰æ•ˆç”¨æˆ·ID
    user, err := service.RegisterUser("testuser", "password123")
    if err != nil {
        t.Fatalf("expected no error, got %v", err)
    }
    
    // éªŒè¯è¿”å›çš„ç”¨æˆ·IDæ˜¯å¦ç¬¦åˆé¢„æœŸ
    if user.ID != 123 {
        t.Errorf("expected ID 123, got %d", user.ID)
    }
}
```

```go
func TestRegisterUser_ReturnsValidationErrorForWeakPassword(t *testing.T) {
    mockRepo := &MockUserRepository{}
    service := NewUserService(mockRepo)
    
    // æµ‹è¯•å…¬å¼€è¡Œä¸ºï¼šè¾“å…¥å¼±å¯†ç ï¼ŒæœŸæœ›è¿”å›éªŒè¯é”™è¯¯
    _, err := service.RegisterUser("testuser", "short")
    if err == nil {
        t.Error("expected validation error for weak password, got nil")
    }
    
    // éªŒè¯é”™è¯¯å†…å®¹ï¼ˆå…³æ³¨å¥‘çº¦ï¼Œä¸å…³æ³¨å†…éƒ¨å¦‚ä½•ç”Ÿæˆé”™è¯¯ï¼‰
    if !strings.Contains(err.Error(), "password must be at least 8 characters") {
        t.Errorf("expected error message containing 'password must be at least 8 characters', got %v", err)
    }
}
```

---

## ğŸ” ä¸ºä»€ä¹ˆè¿™ä¸ªæµ‹è¯•æ˜¯"æ­£ç¡®"çš„ï¼Ÿ

| æµ‹è¯•æ–¹é¢ | é”™è¯¯æµ‹è¯• | æ­£ç¡®æµ‹è¯• |
|----------|----------|----------|
| **å…³æ³¨ç‚¹** | å†…éƒ¨SQLè¯­å¥ã€å…·ä½“å“ˆå¸Œç®—æ³• | å…¬å¼€è¡Œä¸ºï¼ˆè¾“å…¥/è¾“å‡ºï¼‰ |
| **é‡æ„å½±å“** | å¦‚æœæ”¹ç”¨GORMæˆ–ä¸åŒSQLè¯­æ³•ï¼Œæµ‹è¯•å¤±è´¥ | æ— è®ºå†…éƒ¨å¦‚ä½•å®ç°ï¼Œåªè¦è¿”å›ç›¸åŒç»“æœï¼Œæµ‹è¯•é€šè¿‡ |
| **æµ‹è¯•ç›®çš„** | éªŒè¯"å¦‚ä½•åš" | éªŒè¯"åšä»€ä¹ˆ" |
| **å¯ç»´æŠ¤æ€§** | ä½ï¼ˆæ¯æ¬¡å†…éƒ¨å˜æ›´éƒ½éœ€è¦ä¿®æ”¹æµ‹è¯•ï¼‰ | é«˜ï¼ˆæµ‹è¯•åªå…³æ³¨å¥‘çº¦ï¼Œä¸å…³å¿ƒå®ç°ï¼‰ |

---

## ğŸŒˆ å®é™…é‡æ„åœºæ™¯éªŒè¯

### åœºæ™¯ï¼šå°†ç›´æ¥SQLæ“ä½œæ”¹ä¸ºä½¿ç”¨GORM ORM

**é‡æ„å‰ï¼ˆç›´æ¥SQLï¼‰**ï¼š
```go
func (s *UserService) RegisterUser(username, password string) (User, error) {
    // éªŒè¯å¯†ç 
    if err := validatePassword(password); err != nil {
        return User{}, err
    }
    
    // ç›´æ¥SQLæ“ä½œ
    hashed, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return User{}, err
    }
    
    _, err = s.db.Exec(
        "INSERT INTO users (username, password) VALUES (?, ?)",
        username,
        hashed,
    )
    if err != nil {
        return User{}, err
    }
    
    return User{ID: 123}, nil
}
```

**é‡æ„åï¼ˆä½¿ç”¨GORM ORMï¼‰**ï¼š
```go
func (s *UserService) RegisterUser(username, password string) (User, error) {
    // éªŒè¯å¯†ç ï¼ˆä¸å˜ï¼‰
    if err := validatePassword(password); err != nil {
        return User{}, err
    }
    
    // ä½¿ç”¨GORMä¿å­˜
    hashed, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return User{}, err
    }
    
    user := User{Username: username, Password: string(hashed)}
    if err := s.db.Create(&user).Error; err != nil {
        return User{}, err
    }
    
    return user, nil
}
```

### ğŸŸ¢ æµ‹è¯•ç»“æœ
- **é”™è¯¯æµ‹è¯•**ï¼ˆæµ‹è¯•å…·ä½“SQLè¯­å¥ï¼‰ï¼š**å¤±è´¥**ï¼Œå› ä¸ºSQLè¯­å¥å˜äº†
- **æ­£ç¡®æµ‹è¯•**ï¼ˆå…³æ³¨å…¬å¼€è¡Œä¸ºï¼‰ï¼š**é€šè¿‡**ï¼Œå› ä¸ºï¼š
  - è¾“å…¥ï¼š`username="testuser", password="password123"`
  - è¾“å‡ºï¼šè¿”å›äº†ID=123çš„ç”¨æˆ·ï¼Œä¸”æ²¡æœ‰é”™è¯¯

---

## ğŸ’¡ ä¸ºä»€ä¹ˆè¿™ä¸ªåŸåˆ™å¦‚æ­¤é‡è¦ï¼Ÿ

> **"æµ‹è¯•ä¸æ˜¯ä¸ºäº†éªŒè¯ä»£ç å¦‚ä½•å·¥ä½œï¼Œè€Œæ˜¯ä¸ºäº†éªŒè¯ä»£ç åšä»€ä¹ˆ"**

å½“æµ‹è¯•å…³æ³¨**å…¬å¼€è¡Œä¸º**è€Œé**å†…éƒ¨å®ç°**æ—¶ï¼š
1. **é‡æ„æ›´å®‰å…¨**ï¼šå¯ä»¥æ”¾å¿ƒåœ°ä¼˜åŒ–å†…éƒ¨å®ç°ï¼Œè€Œä¸å¿…æ‹…å¿ƒæµ‹è¯•å¤±è´¥
2. **ä»£ç æ›´çµæ´»**ï¼šå¯ä»¥è‡ªç”±æ›¿æ¢åº•å±‚æŠ€æœ¯æ ˆï¼ˆå¦‚ä»SQLæ”¹ç”¨NoSQLã€ä»ç›´æ¥SQLæ”¹ç”¨ORMï¼‰
3. **æµ‹è¯•æ›´ç¨³å®š**ï¼šæµ‹è¯•ç”¨ä¾‹ä¸ä¼šå› ä¸ºå†…éƒ¨å®ç°ç»†èŠ‚å˜æ›´è€Œå¤±æ•ˆ
4. **è®¾è®¡æ›´æ¸…æ™°**ï¼šè¿«ä½¿å¼€å‘è€…å®šä¹‰æ¸…æ™°çš„æ¥å£å¥‘çº¦

---

## ğŸš€ å®æˆ˜å»ºè®®ï¼šå¦‚ä½•å†™å…³æ³¨å…¬å¼€è¡Œä¸ºçš„æµ‹è¯•

1. **ä½¿ç”¨Mockå¯¹è±¡**ï¼šåªæ¨¡æ‹Ÿæ¥å£è¡Œä¸ºï¼Œä¸å…³å¿ƒå†…éƒ¨å®ç°
   ```go
   type MockUserRepository struct {
       SaveUserFn func(user User) error
   }
   
   func (m *MockUserRepository) SaveUser(user User) error {
       return m.SaveUserFn(user)
   }
   ```

2. **æµ‹è¯•è¾“å…¥/è¾“å‡º**ï¼š
   ```go
   // æµ‹è¯•è¾“å…¥ï¼šç”¨æˆ·åã€å¯†ç 
   // æµ‹è¯•è¾“å‡ºï¼šç”¨æˆ·IDã€é”™è¯¯ä¿¡æ¯
   user, err := service.RegisterUser("test", "password123")
   assert.NoError(t, err)
   assert.Equal(t, 123, user.ID)
   ```

3. **ä½¿ç”¨è¡¨æ ¼é©±åŠ¨æµ‹è¯•**ï¼ˆTable-Driven Testsï¼‰ï¼š
   ```go
   tests := []struct {
       name     string
       username string
       password string
       expectedID int
       expectError bool
       errorMsg string
   }{
       {"valid", "test", "ComplexPass123!", 123, false, ""},
       {"weak_password", "test", "short", 0, true, "password must be at least 8 characters"},
   }
   
   for _, tt := range tests {
       t.Run(tt.name, func(t *testing.T) {
           user, err := service.RegisterUser(tt.username, tt.password)
           if tt.expectError {
               assert.Error(t, err)
               assert.Contains(t, err.Error(), tt.errorMsg)
           } else {
               assert.NoError(t, err)
               assert.Equal(t, tt.expectedID, user.ID)
           }
       })
   }
   ```

> ğŸ’¬ **çœŸå®å¼€å‘è€…ç»éªŒ**ï¼š  
> "å½“æˆ‘å¼€å§‹å…³æ³¨å…¬å¼€è¡Œä¸ºè€Œéå†…éƒ¨å®ç°æ—¶ï¼Œæˆ‘çš„æµ‹è¯•ä»'è„†å¼±çš„'å˜æˆäº†'å¯é çš„'ã€‚  
> ç°åœ¨æˆ‘å¯ä»¥æ”¾å¿ƒé‡æ„ä»£ç ï¼Œå› ä¸ºæµ‹è¯•åªå…³å¿ƒ'åšä»€ä¹ˆ'ï¼Œä¸å…³å¿ƒ'æ€ä¹ˆåš'ã€‚  
> è¿™è®©æˆ‘æœ‰æ›´å¤šè‡ªç”±å»ä¼˜åŒ–ä»£ç ï¼Œè€Œä¸å¿…æ‹…å¿ƒç ´åæµ‹è¯•ã€‚"  
> â€”â€” æŸå¤§å‹Goé¡¹ç›®æ¶æ„å¸ˆ


---

# ğŸŒŸ å•å…ƒè®¾è®¡ä¸æµ‹è¯•çš„è‰¯æ€§å¾ªç¯ï¼šä¸€ä¸ªGoè¯­è¨€å®æˆ˜æ¡ˆä¾‹

## ğŸ’¡ æ ¸å¿ƒè§‚ç‚¹
> **"å•å…ƒè®¾è®¡çš„ä¼˜åŠ£ç›´æ¥å½±å“æµ‹è¯•çš„éš¾æ˜“åº¦å’Œä»·å€¼ã€‚å¥½çš„å•å…ƒè®¾è®¡è®©æµ‹è¯•è‡ªç„¶èšç„¦äºè¡Œä¸ºï¼Œè€ŒTDDçš„è¿‡ç¨‹åè¿‡æ¥åˆä¼šé©±åŠ¨æˆ‘ä»¬è¿›è¡Œæ›´å¥½çš„å•å…ƒè®¾è®¡ã€‚"**

ä¸‹é¢é€šè¿‡ä¸€ä¸ª**ç”¨æˆ·æ³¨å†ŒæœåŠ¡**çš„å®ä¾‹ï¼Œå±•ç¤ºä»**ç³Ÿç³•è®¾è®¡ â†’ TDDé©±åŠ¨é‡æ„ â†’ è‰¯å¥½è®¾è®¡**çš„å®Œæ•´è¿‡ç¨‹ï¼Œä»¥åŠæµ‹è¯•å¦‚ä½•éšä¹‹å˜å¾—ç®€å•ã€èšç„¦ä¸”å¯é ã€‚

---

## ğŸš« åˆå§‹è®¾è®¡ï¼šç³Ÿç³•çš„å•å…ƒè®¾è®¡ï¼ˆä½å†…èšã€é«˜è€¦åˆï¼‰

### 1ï¸âƒ£ æœåŠ¡ä»£ç ï¼ˆç›´æ¥å¤„ç†æ‰€æœ‰ç»†èŠ‚ï¼‰
```go
// ä¸è‰¯è®¾è®¡ï¼šä¸€ä¸ªæœåŠ¡ç±»åŒæ—¶å¤„ç†ä¸šåŠ¡é€»è¾‘ã€æ•°æ®åº“æ“ä½œã€æ—¥å¿—è®°å½•
type UserService struct {
    db *sql.DB
}

func (u *UserService) RegisterUser(username, password string) (int, error) {
    // 1. éªŒè¯å¯†ç 
    if len(password) < 8 {
        return 0, errors.New("password too short")
    }
    
    // 2. ç›´æ¥è°ƒç”¨bcryptè¿›è¡Œå“ˆå¸Œ
    hashed, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return 0, err
    }
    
    // 3. ç›´æ¥æ‰§è¡ŒSQLæ’å…¥
    result, err := u.db.Exec("INSERT INTO users (username, password) VALUES (?, ?)", username, hashed)
    if err != nil {
        return 0, err
    }
    
    id, err := result.LastInsertId()
    if err != nil {
        return 0, err
    }
    
    return int(id), nil
}
```

### 2ï¸âƒ£ æµ‹è¯•ä»£ç ï¼ˆå¤æ‚ä¸”è„†å¼±ï¼‰
```go
func TestRegisterUser_BadDesign(t *testing.T) {
    // 1. åˆ›å»ºæ•°æ®åº“è¿æ¥å’Œæ¨¡æ‹Ÿ
    db, mock := sqlmock.New()
    defer db.Close()
    
    // 2. è®¾ç½®SQLæŸ¥è¯¢æœŸæœ›ï¼ˆå…³æ³¨å†…éƒ¨å®ç°ç»†èŠ‚ï¼‰
    mock.ExpectExec("INSERT INTO users").
        WithArgs("testuser", "hashed_password").
        WillReturnResult(sqlmock.NewResult(1, 1))
    
    // 3. åˆ›å»ºæœåŠ¡
    service := UserService{db: db}
    
    // 4. æµ‹è¯•
    id, err := service.RegisterUser("testuser", "password123")
    
    // 5. éªŒè¯
    if err != nil {
        t.Fatal("expected no error, got", err)
    }
    if id != 1 {
        t.Errorf("expected id 1, got %d", id)
    }
    
    // 6. éªŒè¯æ‰€æœ‰æœŸæœ›éƒ½æ»¡è¶³
    if err := mock.ExpectationsWereMet(); err != nil {
        t.Errorf("unfulfilled expectations: %s", err)
    }
}
```

### âš ï¸ é—®é¢˜åˆ†æï¼ˆä¸ºä»€ä¹ˆè¿™ä¸ªè®¾è®¡ç³Ÿç³•ï¼Ÿï¼‰

| é—®é¢˜ | å…·ä½“è¡¨ç° | å½±å“ |
|------|----------|------|
| **é«˜è€¦åˆ** | æœåŠ¡ç±»ç›´æ¥ä¾èµ–å…·ä½“æ•°æ®åº“å®ç°ã€bcryptåº“ | æ— æ³•ç‹¬ç«‹æµ‹è¯•ï¼Œå¿…é¡»å¯åŠ¨çœŸå®æ•°æ®åº“ |
| **ä½å†…èš** | åŒä¸€ä¸ªç±»å¤„ç†éªŒè¯ã€å“ˆå¸Œã€æ•°æ®åº“æ“ä½œ | ä¿®æ”¹ä»»æ„éƒ¨åˆ†éƒ½å¯èƒ½å½±å“å…¶ä»–åŠŸèƒ½ |
| **æµ‹è¯•è„†å¼±** | æµ‹è¯•å…³æ³¨SQLè¯­å¥ã€å…·ä½“å“ˆå¸Œç®—æ³•ç­‰å†…éƒ¨ç»†èŠ‚ | ä»»ä½•å†…éƒ¨å®ç°å˜æ›´éƒ½ä¼šå¯¼è‡´æµ‹è¯•å¤±è´¥ |
| **éš¾ä»¥æ‰©å±•** | æƒ³è¦æ›´æ¢å“ˆå¸Œç®—æ³•æˆ–æ•°æ®åº“ç±»å‹ï¼Ÿå¿…é¡»ä¿®æ”¹æœåŠ¡ç±» | é‡æ„æˆæœ¬é«˜ï¼Œé£é™©å¤§ |

> ğŸ“Œ **å…³é”®é—®é¢˜**ï¼š**æµ‹è¯•ä¸æ˜¯åœ¨éªŒè¯"åšä»€ä¹ˆ"ï¼Œè€Œæ˜¯åœ¨éªŒè¯"æ€ä¹ˆåš"**ã€‚æµ‹è¯•å…³æ³¨äº†å…·ä½“SQLè¯­å¥ã€å…·ä½“å“ˆå¸Œç®—æ³•ç­‰å†…éƒ¨å®ç°ç»†èŠ‚ï¼Œè€Œéå…³æ³¨æœåŠ¡çš„**å…¬å¼€è¡Œä¸º**ï¼ˆè¾“å…¥/è¾“å‡ºï¼‰ã€‚

---

## ğŸ”„ TDDé©±åŠ¨é‡æ„ï¼šä»ç³Ÿç³•è®¾è®¡åˆ°è‰¯å¥½è®¾è®¡

### 1ï¸âƒ£ ç¬¬ä¸€æ­¥ï¼šç¼–å†™æµ‹è¯•ï¼Œå‘ç°è®¾è®¡é—®é¢˜

å½“æˆ‘ä»¬å°è¯•æµ‹è¯•`RegisterUser`æ—¶ï¼Œå‘ç°ï¼š
- éœ€è¦æ¨¡æ‹ŸSQLæ•°æ®åº“è¿æ¥
- éœ€è¦è®¾ç½®å…·ä½“çš„SQLè¯­å¥æœŸæœ›
- éœ€è¦å¤„ç†bcryptå“ˆå¸Œçš„ç»†èŠ‚

> ğŸ’¡ **TDDé»„é‡‘æ³•åˆ™**ï¼š**"å½“æµ‹è¯•éš¾ä»¥ç¼–å†™æ—¶ï¼Œè¯´æ˜è®¾è®¡æœ‰é—®é¢˜"**

### 2ï¸âƒ£ ç¬¬äºŒæ­¥ï¼šé€šè¿‡TDDé©±åŠ¨æ‹†åˆ†èŒè´£

#### ğŸŸ¢ é‡æ„1ï¼šæå–å¯†ç éªŒè¯å™¨ï¼ˆç‹¬ç«‹å•å…ƒï¼‰

**æµ‹è¯•æ–‡ä»¶ï¼š`password_validator_test.go`**
```go
func TestPasswordValidator_Validate(t *testing.T) {
    validator := PasswordValidator{}
    
    // æµ‹è¯•çŸ­å¯†ç 
    err := validator.Validate("short")
    if err == nil {
        t.Error("expected error for short password, got nil")
    }
    
    // æµ‹è¯•é•¿å¯†ç 
    err = validator.Validate("longpassword123")
    if err != nil {
        t.Errorf("expected no error, got %v", err)
    }
}
```

**å®ç°æ–‡ä»¶ï¼š`password_validator.go`**
```go
type PasswordValidator struct{}

func (p *PasswordValidator) Validate(password string) error {
    if len(password) < 8 {
        return errors.New("password too short")
    }
    return nil
}
```

#### ğŸŸ¢ é‡æ„2ï¼šæå–å¯†ç å“ˆå¸Œå™¨ï¼ˆç‹¬ç«‹å•å…ƒï¼‰

**æµ‹è¯•æ–‡ä»¶ï¼š`password_hasher_test.go`**
```go
func TestPasswordHasher_Hash(t *testing.T) {
    hasher := PasswordHasher{}
    
    hashed, err := hasher.Hash("password123")
    if err != nil {
        t.Fatalf("expected no error, got %v", err)
    }
    
    // éªŒè¯å“ˆå¸Œç»“æœä¸æ˜¯æ˜æ–‡
    if hashed == "password123" {
        t.Error("expected hashed password, got plain text")
    }
}
```

**å®ç°æ–‡ä»¶ï¼š`password_hasher.go`**
```go
type PasswordHasher struct{}

func (p *PasswordHasher) Hash(password string) (string, error) {
    hashed, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return "", err
    }
    return string(hashed), nil
}
```

#### ğŸŸ¢ é‡æ„3ï¼šæå–ä»“åº“æ¥å£ï¼ˆæŠ½è±¡æ•°æ®åº“æ“ä½œï¼‰

**æ¥å£å®šä¹‰ï¼š`user_repository.go`**
```go
type UserRepository interface {
    SaveUser(username, hashedPassword string) (int, error)
}
```

**æµ‹è¯•æ–‡ä»¶ï¼š`user_repository_test.go`ï¼ˆä½¿ç”¨mockï¼‰**
```go
type MockUserRepository struct {
    SaveUserFn func(username, hashedPassword string) (int, error)
}

func (m *MockUserRepository) SaveUser(username, hashedPassword string) (int, error) {
    return m.SaveUserFn(username, hashedPassword)
}

func TestMockUserRepository_SaveUser(t *testing.T) {
    repo := &MockUserRepository{
        SaveUserFn: func(username, hashedPassword string) (int, error) {
            return 123, nil
        },
    }
    
    id, err := repo.SaveUser("testuser", "hashed_password")
    if err != nil {
        t.Fatal("expected no error, got", err)
    }
    if id != 123 {
        t.Errorf("expected id 123, got %d", id)
    }
}
```

### 3ï¸âƒ£ ç¬¬ä¸‰æ­¥ï¼šé‡æ„æœåŠ¡ç±»ï¼ˆä¾èµ–æ³¨å…¥ï¼‰

**æœåŠ¡ä»£ç ï¼š`user_service.go`**
```go
type UserService struct {
    validator PasswordValidator
    hasher    PasswordHasher
    repo      UserRepository
}

func (u *UserService) RegisterUser(username, password string) (int, error) {
    // 1. éªŒè¯å¯†ç 
    if err := u.validator.Validate(password); err != nil {
        return 0, err
    }
    
    // 2. å“ˆå¸Œå¯†ç 
    hashed, err := u.hasher.Hash(password)
    if err != nil {
        return 0, err
    }
    
    // 3. ä¿å­˜ç”¨æˆ·
    return u.repo.SaveUser(username, hashed)
}
```

**æµ‹è¯•æ–‡ä»¶ï¼š`user_service_test.go`ï¼ˆç°åœ¨å˜å¾—ç®€å•ï¼ï¼‰**
```go
func TestUserService_RegisterUser_Success(t *testing.T) {
    // åˆ›å»ºmockä»“åº“
    repo := &MockUserRepository{
        SaveUserFn: func(username, hashedPassword string) (int, error) {
            return 123, nil
        },
    }
    
    // åˆ›å»ºæœåŠ¡ï¼ˆä¾èµ–æ³¨å…¥ï¼‰
    service := UserService{
        validator: PasswordValidator{},
        hasher:    PasswordHasher{},
        repo:      repo,
    }
    
    // æµ‹è¯•æ³¨å†Œ
    id, err := service.RegisterUser("testuser", "password123")
    
    // éªŒè¯ï¼ˆåªå…³æ³¨å…¬å¼€è¡Œä¸ºï¼ï¼‰
    if err != nil {
        t.Fatalf("expected no error, got %v", err)
    }
    if id != 123 {
        t.Errorf("expected id 123, got %d", id)
    }
}
```

---

## âœ… é‡æ„åçš„å¯¹æ¯”ï¼šå•å…ƒè®¾è®¡å¦‚ä½•å½±å“æµ‹è¯•

| æ–¹é¢ | é‡æ„å‰ | é‡æ„å | ä¸ºä»€ä¹ˆæ›´å¥½ |
|------|--------|--------|------------|
| **æµ‹è¯•å¤æ‚åº¦** | éœ€è¦æ¨¡æ‹ŸSQLè¿æ¥ã€è®¾ç½®å…·ä½“SQLè¯­å¥ | åªéœ€å…³æ³¨æ¥å£è¡Œä¸ºï¼Œæ— éœ€å…³å¿ƒå…·ä½“å®ç° | æµ‹è¯•ä»£ç æ›´ç®€å•ã€æ›´æ˜“ç»´æŠ¤ |
| **æµ‹è¯•èšç„¦ç‚¹** | å…³æ³¨å†…éƒ¨å®ç°ç»†èŠ‚ï¼ˆSQLè¯­å¥ã€å“ˆå¸Œç®—æ³•ï¼‰ | å…³æ³¨å…¬å¼€è¡Œä¸ºï¼ˆè¾“å…¥/è¾“å‡ºï¼‰ | æµ‹è¯•éªŒè¯"åšä»€ä¹ˆ"è€Œé"æ€ä¹ˆåš" |
| **æµ‹è¯•ç¨³å®šæ€§** | ä»»ä½•å†…éƒ¨å®ç°å˜æ›´éƒ½ä¼šå¯¼è‡´æµ‹è¯•å¤±è´¥ | åªè¦è¡Œä¸ºä¸å˜ï¼Œæµ‹è¯•å§‹ç»ˆé€šè¿‡ | é‡æ„æ›´å®‰å…¨ï¼Œæµ‹è¯•ä¸ä¼šæˆä¸ºè´Ÿæ‹… |
| **ä»£ç å¯ç»´æŠ¤æ€§** | ä½ï¼ˆä¿®æ”¹ä»»æ„éƒ¨åˆ†å¯èƒ½å½±å“å…¶ä»–åŠŸèƒ½ï¼‰ | é«˜ï¼ˆæ¯ä¸ªå•å…ƒåªè´Ÿè´£å•ä¸€èŒè´£ï¼‰ | æ›´å®¹æ˜“æ‰©å±•å’Œä¿®æ”¹ |
| **è®¾è®¡è´¨é‡** | ä½å†…èšã€é«˜è€¦åˆ | é«˜å†…èšã€ä½è€¦åˆ | ç¬¦åˆSOLIDåŸåˆ™ |

---

## ğŸŒˆ TDDå¦‚ä½•é©±åŠ¨æ›´å¥½çš„è®¾è®¡ï¼ˆå…³é”®æ´å¯Ÿï¼‰

### ğŸ’¡ 1. **"å½“æµ‹è¯•éš¾ä»¥ç¼–å†™æ—¶ï¼Œè¯´æ˜è®¾è®¡æœ‰é—®é¢˜"**
- åˆå§‹è®¾è®¡ä¸­ï¼Œæµ‹è¯•éœ€è¦æ¨¡æ‹ŸSQLè¿æ¥ã€è®¾ç½®å…·ä½“SQLè¯­å¥ â†’ æç¤ºæˆ‘ä»¬è®¾è®¡æœ‰é—®é¢˜
- TDDè¿«ä½¿æˆ‘ä»¬æ€è€ƒï¼š**å¦‚ä½•è®©æµ‹è¯•æ›´å®¹æ˜“ç¼–å†™ï¼Ÿ** â†’ ç­”æ¡ˆæ˜¯**æ‹†åˆ†èŒè´£ã€æŠ½è±¡æ¥å£**

### ğŸ’¡ 2. **"æµ‹è¯•é©±åŠ¨æ¥å£è®¾è®¡"**
- ä¸ºäº†æµ‹è¯•æœåŠ¡ç±»ï¼Œæˆ‘ä»¬éœ€è¦æ¨¡æ‹Ÿæ•°æ®åº“æ“ä½œ â†’ è¿™è‡ªç„¶å¼•å¯¼æˆ‘ä»¬åˆ›å»º`UserRepository`æ¥å£
- æ¥å£å®šä¹‰åï¼Œæµ‹è¯•åªéœ€å…³æ³¨æ¥å£è¡Œä¸ºï¼Œæ— éœ€å…³å¿ƒå…·ä½“å®ç°

### ğŸ’¡ 3. **"ä¾èµ–æ³¨å…¥æ˜¯TDDçš„è‡ªç„¶äº§ç‰©"**
- æœåŠ¡ç±»ä¸å†ç›´æ¥ä¾èµ–å…·ä½“å®ç°ï¼Œè€Œæ˜¯é€šè¿‡æ„é€ å‡½æ•°æ¥æ”¶ä¾èµ–
- è¿™ä½¿å¾—æœåŠ¡ç±»**åªå…³æ³¨ä¸šåŠ¡é€»è¾‘**ï¼Œä¸å…³å¿ƒæ•°æ®å¦‚ä½•å­˜å‚¨ã€å¯†ç å¦‚ä½•å“ˆå¸Œ

### ğŸ’¡ 4. **"å•ä¸€èŒè´£åŸåˆ™æ˜¯TDDçš„å¿…ç„¶ç»“æœ"**
- æ¯ä¸ªå•å…ƒåªè´Ÿè´£ä¸€ä¸ªåŠŸèƒ½ï¼š
  - `PasswordValidator`ï¼šåªéªŒè¯å¯†ç 
  - `PasswordHasher`ï¼šåªå“ˆå¸Œå¯†ç 
  - `UserRepository`ï¼šåªå¤„ç†æ•°æ®å­˜å‚¨
- è¿™ä½¿å¾—æ¯ä¸ªå•å…ƒçš„æµ‹è¯•**ç®€å•ã€æ˜ç¡®ã€å¯é **

---

## ğŸš€ å®æˆ˜å»ºè®®ï¼šå¦‚ä½•ç”¨TDDé©±åŠ¨æ›´å¥½çš„å•å…ƒè®¾è®¡

### 1ï¸âƒ£ **å…ˆå†™æµ‹è¯•ï¼Œå†å†™å®ç°**
```go
// å…ˆå†™æµ‹è¯•ï¼ˆçº¢ï¼‰
func TestPasswordValidator_Validate(t *testing.T) {
    validator := PasswordValidator{}
    err := validator.Validate("short")
    if err == nil {
        t.Error("expected error for short password, got nil")
    }
}

// å†å†™å®ç°ï¼ˆç»¿ï¼‰
type PasswordValidator struct{}
func (p *PasswordValidator) Validate(password string) error {
    if len(password) < 8 {
        return errors.New("password too short")
    }
    return nil
}
```

### 2ï¸âƒ£ **å½“æµ‹è¯•éš¾ä»¥ç¼–å†™æ—¶ï¼Œåœä¸‹æ¥é‡æ„è®¾è®¡**
- å¦‚æœæµ‹è¯•éœ€è¦æ¨¡æ‹Ÿå¤æ‚ä¾èµ– â†’ åˆ›å»ºæ¥å£
- å¦‚æœæµ‹è¯•éœ€è¦è®¾ç½®å¤§é‡ç»†èŠ‚ â†’ æ‹†åˆ†èŒè´£

### 3ï¸âƒ£ **æµ‹è¯•åªå…³æ³¨å…¬å¼€è¡Œä¸ºï¼Œä¸å…³æ³¨å†…éƒ¨å®ç°**
```go
// é”™è¯¯åšæ³•ï¼ˆå…³æ³¨å†…éƒ¨å®ç°ï¼‰
mock.ExpectExec("INSERT INTO users...")

// æ­£ç¡®åšæ³•ï¼ˆå…³æ³¨å…¬å¼€è¡Œä¸ºï¼‰
repo.SaveUserFn = func(username, hashedPassword string) (int, error) {
    return 123, nil
}
```

### 4ï¸âƒ£ **ä½¿ç”¨è¡¨æ ¼é©±åŠ¨æµ‹è¯•ï¼ˆTable-Driven Testsï¼‰**
```go
func TestPasswordValidator_Validate(t *testing.T) {
    tests := []struct {
        name     string
        password string
        expectErr bool
        errMsg   string
    }{
        {"short", "short", true, "password too short"},
        {"valid", "ComplexPass123!", false, ""},
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            validator := PasswordValidator{}
            err := validator.Validate(tt.password)
            
            if tt.expectErr {
                if err == nil {
                    t.Error("expected error, got nil")
                } else if !strings.Contains(err.Error(), tt.errMsg) {
                    t.Errorf("expected error '%s', got '%s'", tt.errMsg, err.Error())
                }
            } else {
                if err != nil {
                    t.Errorf("expected no error, got %v", err)
                }
            }
        })
    }
}
```

---

## ğŸ’¬ çœŸå®å¼€å‘è€…åé¦ˆ

> "å½“æˆ‘å¼€å§‹ç”¨TDDé©±åŠ¨è®¾è®¡æ—¶ï¼Œæˆ‘çš„ä»£ç ä»'èƒ½è·‘'å˜æˆäº†'å¯ç»´æŠ¤'ã€‚  
> æœ€å¤§çš„æ”¹å˜æ˜¯ï¼šæˆ‘ä¸å†æ‹…å¿ƒä¿®æ”¹ç°æœ‰ä»£ç ä¼šç ´åå…¶ä»–åŠŸèƒ½ï¼Œ  
> å› ä¸ºæµ‹è¯•åªå…³æ³¨'åšä»€ä¹ˆ'ï¼Œä¸å…³å¿ƒ'æ€ä¹ˆåš'ã€‚  
> ç°åœ¨é‡æ„ä»£ç å˜å¾—è½»æ¾ï¼Œå› ä¸ºæµ‹è¯•ä¸ä¼šå› ä¸ºå†…éƒ¨å®ç°å˜æ›´è€Œå¤±è´¥ã€‚"  
> â€”â€” æŸäº‘æœåŠ¡Goå›¢é˜Ÿæ¶æ„å¸ˆ

> "TDDä¸æ˜¯ä¸ºäº†å†™æµ‹è¯•ï¼Œè€Œæ˜¯ä¸ºäº†è®¾è®¡æ›´å¥½çš„ä»£ç ã€‚  
> å½“æµ‹è¯•å˜å¾—ç®€å•æ—¶ï¼Œè¯´æ˜è®¾è®¡å˜å¾—æ›´å¥½ã€‚  
> å½“æµ‹è¯•å˜å¾—å¤æ‚æ—¶ï¼Œè¯´æ˜è®¾è®¡æœ‰é—®é¢˜ã€‚  
> è¿™æ˜¯ä¸€ä¸ªè‰¯æ€§å¾ªç¯ã€‚"  
> â€”â€” æŸå¤§å‹å¼€æºé¡¹ç›®ç»´æŠ¤è€…

---

## ğŸŒŸ ç»“è®ºï¼šå•å…ƒè®¾è®¡ä¸TDDçš„å…±ç”Ÿå…³ç³»

> **"å¥½çš„å•å…ƒè®¾è®¡è®©æµ‹è¯•è‡ªç„¶èšç„¦äºè¡Œä¸ºï¼Œè€ŒTDDçš„è¿‡ç¨‹åè¿‡æ¥åˆä¼šé©±åŠ¨æˆ‘ä»¬è¿›è¡Œæ›´å¥½çš„å•å…ƒè®¾è®¡ã€‚"**

- **ç³Ÿç³•è®¾è®¡ â†’ æµ‹è¯•å¤æ‚è„†å¼± â†’ é‡æ„å›°éš¾ â†’ è®¾è®¡æ›´å·®**ï¼ˆæ¶æ€§å¾ªç¯ï¼‰
- **è‰¯å¥½è®¾è®¡ â†’ æµ‹è¯•ç®€å•å¯é  â†’ é‡æ„å®¹æ˜“ â†’ è®¾è®¡æ›´å¥½**ï¼ˆè‰¯æ€§å¾ªç¯ï¼‰

> âœ… **å…³é”®å®è·µ**ï¼š  
> 1. **å…ˆå†™æµ‹è¯•**ï¼Œè®©æµ‹è¯•å¼•å¯¼è®¾è®¡  
> 2. **å½“æµ‹è¯•éš¾ä»¥ç¼–å†™æ—¶ï¼Œåœä¸‹æ¥é‡æ„**  
> 3. **æµ‹è¯•åªå…³æ³¨å…¬å¼€è¡Œä¸ºï¼Œä¸å…³æ³¨å†…éƒ¨å®ç°**  
> 4. **æ¯ä¸ªå•å…ƒåªè´Ÿè´£å•ä¸€èŒè´£**  

> ğŸ’¡ **ç»ˆæå¿ƒæ³•**ï¼š  
> **"æµ‹è¯•ä¸æ˜¯ä¸ºäº†éªŒè¯ä»£ç æ­£ç¡®ï¼Œè€Œæ˜¯ä¸ºäº†è®¾è®¡æ›´å¥½çš„ä»£ç "**  
> â€”â€” TDDçš„æœ¬è´¨æ˜¯**è®¾è®¡é©±åŠ¨å¼€å‘**ï¼Œè€Œéå•çº¯æµ‹è¯•é©±åŠ¨å¼€å‘


---

# å•å…ƒè®¾è®¡ä¸æµ‹è¯•çš„ç›¸äº’é©±åŠ¨ï¼šæ”¯ä»˜å¤„ç†ç³»ç»Ÿçš„æ¼”è¿›

è®©æˆ‘é€šè¿‡ä¸€ä¸ªå®é™…çš„æ”¯ä»˜å¤„ç†ç³»ç»Ÿæ¡ˆä¾‹ï¼Œå±•ç¤ºå•å…ƒè®¾è®¡å¦‚ä½•ç›´æ¥å½±å“æµ‹è¯•è´¨é‡ï¼Œä»¥åŠTDDå¦‚ä½•é©±åŠ¨æ›´å¥½çš„è®¾è®¡ã€‚

## ğŸ¯ æ¡ˆä¾‹èƒŒæ™¯ï¼šæ”¯ä»˜å¤„ç†ç³»ç»Ÿ

æˆ‘ä»¬è¦å¼€å‘ä¸€ä¸ªæ”¯ä»˜å¤„ç†ç³»ç»Ÿï¼Œæ”¯æŒå¤šç§æ”¯ä»˜æ–¹å¼ï¼ˆä¿¡ç”¨å¡ã€å€Ÿè®°å¡ã€ç”µå­é’±åŒ…ï¼‰ã€‚

## ğŸ”§ ç¬¬ä¸€é˜¶æ®µï¼šç³Ÿç³•çš„å•å…ƒè®¾è®¡

```go
// bad_design/payment_processor.go
package payment

import (
    "database/sql"
    "fmt"
    "net/http"
    "time"
)

type PaymentProcessor struct {
    db         *sql.DB
    httpClient *http.Client
    apiKey     string
}

func NewPaymentProcessor(db *sql.DB, apiKey string) *PaymentProcessor {
    return &PaymentProcessor{
        db:         db,
        httpClient: &http.Client{Timeout: 30 * time.Second},
        apiKey:     apiKey,
    }
}

func (p *PaymentProcessor) ProcessPayment(cardNumber, cvv, expiry string, amount float64) (string, error) {
    // 1. éªŒè¯ä¿¡ç”¨å¡ä¿¡æ¯ï¼ˆç›´æ¥åœ¨ä¸»æ–¹æ³•ä¸­ï¼‰
    if len(cardNumber) != 16 {
        return "", fmt.Errorf("å¡å·é•¿åº¦ä¸æ­£ç¡®")
    }
    if len(cvv) != 3 {
        return "", fmt.Errorf("CVVé•¿åº¦ä¸æ­£ç¡®")
    }
    
    // 2. æ£€æŸ¥æ•°æ®åº“ä¸­æ˜¯å¦æœ‰è¶³å¤Ÿä½™é¢
    var balance float64
    err := p.db.QueryRow("SELECT balance FROM accounts WHERE card_number = ?", cardNumber).Scan(&balance)
    if err != nil {
        return "", fmt.Errorf("æŸ¥è¯¢è´¦æˆ·å¤±è´¥: %v", err)
    }
    if balance < amount {
        return "", fmt.Errorf("ä½™é¢ä¸è¶³")
    }
    
    // 3. è°ƒç”¨ç¬¬ä¸‰æ–¹æ”¯ä»˜API
    url := "https://payment-gateway.com/process"
    // ... æ„é€ è¯·æ±‚ï¼Œå‘é€HTTPè¯·æ±‚ ...
    
    // 4. æ›´æ–°æ•°æ®åº“ä½™é¢
    _, err = p.db.Exec("UPDATE accounts SET balance = balance - ? WHERE card_number = ?", amount, cardNumber)
    if err != nil {
        return "", fmt.Errorf("æ›´æ–°ä½™é¢å¤±è´¥: %v", err)
    }
    
    // 5. è®°å½•äº¤æ˜“æ—¥å¿—åˆ°æ•°æ®åº“
    _, err = p.db.Exec("INSERT INTO transactions (card_number, amount, status) VALUES (?, ?, ?)", cardNumber, amount, "success")
    if err != nil {
        // æ³¨æ„ï¼šè¿™é‡Œæ²¡æœ‰å›æ»šå‰é¢çš„æ“ä½œï¼
        return "", fmt.Errorf("è®°å½•äº¤æ˜“å¤±è´¥: %v", err)
    }
    
    return "transaction_id_123", nil
}
```

## ğŸ§ª ç³Ÿç³•è®¾è®¡ä¸‹çš„æµ‹è¯•ï¼ˆå›°éš¾ä¸”ä»·å€¼ä½ï¼‰

```go
// bad_design/payment_processor_test.go
package payment_test

import (
    "database/sql"
    "net/http"
    "net/http/httptest"
    "testing"
    // è¿™é‡Œéœ€è¦çœŸå®çš„æ•°æ®åº“è¿æ¥å’ŒHTTPæœåŠ¡ï¼
)

func TestPaymentProcessor_ProcessPayment_BadExample(t *testing.T) {
    // é—®é¢˜1ï¼šéœ€è¦çœŸå®çš„æ•°æ®åº“è¿æ¥
    db, err := sql.Open("mysql", "test_connection_string")
    if err != nil {
        t.Skip("è·³è¿‡æµ‹è¯•ï¼šæ— æ³•è¿æ¥æµ‹è¯•æ•°æ®åº“")
        return
    }
    
    // é—®é¢˜2ï¼šéœ€è¦çœŸå®çš„HTTPæœåŠ¡
    server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // æ¨¡æ‹Ÿç¬¬ä¸‰æ–¹APIå“åº”
        w.WriteHeader(http.StatusOK)
        w.Write([]byte(`{"transaction_id": "test_123", "status": "success"}`))
    }))
    defer server.Close()
    
    // é—®é¢˜3ï¼šéœ€è¦å‡†å¤‡æµ‹è¯•æ•°æ®
    // ... å¤æ‚çš„æ•°æ®åº“å‡†å¤‡ä»£ç  ...
    
    processor := NewPaymentProcessor(db, "test_api_key")
    
    // é—®é¢˜4ï¼šæµ‹è¯•è€¦åˆäº†å¤ªå¤šå¤–éƒ¨ä¾èµ–
    transactionID, err := processor.ProcessPayment("1234567890123456", "123", "12/25", 100.0)
    
    // é—®é¢˜5ï¼šæµ‹è¯•è„†å¼±ï¼Œå®¹æ˜“å¤±è´¥
    if err != nil {
        t.Fatalf("æœŸæœ›æˆåŠŸå¤„ç†æ”¯ä»˜ï¼Œä½†å¾—åˆ°é”™è¯¯: %v", err)
    }
    
    // é—®é¢˜6ï¼šæµ‹è¯•é€Ÿåº¦æ…¢ï¼ˆç§’çº§ï¼‰
}
```

**ç³Ÿç³•è®¾è®¡çš„é—®é¢˜ï¼š**
- æµ‹è¯•éœ€è¦çœŸå®æ•°æ®åº“å’ŒHTTPæœåŠ¡
- æµ‹è¯•å‡†å¤‡å¤æ‚ï¼Œæ‰§è¡Œç¼“æ…¢
- æµ‹è¯•è„†å¼±ï¼Œå®¹æ˜“å› å¤–éƒ¨ä¾èµ–å˜åŒ–è€Œå¤±è´¥
- éš¾ä»¥æµ‹è¯•å„ç§è¾¹ç•Œæƒ…å†µ
- æµ‹è¯•è¦†ç›–ç‡ä½ï¼Œä»·å€¼æœ‰é™

## ğŸ”„ ç¬¬äºŒé˜¶æ®µï¼šTDDé©±åŠ¨çš„ä¼˜ç§€è®¾è®¡

è®©æˆ‘ä»¬é‡æ–°å¼€å§‹ï¼Œä½¿ç”¨TDDæ¥é©±åŠ¨æ›´å¥½çš„è®¾è®¡ã€‚

### æ­¥éª¤1ï¼šç¼–å†™ç¬¬ä¸€ä¸ªæµ‹è¯•ï¼ˆé©±åŠ¨å‡ºæ¥å£è®¾è®¡ï¼‰

```go
// good_design/payment_processor_test.go
package payment_test

import (
    "errors"
    "testing"
    "good_design"
)

// Mockå®ç° - é©±åŠ¨å‡ºæ¸…æ™°çš„æ¥å£
type mockCardValidator struct {
    isValid bool
    err     error
}

func (m *mockCardValidator) Validate(cardNumber, cvv, expiry string) error {
    if m.err != nil {
        return m.err
    }
    if !m.isValid {
        return errors.New("å¡ä¿¡æ¯æ— æ•ˆ")
    }
    return nil
}

type mockAccountService struct {
    balance float64
    err     error
}

func (m *mockAccountService) CheckBalance(cardNumber string) (float64, error) {
    if m.err != nil {
        return 0, m.err
    }
    return m.balance, nil
}

func (m *mockAccountService) DeductBalance(cardNumber string, amount float64) error {
    if m.err != nil {
        return m.err
    }
    return nil
}

type mockPaymentGateway struct {
    transactionID string
    err           error
}

func (m *mockPaymentGateway) Charge(cardNumber, cvv, expiry string, amount float64) (string, error) {
    if m.err != nil {
        return "", m.err
    }
    return m.transactionID, nil
}

type mockTransactionLogger struct {
    logged bool
    err    error
}

func (m *mockTransactionLogger) Log(cardNumber string, amount float64, status string, transactionID string) error {
    if m.err != nil {
        return m.err
    }
    m.logged = true
    return nil
}

// æµ‹è¯•1ï¼šæˆåŠŸæ”¯ä»˜åœºæ™¯
func TestPaymentProcessor_ProcessPayment_Success(t *testing.T) {
    // Arrange - æ¸…æ™°çš„æµ‹è¯•å‡†å¤‡
    validator := &mockCardValidator{isValid: true}
    accountService := &mockAccountService{balance: 150.0}
    gateway := &mockPaymentGateway{transactionID: "txn_123"}
    logger := &mockTransactionLogger{}
    
    processor := payment.NewPaymentProcessor(validator, accountService, gateway, logger)
    
    // Act - ç®€å•çš„è°ƒç”¨
    transactionID, err := processor.ProcessPayment("1234567890123456", "123", "12/25", 100.0)
    
    // Assert - æ¸…æ™°çš„è¡Œä¸ºéªŒè¯
    if err != nil {
        t.Fatalf("æœŸæœ›æˆåŠŸå¤„ç†æ”¯ä»˜ï¼Œä½†å¾—åˆ°é”™è¯¯: %v", err)
    }
    if transactionID != "txn_123" {
        t.Errorf("æœŸæœ›äº¤æ˜“IDä¸º 'txn_123'ï¼Œä½†å¾—åˆ° '%s'", transactionID)
    }
}

// æµ‹è¯•2ï¼šä½™é¢ä¸è¶³åœºæ™¯
func TestPaymentProcessor_ProcessPayment_InsufficientBalance(t *testing.T) {
    // Arrange
    validator := &mockCardValidator{isValid: true}
    accountService := &mockAccountService{balance: 50.0} // ä½™é¢ä¸è¶³
    gateway := &mockPaymentGateway{transactionID: "txn_123"}
    logger := &mockTransactionLogger{}
    
    processor := payment.NewPaymentProcessor(validator, accountService, gateway, logger)
    
    // Act
    transactionID, err := processor.ProcessPayment("1234567890123456", "123", "12/25", 100.0)
    
    // Assert
    if err == nil {
        t.Fatal("æœŸæœ›å¾—åˆ°é”™è¯¯ï¼Œä½†æ“ä½œæˆåŠŸ")
    }
    if transactionID != "" {
        t.Errorf("æœŸæœ›ç©ºçš„äº¤æ˜“IDï¼Œä½†å¾—åˆ° '%s'", transactionID)
    }
    if err.Error() != "ä½™é¢ä¸è¶³" {
        t.Errorf("æœŸæœ›é”™è¯¯æ¶ˆæ¯ä¸º 'ä½™é¢ä¸è¶³'ï¼Œä½†å¾—åˆ° '%s'", err.Error())
    }
}
```

### æ­¥éª¤2ï¼šæ ¹æ®æµ‹è¯•é©±åŠ¨å‡ºä¼˜ç§€çš„è®¾è®¡

```go
// good_design/interfaces.go
package payment

import "errors"

// CardValidator - å¡ä¿¡æ¯éªŒè¯æ¥å£
type CardValidator interface {
    Validate(cardNumber, cvv, expiry string) error
}

// AccountService - è´¦æˆ·æœåŠ¡æ¥å£
type AccountService interface {
    CheckBalance(cardNumber string) (float64, error)
    DeductBalance(cardNumber string, amount float64) error
}

// PaymentGateway - æ”¯ä»˜ç½‘å…³æ¥å£
type PaymentGateway interface {
    Charge(cardNumber, cvv, expiry string, amount float64) (string, error)
}

// TransactionLogger - äº¤æ˜“æ—¥å¿—æ¥å£
type TransactionLogger interface {
    Log(cardNumber string, amount float64, status string, transactionID string) error
}

// å®šä¹‰æ ‡å‡†é”™è¯¯
var (
    ErrInsufficientBalance = errors.New("ä½™é¢ä¸è¶³")
    ErrInvalidCard         = errors.New("å¡ä¿¡æ¯æ— æ•ˆ")
    ErrPaymentFailed       = errors.New("æ”¯ä»˜å¤±è´¥")
)
```

```go
// good_design/payment_processor.go
package payment

import "fmt"

// PaymentProcessor - æ”¯ä»˜å¤„ç†å™¨ï¼ˆé«˜å†…èšã€ä½è€¦åˆï¼‰
type PaymentProcessor struct {
    validator      CardValidator
    accountService AccountService
    gateway        PaymentGateway
    logger         TransactionLogger
}

func NewPaymentProcessor(
    validator CardValidator,
    accountService AccountService,
    gateway PaymentGateway,
    logger TransactionLogger,
) *PaymentProcessor {
    return &PaymentProcessor{
        validator:      validator,
        accountService: accountService,
        gateway:        gateway,
        logger:         logger,
    }
}

// ProcessPayment - æ¸…æ™°çš„ä¸šåŠ¡æµç¨‹ï¼ˆé«˜å†…èšï¼‰
func (p *PaymentProcessor) ProcessPayment(cardNumber, cvv, expiry string, amount float64) (string, error) {
    // 1. éªŒè¯å¡ä¿¡æ¯
    if err := p.validator.Validate(cardNumber, cvv, expiry); err != nil {
        p.logger.Log(cardNumber, amount, "failed", "")
        return "", fmt.Errorf("%w: %v", ErrInvalidCard, err)
    }
    
    // 2. æ£€æŸ¥ä½™é¢
    balance, err := p.accountService.CheckBalance(cardNumber)
    if err != nil {
        p.logger.Log(cardNumber, amount, "failed", "")
        return "", fmt.Errorf("æ£€æŸ¥ä½™é¢å¤±è´¥: %w", err)
    }
    if balance < amount {
        p.logger.Log(cardNumber, amount, "failed", "")
        return "", ErrInsufficientBalance
    }
    
    // 3. å¤„ç†æ”¯ä»˜
    transactionID, err := p.gateway.Charge(cardNumber, cvv, expiry, amount)
    if err != nil {
        p.logger.Log(cardNumber, amount, "failed", "")
        return "", fmt.Errorf("%w: %v", ErrPaymentFailed, err)
    }
    
    // 4. æ‰£é™¤ä½™é¢
    if err := p.accountService.DeductBalance(cardNumber, amount); err != nil {
        p.logger.Log(cardNumber, amount, "failed", transactionID)
        return "", fmt.Errorf("æ‰£é™¤ä½™é¢å¤±è´¥: %w", err)
    }
    
    // 5. è®°å½•æˆåŠŸæ—¥å¿—
    if err := p.logger.Log(cardNumber, amount, "success", transactionID); err != nil {
        // æ³¨æ„ï¼šè¿™é‡Œå¯ä»¥é€‰æ‹©æ˜¯å¦è¿”å›é”™è¯¯ï¼Œå› ä¸ºæ”¯ä»˜å·²ç»æˆåŠŸ
        // è¿™æ˜¯ä¸€ä¸ªå¥½çš„è®¾è®¡å†³ç­–
    }
    
    return transactionID, nil
}
```

```go
// good_design/card_validator.go
package payment

import (
    "errors"
    "regexp"
    "strconv"
    "strings"
    "time"
)

type DefaultCardValidator struct{}

func NewDefaultCardValidator() *DefaultCardValidator {
    return &DefaultCardValidator{}
}

func (v *DefaultCardValidator) Validate(cardNumber, cvv, expiry string) error {
    // éªŒè¯å¡å·
    if !isValidCardNumber(cardNumber) {
        return errors.New("å¡å·æ ¼å¼ä¸æ­£ç¡®")
    }
    
    // éªŒè¯CVV
    if !isValidCVV(cvv) {
        return errors.New("CVVæ ¼å¼ä¸æ­£ç¡®")
    }
    
    // éªŒè¯è¿‡æœŸæ—¥æœŸ
    if !isValidExpiry(expiry) {
        return errors.New("è¿‡æœŸæ—¥æœŸæ— æ•ˆ")
    }
    
    return nil
}

func isValidCardNumber(cardNumber string) bool {
    // ç§»é™¤ç©ºæ ¼å’Œè¿å­—ç¬¦
    cleanNumber := strings.ReplaceAll(strings.ReplaceAll(cardNumber, " ", ""), "-", "")
    if len(cleanNumber) < 13 || len(cleanNumber) > 19 {
        return false
    }
    
    // ç®€å•çš„æ•°å­—éªŒè¯
    _, err := strconv.ParseInt(cleanNumber, 10, 64)
    return err == nil
}

func isValidCVV(cvv string) bool {
    match, _ := regexp.MatchString(`^\d{3,4}$`, cvv)
    return match
}

func isValidExpiry(expiry string) bool {
    // è§£æ MM/YY æ ¼å¼
    parts := strings.Split(expiry, "/")
    if len(parts) != 2 {
        return false
    }
    
    month, err1 := strconv.Atoi(parts[0])
    year, err2 := strconv.Atoi(parts[1])
    if err1 != nil || err2 != nil {
        return false
    }
    
    if month < 1 || month > 12 {
        return false
    }
    
    // å‡è®¾å¹´ä»½æ˜¯ 20xx æ ¼å¼
    fullYear := 2000 + year
    now := time.Now()
    expiryTime := time.Date(fullYear, time.Month(month+1), 0, 0, 0, 0, 0, time.UTC)
    
    return expiryTime.After(now)
}
```

## ğŸ¯ è®¾è®¡å¯¹æ¯”åˆ†æ

### ç³Ÿç³•è®¾è®¡çš„é—®é¢˜ï¼š

1. **è¿åå•ä¸€èŒè´£åŸåˆ™**
   ```go
   // ä¸€ä¸ªæ–¹æ³•åšäº†å¤ªå¤šäº‹æƒ…
   func (p *PaymentProcessor) ProcessPayment(...) {
       // éªŒè¯ + æ•°æ®åº“æŸ¥è¯¢ + HTTPè°ƒç”¨ + æ•°æ®åº“æ›´æ–° + æ—¥å¿—è®°å½•
   }
   ```

2. **ç´§è€¦åˆ**
   ```go
   type PaymentProcessor struct {
       db         *sql.DB        // ç›´æ¥ä¾èµ–å…·ä½“å®ç°
       httpClient *http.Client   // ç›´æ¥ä¾èµ–å…·ä½“å®ç°
   }
   ```

3. **éš¾ä»¥æµ‹è¯•**
   - éœ€è¦çœŸå®æ•°æ®åº“å’ŒHTTPæœåŠ¡
   - æµ‹è¯•å‡†å¤‡å¤æ‚
   - æ‰§è¡Œé€Ÿåº¦æ…¢

### ä¼˜ç§€è®¾è®¡çš„ä¼˜åŠ¿ï¼š

1. **é«˜å†…èšã€ä½è€¦åˆ**
   ```go
   // æ¯ä¸ªç»„ä»¶èŒè´£å•ä¸€
   type CardValidator interface { ... }      // åªè´Ÿè´£éªŒè¯
   type AccountService interface { ... }     // åªè´Ÿè´£è´¦æˆ·æ“ä½œ
   type PaymentGateway interface { ... }     // åªè´Ÿè´£æ”¯ä»˜è°ƒç”¨
   type TransactionLogger interface { ... }  // åªè´Ÿè´£æ—¥å¿—è®°å½•
   ```

2. **ä¾èµ–æŠ½è±¡è€Œéå…·ä½“å®ç°**
   ```go
   type PaymentProcessor struct {
       validator      CardValidator      // ä¾èµ–æ¥å£
       accountService AccountService     // ä¾èµ–æ¥å£
       gateway        PaymentGateway     // ä¾èµ–æ¥å£
       logger         TransactionLogger  // ä¾èµ–æ¥å£
   }
   ```

3. **æ˜“äºæµ‹è¯•**
   ```go
   // æµ‹è¯•ç®€å•æ˜äº†ï¼Œæ¯«ç§’çº§æ‰§è¡Œ
   func TestPaymentProcessor_ProcessPayment_Success(t *testing.T) {
       // åªéœ€è¦Mockæ¥å£ï¼Œä¸éœ€è¦çœŸå®å¤–éƒ¨æœåŠ¡
       validator := &mockCardValidator{isValid: true}
       accountService := &mockAccountService{balance: 150.0}
       gateway := &mockPaymentGateway{transactionID: "txn_123"}
       logger := &mockTransactionLogger{}
       
       processor := NewPaymentProcessor(validator, accountService, gateway, logger)
       // ... ç®€å•æµ‹è¯•
   }
   ```

## ğŸ“Š æµ‹è¯•è´¨é‡å¯¹æ¯”

### ç³Ÿç³•è®¾è®¡ä¸‹çš„æµ‹è¯•ï¼š
- **æ‰§è¡Œæ—¶é—´**ï¼šç§’çº§ï¼ˆéœ€è¦çœŸå®æ•°æ®åº“å’Œç½‘ç»œï¼‰
- **ç¨³å®šæ€§**ï¼šå·®ï¼ˆå¤–éƒ¨ä¾èµ–å˜åŒ–ä¼šå¤±è´¥ï¼‰
- **è¦†ç›–ç‡**ï¼šä½ï¼ˆéš¾ä»¥æµ‹è¯•å„ç§åœºæ™¯ï¼‰
- **ç»´æŠ¤æˆæœ¬**ï¼šé«˜ï¼ˆéœ€è¦ç»´æŠ¤æµ‹è¯•ç¯å¢ƒï¼‰
- **ä»·å€¼**ï¼šä½ï¼ˆä¸»è¦æ˜¯é›†æˆæµ‹è¯•ï¼Œä¸æ˜¯å•å…ƒæµ‹è¯•ï¼‰

### ä¼˜ç§€è®¾è®¡ä¸‹çš„æµ‹è¯•ï¼š
- **æ‰§è¡Œæ—¶é—´**ï¼šæ¯«ç§’çº§ï¼ˆçº¯å†…å­˜æ“ä½œï¼‰
- **ç¨³å®šæ€§**ï¼šé«˜ï¼ˆä¸ä¾èµ–å¤–éƒ¨ç¯å¢ƒï¼‰
- **è¦†ç›–ç‡**ï¼šé«˜ï¼ˆå®¹æ˜“æµ‹è¯•å„ç§è¾¹ç•Œæƒ…å†µï¼‰
- **ç»´æŠ¤æˆæœ¬**ï¼šä½ï¼ˆæµ‹è¯•ä»£ç ç®€æ´ï¼‰
- **ä»·å€¼**ï¼šé«˜ï¼ˆçœŸæ­£çš„å•å…ƒæµ‹è¯•ï¼Œå¿«é€Ÿåé¦ˆï¼‰

## ğŸ”„ TDDé©±åŠ¨è®¾è®¡çš„ä»·å€¼ä½“ç°

### 1. **é©±åŠ¨å‡ºæ¸…æ™°çš„æ¥å£è®¾è®¡**
```go
// æµ‹è¯•éœ€æ±‚é©±åŠ¨å‡ºæ¥å£å¥‘çº¦
type CardValidator interface {
    Validate(cardNumber, cvv, expiry string) error
}
```

### 2. **é©±åŠ¨å‡ºåˆç†çš„èŒè´£åˆ†ç¦»**
```go
// æ¯ä¸ªæµ‹è¯•åœºæ™¯é©±åŠ¨å‡ºç‹¬ç«‹çš„ç»„ä»¶
func TestPaymentProcessor_InsufficientBalance(...) {
    // é©±åŠ¨å‡º AccountService æ¥å£
}

func TestPaymentProcessor_InvalidCard(...) {
    // é©±åŠ¨å‡º CardValidator æ¥å£
}
```

### 3. **é©±åŠ¨å‡ºæ›´å¥½çš„é”™è¯¯å¤„ç†**
```go
// æµ‹è¯•å„ç§é”™è¯¯åœºæ™¯é©±åŠ¨å‡ºæ¸…æ™°çš„é”™è¯¯å®šä¹‰
var (
    ErrInsufficientBalance = errors.New("ä½™é¢ä¸è¶³")
    ErrInvalidCard         = errors.New("å¡ä¿¡æ¯æ— æ•ˆ")
    ErrPaymentFailed       = errors.New("æ”¯ä»˜å¤±è´¥")
)
```

### 4. **é©±åŠ¨å‡ºå¯æ‰©å±•çš„æ¶æ„**
```go
// æ˜“äºæ·»åŠ æ–°çš„æ”¯ä»˜æ–¹å¼
type AlipayGateway struct { ... }
type WeChatPayGateway struct { ... }

// åªéœ€è¦å®ç° PaymentGateway æ¥å£å³å¯
```

## ğŸ¯ æ€»ç»“

é€šè¿‡è¿™ä¸ªå®é™…æ¡ˆä¾‹å¯ä»¥çœ‹å‡ºï¼š

### å•å…ƒè®¾è®¡å½±å“æµ‹è¯•è´¨é‡ï¼š
- **ç³Ÿç³•è®¾è®¡** â†’ éš¾ä»¥æµ‹è¯•ã€ä»·å€¼ä½
- **ä¼˜ç§€è®¾è®¡** â†’ æ˜“äºæµ‹è¯•ã€ä»·å€¼é«˜

### TDDé©±åŠ¨æ›´å¥½çš„è®¾è®¡ï¼š
- **æµ‹è¯•å…ˆè¡Œ** â†’ é©±åŠ¨å‡ºæ¸…æ™°çš„æ¥å£
- **Mockéœ€æ±‚** â†’ é©±åŠ¨å‡ºåˆç†çš„èŒè´£åˆ†ç¦»
- **åœºæ™¯è¦†ç›–** â†’ é©±åŠ¨å‡ºå®Œå–„çš„é”™è¯¯å¤„ç†
- **é‡æ„å®‰å…¨** â†’ é©±åŠ¨å‡ºå¯æ‰©å±•çš„æ¶æ„

è¿™æ­£æ˜¯"å•å…ƒè®¾è®¡çš„ä¼˜åŠ£ç›´æ¥å½±å“æµ‹è¯•çš„éš¾æ˜“åº¦å’Œä»·å€¼ï¼Œè€ŒTDDçš„è¿‡ç¨‹åè¿‡æ¥åˆä¼šé©±åŠ¨æˆ‘ä»¬è¿›è¡Œæ›´å¥½çš„å•å…ƒè®¾è®¡"çš„å®Œç¾ä½“ç°ã€‚


