**第9章：Optimizing Memory Access（优化内存访问）内容实用总结：**

- **9.1-9.2 缓存机制与组织（Caching of code and data, Cache organization）**
    
    - CPU缓存分多级（L1/L2/L3），极大影响内存访问速度。
        
    - 程序数据结构、数组、变量最好顺序存放、按访问频率组织，提升缓存命中。
        
    - 大数组或结构尽量按连续内存分布，避免频繁跨缓存行访问。
        
- **9.3-9.4 代码/数据空间相关性优化（Functions/variables that are used together should be stored together）**
    
    - 建议把多次一起访问的变量/函数，组织为结构体、数组、模块，减少跨区域跳跃。
        
    - 示例：用结构体替代多个平行数组，可让缓存利用更高效。
        
    - 联合体（union）可复用空间（仅限大对象且生命周期不重叠，以节省Cache）。
        
- **9.5 数据对齐（Alignment of data）**
    
    - 关键变量建议显式对齐到8/16/64字节（如 alignas(64)），保证高速访问，不浪费Cache。
        
    - 类成员及大数组靠前声明，减少和填充字节（padding）的浪费。
        
- **9.6 动态内存分配（Dynamic memory allocation）**
    
    - 动态分配（new/delete, malloc/free）会导致慢速、碎片化和Cache低效。如无需频繁变大建议用栈数组。
        
    - 动态分配后应用容器类自动管理释放，防止泄漏。
        
- **9.7 容器类和数据结构（Data structures and container classes）**
    
    - std::vector 优于链表（性能/内存/缓存）；对vector预留内存（reserve）最有效。
        
    - 标准库泛型容器（vector、map等）适合普适场景，缺点是频繁 reallocation 影响缓存命中。
        
    - 高性能场景可用 memory pool（内存池），或预分配大块缓冲区，减少碎片和内存管理负担。
        
- **9.8 字符串优化（Strings）**
    
    - 建议用内存池集中存储字符串，避免频繁分配与释放、缓存失效；大型文本场景尤其明显。
        
- **9.9 顺序访问与非顺序访问（Access data sequentially）**
    
    - 数据尽量按顺序访问，匹配CPU预取机制，减少缓存错失。
        
    - 多维数组建议最后一维元素变化最快（如 matrix[i][j], j为内层循环），适合C++的行优先存储。
        
- **9.10 缓存冲突与大型数据结构（Cache contentions in large data structures）**
    
    - 多线程/大结构容易引发缓存争用，需分块分区数据，尽量让线程/代码访问独立区块。
        
    - 合理分配对象/数组，使关键数据不抢同一个缓存集合。
        
- **9.11 显式缓存控制（Explicit cache control）**
    
    - SSE/AVX等新指令如 MOVNT/stream store，可用于大对象写入时禁用缓存，不污染数据缓存。
        
    - 推荐仅在有水平 cache miss 时才用 nontemporal 指令，避免影响其它正常缓存行为。
        

**结论**  
内存访问和缓存效率是 C++ 性能优化的重点。正确的数据组织、顺序访问、尺寸和对齐、减少动态碎片化和冲突，可大幅提升程序运行速度。大规模数据和高并发场景下，最优策略是结构紧凑、空间复用、容器预分配和适当使用底层指令优化，极大提升稳定性和性能。

1. [https://agner.org/optimize/optimizing_cpp.pdf](https://agner.org/optimize/optimizing_cpp.pdf)