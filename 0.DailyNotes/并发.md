---
type: MOC
tags:
  - ComputerScience
  - Concurrency
  - Problem-Solving
---

### **Concurrency**

Your program is slow. It wastes time. It wastes power.
We must fix this.

---

### **The Problem**

A program does two things. It waits or it works.

Sometimes, the program waits. It waits for the network. It waits for the disk. The CPU is idle. This is waste.

Sometimes, the program works. It computes hard. It uses one CPU core. The other cores are idle. This is also waste.

First, know your problem. Is the program waiting? Or is it working?

---

### **The Solutions**

There are two problems. There are two solutions.

If your program waits, use asynchronous code.
The program gives a task. It does not wait for the answer. It moves to the next task. This ends the waste of waiting.

If your program works hard, use many threads.
One big job becomes many small jobs. Each thread takes a job. Each CPU core runs a thread. All cores work together. This ends the waste of idle cores.

---

### **The Dangers**

These solutions have dangers.

Asynchronous code is hard to read. It is hard to debug. The logic can get lost.

Many threads are dangerous. They share memory. They can corrupt data. They can block each other. You must control them with locks. Locks are complex. They create new problems.

---

### **The Choice**

You must choose.

If your program waits for I/O, choose asynchronous code.
It is faster. It uses less power. Accept the complex logic.

If your program does heavy math, choose multithreading.
It uses all your cores. Accept the danger of locks.

Know your problem. Choose your tool. Write strong code.