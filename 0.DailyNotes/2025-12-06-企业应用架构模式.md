《企业应用架构模式》（_Patterns of Enterprise Application Architecture_）是 Martin Fowler 于 2002 年出版的经典著作，系统总结了构建企业级软件（尤其是数据库驱动的业务系统）时反复出现的设计问题与解决方案。尽管技术栈不断演进，但书中提出的**核心思想和模式**至今仍深刻影响着现代应用架构（如 DDD、微服务、ORM 框架等）。

以下是该书涉及的 **核心知识点分类罗列**，便于系统学习：

---

## 一、架构分层模式（Architectural Patterns）

|模式|说明|
|---|---|
|**Transaction Script**|用一个过程（脚本）处理整个业务事务，适合简单逻辑。|
|**Domain Model（领域模型）**|将业务逻辑封装在富对象中，对象间有关系和行为，适合复杂业务。|
|**Table Module**|每张表对应一个模块（类），包含对该表所有操作，介于 Transaction Script 与 Domain Model 之间。|
|**Service Layer**|定义一套服务接口作为业务逻辑的入口，解耦表现层与领域逻辑。|

> ✅ 现代对应：Service Layer → 微服务 API；Domain Model → DDD 聚合根。

---

## 二、对象-关系映射（ORM）模式（Object-Relational Metadata Mapping Patterns）

这些模式解决 **对象世界 vs 关系数据库** 的“阻抗失配”问题。

|模式|说明|
|---|---|
|**Metadata Mapping**|通过配置（XML/注解）描述对象与表的映射关系（如 Hibernate/JPA）。|
|**Query Object**|用对象封装数据库查询逻辑（如 JPA Criteria、MyBatis QueryWrapper）。|
|**Repository**|提供集合式接口访问领域对象，隐藏数据源细节（DDD 核心模式）。|
|**Identity Map**|在会话内缓存已加载对象，确保同一 ID 对应同一对象实例。|
|**Unit of Work**|跟踪对象变更，在事务结束时统一提交（如 Hibernate Session）。|
|**Lazy Load**|延迟加载关联对象（如 `@OneToMany(fetch = FetchType.LAZY)`）。|
|**Foreign Key Mapping / Association Table Mapping**|处理对象关联如何映射到外键或关联表。|

> 💡 这些是现代 ORM 框架（Hibernate、MyBatis Plus、Entity Framework）的理论基础。

---

## 三、并发与事务控制模式

|模式|说明|
|---|---|
|**Optimistic Offline Lock（乐观锁）**|通过版本号/时间戳检测并发冲突（如 `@Version`）。|
|**Pessimistic Offline Lock（悲观锁）**|通过数据库行锁（`SELECT FOR UPDATE`）防止并发修改。|
|**Coarse-Grained Lock**|对聚合根加锁，而非每个实体。|

---

## 四、数据源架构模式（Data Source Architectural Patterns）

|模式|说明|
|---|---|
|**Table Data Gateway**|一个类封装对一张表的所有操作（如 MyBatis Mapper）。|
|**Row Data Gateway**|每一行数据对应一个对象，含 CRUD 方法（轻量级 DAO）。|
|**Active Record**|对象自身包含持久化逻辑（如 Rails ActiveRecord、ThinkPHP）。|
|**Data Mapper**|对象与数据库完全解耦，由独立 Mapper 负责转换（如 MyBatis、Hibernate）。|

> ✅ 现代趋势：**Data Mapper + Repository** 是主流（尤其在 DDD 中）。

---

## 五、组织领域逻辑模式

|模式|说明|
|---|---|
|**Domain Model**|富领域对象，包含行为和状态（OOP 核心）。|
|**Anemic Domain Model（贫血模型）**|对象只有 getter/setter，业务逻辑在 Service 中（常见但被 Fowler 批评）。|
|**Specification**|将业务规则封装为可组合的谓词对象（用于复杂查询或验证）。|

---

## 六、分配职责与解耦模式

|模式|说明|
|---|---|
|**Separated Interface**|接口定义与实现分离，支持跨模块依赖（如 API 模块）。|
|**Registry**|全局访问点管理共享对象（类似 Spring Bean 容器）。|
|**Value Object**|不可变、无身份的对象（如 Money、Address），用于传递数据。|
|**Money Pattern**|专门处理货币金额（含币种、精度），避免浮点误差。|

---

## 七、Web 表现层相关模式

|模式|说明|
|---|---|
|**Front Controller**|单一入口处理所有请求（如 Spring MVC DispatcherServlet）。|
|**Transform View**|模板引擎将数据转换为 HTML（如 Thymeleaf、Freemarker）。|
|**Template View**|视图模板嵌入动态内容（JSP、Vue 组件也属此类思想）。|

---

## 八、分布式与集成模式（简要提及）

虽然本书聚焦单体应用，但也涉及：

- **Remote Facade**：为远程调用提供粗粒度接口（减少网络往返）。
- **Data Transfer Object (DTO)**：封装跨进程传输的数据（避免暴露领域对象）。

> ✅ DTO 至今仍是微服务间通信的标准实践。

---

## 九、关键思想总结

1. **没有银弹**：根据系统复杂度选择合适模式（简单用 Transaction Script，复杂用 Domain Model）。
2. **关注点分离**：表现层、业务逻辑、数据源应清晰分层。
3. **对象 vs 表 ≠ 一一对应**：需通过映射模式桥接。
4. **并发是常态**：必须显式处理数据一致性。
5. **测试驱动设计**：好的架构应易于单元测试（贫血模型难测，富模型易测）。

---

## 学习建议

- 📚 **精读重点章节**：Domain Model、Service Layer、Data Mapper、Repository、Unit of Work、Lazy Load。
- 🔧 **结合代码实践**：用 Java/Spring Boot 实现一个小型系统，分别尝试 Transaction Script 和 Domain Model。
- 🔄 **对比现代框架**：理解 MyBatis/Hibernate 如何实现书中模式。
- 🧠 **延伸阅读**：
    - 《领域驱动设计》（Eric Evans）—— 深化 Domain Model
    - 《实现领域驱动设计》（Vaughn Vernon）
    - Martin Fowler 官网（[martinfowler.com](https://martinfowler.com/)）持续更新模式解释

---

> 💡 虽然该书年代较早，但其**模式语言**已成为软件工程通用词汇。掌握它，能让你在架构讨论中“说同一种语言”。

如需某类模式的详细示例（如用 Spring Boot 实现 Repository + Unit of Work），欢迎继续提问！