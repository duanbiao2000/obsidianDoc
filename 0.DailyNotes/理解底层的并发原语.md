以下示例覆盖 goroutines、threads、promises、async/await 四类常见并发原语，示范“理解底层并主动管理资源”所需的关键手法。所有片段都可直接复用在商用代码中。

---

- **Go：goroutines + channel + context 控制协程生命周期**

```go
// Package main 演示如何使用 context 管理 goroutine 生命周期，
// 实现一个安全的工作池（WorkerPool），确保所有资源在关闭时正确回收。
package main

import (
	"context"
	"fmt"
	"sync"
	"time"
)

// WorkerPool 工作池结构体，用于管理一组工作协程、任务投递和结果收集，
// 通过 context 实现协程生命周期的统一管控。
type WorkerPool struct {
	wg       sync.WaitGroup       // wg：等待所有工作协程退出的同步等待组
	ctx      context.Context      // ctx：管理工作池生命周期的上下文
	cancel   context.CancelFunc   // cancel：触发上下文取消的函数（关闭工作池时调用）
	taskCh   chan int             // taskCh：任务投递通道，用于向工作协程发送任务
	resultCh chan int             // resultCh：结果返回通道，用于接收工作协程的执行结果
}

// NewWorkerPool 创建并初始化一个工作池实例。
//
// 参数：
//   workerCount - 工作协程的数量（同时并发执行任务的goroutine数）
//
// 返回值：
//   *WorkerPool - 初始化完成的工作池指针，已启动所有工作协程
func NewWorkerPool(workerCount int) *WorkerPool {
	ctx, cancel := context.WithCancel(context.Background())
	wp := &WorkerPool{
		ctx:      ctx,
		cancel:   cancel,
		taskCh:   make(chan int),
		resultCh: make(chan int),
	}
	wp.startWorkers(workerCount)
	return wp
}

// startWorkers 启动指定数量的工作协程，内部方法（不对外暴露）。
// 每个工作协程会循环监听任务通道或上下文取消信号，直至工作池关闭。
//
// 参数：
//   workerCount - 要启动的工作协程数量
func (wp *WorkerPool) startWorkers(workerCount int) {
	for i := 0; i < workerCount; i++ {
		wp.wg.Add(1)
		// 启动工作协程，传入协程ID用于调试（实际业务中可移除）
		go func(id int) {
			defer wp.wg.Done() // 协程退出时通知等待组
			for {
				select {
				case <-wp.ctx.Done(): // 监听工作池关闭信号
					fmt.Printf("worker %d: 收到关闭信号，退出\n", id)
					return
				case task, ok := <-wp.taskCh: // 监听任务通道
					if !ok { // 任务通道关闭，退出协程
						fmt.Printf("worker %d: 任务通道关闭，退出\n", id)
						return
					}
					// 模拟耗时任务执行（实际场景替换为业务逻辑）
					time.Sleep(50 * time.Millisecond)
					wp.resultCh <- task * 2 // 将任务结果发送到结果通道
				}
			}
		}(i)
	}

// Submit 非阻塞地向工作池提交一个任务。
//
// 参数：
//   task - 要提交的任务（此处为int类型，实际可根据业务定义为任意类型）
//
// 返回值：
//   bool - 任务提交是否成功：true表示提交成功，false表示工作池已关闭
func (wp *WorkerPool) Submit(task int) bool {
	select {
	case <-wp.ctx.Done(): // 工作池已关闭，拒绝提交
		return false
	case wp.taskCh <- task: // 成功将任务投递到任务通道
		return true
	}
}

// Close 关闭工作池，确保所有资源安全回收。
// 执行逻辑：1. 触发上下文取消（通知所有工作协程退出）；2. 关闭任务通道（阻止新任务提交）；
// 3. 等待所有工作协程完成当前任务并退出；4. 关闭结果通道（通知结果接收者停止监听）。
func (wp *WorkerPool) Close() {
	wp.cancel()       // 触发上下文取消
	close(wp.taskCh)  // 关闭任务通道
	wp.wg.Wait()      // 等待所有工作协程退出
	close(wp.resultCh) // 关闭结果通道
	fmt.Println("工作池已完全关闭，所有资源已回收")
}

// main 程序入口，演示 WorkerPool 的使用流程。
func main() {
	// 创建一个包含4个工作协程的工作池
	pool := NewWorkerPool(4)

	// 启动一个协程，持续接收并打印工作池的执行结果
	go func() {
		for result := range pool.resultCh {
			fmt.Printf("收到结果: %d\n", result)
		}
		fmt.Println("结果通道已关闭，停止接收结果")
	}()

	// 向工作池提交10个任务
	for i := 0; i < 10; i++ {
		if !pool.Submit(i) { // 若提交失败（工作池已关闭），则终止提交
			fmt.Printf("任务 %d 提交失败，工作池已关闭\n", i)
			break
		}
		fmt.Printf("任务 %d 提交成功\n", i)
	}

	// 等待一段时间，确保所有任务有足够时间执行（实际场景可根据业务调整或移除）
	time.Sleep(500 * time.Millisecond)

	// 关闭工作池
	pool.Close()
}
```

- 亮点：
  - `context.Context` 用于显式终止 goroutine，避免泄漏。
  - `sync.WaitGroup` 确保主流程等待所有协程结束。
  - `chan` 控制任务和结果的安全传递，避免竞态写入。

---

- **Python：threading + Lock 避免竞态 + Queue 保障消息有序**

```python
import threading
import queue
import time

class Inventory:
    def __init__(self):
        self._stock = 0
        self._lock = threading.Lock()

    def add_stock(self, amount):
        with self._lock:
            new_stock = self._stock + amount
            time.sleep(0.01)  # 模拟处理耗时
            self._stock = new_stock

    def remove_stock(self, amount):
        with self._lock:
            if self._stock < amount:
                raise ValueError("库存不足")
            new_stock = self._stock - amount
            time.sleep(0.01)
            self._stock = new_stock

    @property
    def stock(self):
        with self._lock:
            return self._stock

def worker(inventory, tasks):
    while True:
        try:
            action, amount = tasks.get(timeout=0.1)
        except queue.Empty:
            break
        if action == "add":
            inventory.add_stock(amount)
        elif action == "remove":
            inventory.remove_stock(amount)
        tasks.task_done()

if __name__ == "__main__":
    inventory = Inventory()
    tasks = queue.Queue()

    # 投递任务
    for _ in range(100):
        tasks.put(("add", 5))
        tasks.put(("remove", 3))

    threads = []
    for _ in range(5):
        t = threading.Thread(target=worker, args=(inventory, tasks), daemon=True)
        t.start()
        threads.append(t)

    tasks.join()
    print("最终库存:", inventory.stock)
```

- 亮点：
  - `with self._lock` 确保读写库存时互斥，避免竞态。
  - `queue.Queue` 天然线程安全，自动管理任务同步。

---

- **JavaScript (Node.js)：Promise + Mutex 管理共享资源**

```javascript
// 简易 Mutex 实现
class Mutex {
  constructor() {
    this._queue = [];
    this._locked = false;
  }

  lock() {
    return new Promise(resolve => {
      if (!this._locked) {
        this._locked = true;
        resolve(this.unlock.bind(this));
      } else {
        this._queue.push(resolve);
      }
    });
  }

  unlock() {
    if (this._queue.length > 0) {
      const nextResolve = this._queue.shift();
      nextResolve(this.unlock.bind(this));
    } else {
      this._locked = false;
    }
  }
}

class Counter {
  constructor() {
    this.value = 0;
    this.mutex = new Mutex();
  }

  async increase() {
    const release = await this.mutex.lock();
    try {
      const next = this.value + 1;
      await new Promise(res => setTimeout(res, 10)); // 模拟耗时
      this.value = next;
    } finally {
      release();
    }
  }
}

async function main() {
  const counter = new Counter();
  const tasks = Array.from({ length: 100 }, () => counter.increase());
  await Promise.all(tasks);
  console.log("Counter:", counter.value);
}

main();
```

- 亮点：
  - 自定义 `Mutex` 保障 `increase` 的原子性。
  - `Promise.all` 并发执行但依赖锁序列化关键区，适用于 Node.js API 服务。

---

- **TypeScript + async/await + AbortController 管理请求超时**

```typescript
import fetch from "node-fetch";

async function fetchWithTimeout(url: string, timeoutMs: number) {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), timeoutMs);

  try {
    const res = await fetch(url, { signal: controller.signal });
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }
    return await res.json();
  } finally {
    clearTimeout(timeout);
  }
}

async function main() {
  try {
    const data = await fetchWithTimeout("https://api.example.com/report", 2000);
    console.log("data", data);
  } catch (err) {
    console.error("请求超时或失败", err);
  }
}

main();
```

- 亮点：
  - `AbortController` 主动终止超时请求，避免资源悬挂。
  - `try/finally` 保证超时计时器被清除，防止内存泄漏。

---

- **加分：竞态检测（Go 工具链示例）**

```bash
go test -race ./...
```

- 可在 CI 中启用，检测数据竞争。搭配 `go vet` 等静态分析工具形成“像个成年人”的防线。

---

这些代码片段展示了如何在不同环境中**理解并应用底层并发原语、显式管理锁与同步机制、设计退出路径与错误处理**，从而将理念落地到可直接部署的商用场景。