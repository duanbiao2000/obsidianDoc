---
title: Backend Architecture | toeverything/AFFiNE
source: https://deepwiki.com/toeverything/AFFiNE/3-backend-architecture
author:
  - "[[DeepWiki]]"
published: 
created: 2025-04-30
description: AFFiNE 的后端架构概览，基于 NestJS、GraphQL、Prisma、PostgreSQL 和 Rust 本地模块，重点介绍其 AI 系统和部署模型。
tags:
  - clippings
  - Backend
  - NestJS
  - GraphQL
  - AI
---
## 代理系统

本页面记录了 LangChain 中的代理系统，该系统提供了一个框架，用于创建使用大型语言模型 (LLM) 作为推理引擎来确定应采取哪些行动的代理。代理可以调用工具、观察结果并按顺序做出决策。有关具体代理实现模式的信息，请参阅 [链类型和实现](https://deepwiki.com/langchain-ai/langchain/5.1-chain-types-and-implementation) 。有关工具的详细信息，请参阅 [工具系统](https://deepwiki.com/langchain-ai/langchain/6.1-tool-system) 。

## 什么是代理？

代理是一种使用 LLM 作为推理引擎的系统，它决定要采取哪些操作以及执行这些操作所需的输入。执行操作后，结果将反馈到 LLM，以确定是否需要执行更多操作或任务是否已完成。代理对于需要多步推理并与外部工具交互的任务尤其有用。

```
Agent SystemLanguage ModelReasoning EngineAction SelectionToolsExecutionUser InputResult to User
```

来源：docs/docs/tutorials/agents.ipynb、docs/docs/how\_to/agent\_executor.ipynb、docs/docs/tutorials/sql\_qa.ipynb

## 代理架构

LangChain 代理架构由几个关键组件组成：

1. **LLM/聊天模型** ：进行推理和决策的代理大脑
2. **工具** ：代理可以调用来与世界互动的外部函数
3. **编排框架** ：管理代理的状态和执行流程
4. **记忆/持久性** ：存储对话历史和回合之间的状态

## 实施方法

LangChain 提供了两种实现代理的主要方法：

[LangGraph](https://github.com/langchain-ai/langchain/blob/b36c2bf8/LangGraph) 是 LangChain 中推荐的代理构建框架。它通过基于图的设计，为代理构建提供了一种更灵活、更模块化的方法。

```
LangGraph Agent StructureCall ToolFinishedSTARTState Definition
- question
- context
- messages
- etc.LLM NodeCondition Node
(Tool or Finish?)Tool NodeEND
```

来源：docs/docs/tutorials/qa\_chat\_history.ipynb、docs/docs/tutorials/agents.ipynb

### 2\. AgentExecutor（遗留）

对于更简单的用例或遗留支持， `AgentExecutor` 提供了更直接的实现。

来源：docs/docs/how\_to/agent\_executor.ipynb

## ReAct 模式

LangChain 中最常见的代理模式是 ReAct（推理 + 行动）模式，它鼓励模型逐步思考问题并根据需要采取行动。

```
ReAct Pattern FlowThought: Think about what to doAction: Choose a tool to useObservation: Result from toolAnswer: Final response to user
```

来源：docs/docs/tutorials/agents.ipynb

## 工具集成

代理依靠工具与外部系统进行交互。在 LangChain 中，可以通过多种方式创建工具：

1. 从使用 `@tool` 装饰器的 Python 函数
2. 来自 Pydantic 模型或 TypedDict 类
3. 从 Runnables 使用 `.as_tool()`
4. 通过子类化 `BaseTool`
```
Tool ComponentsTool Creation Methods@tool decoratorStructuredTool.from_function().as_tool()subclassPython FunctionTool ObjectPydantic ModelRunnableBaseTool Classname: strdescription: strargs_schema: BaseModel_run(): Any_arun(): Coroutine
```

来源：docs/docs/how\_to/custom\_tools.ipynb、docs/docs/how\_to/tool\_calling.ipynb、docs/docs/how\_to/convert\_runnable\_to\_tool.ipynb

## 将工具与法学硕士 (LLM) 绑定

要使 LLM 能够使用工具，必须将工具绑定到模型：

```
"Agent Executor/Graph""Model with Tools""Chat Model"Developer"Agent Executor/Graph""Model with Tools""Chat Model"DeveloperCreate chat modelmodel.bind_tools([tool1, tool2, ...])Creates model with tool schemaCreate agent with bound modelUser queryTool callsExecute toolsTool resultsFinal answer
```

来源：docs/docs/how\_to/tool\_calling.ipynb、docs/docs/tutorials/agents.ipynb

## 记忆与持久性

代理通常需要在多个交互中保持状态，特别是对于基于对话的应用程序。

```
LangGraph PersistenceMemorySaverSQLiteCheckpointerPostgresCheckpointerThread State
(messages, context, etc.)Next Interaction
```

资料来源：docs/docs/tutorials/chatbot.ipynb、docs/docs/tutorials/qa\_chat\_history.ipynb

## 创建一个简单的代理

创建代理的最简单方法是使用 LangGraph 的预构建组件：

```
Agent CreationChat Model
(e.g., ChatOpenAI)create_react_agent()Tools
(e.g., TavilySearchResults)MemorySaverAgent Executor
```

来源：docs/docs/tutorials/agents.ipynb

## 代理应用程序示例

Agent 可以应用于各种场景：

1. **对话代理** ：可以在需要时使用工具的聊天机器人
2. **RAG 代理** ：搜索文档并与知识库交互
3. **SQL 代理** ：查询数据库以回答有关数据的问题
4. **多工具代理** ：协调多种不同的工具
```
Agent Application ExamplesusesusesusesusesConversational AgentDatabase Query AgentSearch & Research AgentDocument Analysis AgentChat History
Search ToolsSQL Tools
Data Analysis ToolsWeb Search
Document RetrievalDocument Loaders
Text Analysis Tools
```

Sources: docs/docs/tutorials/qa\_chat\_history.ipynb, docs/docs/tutorials/sql\_qa.ipynb, docs/docs/tutorials/agents.ipynb

## Agent Output Handling

Agents can generate various types of outputs that need to be handled appropriately:

1. **Tool Calls**: When the agent decides to call a tool
2. **Final Answers**: When the agent has completed its task
3. **Streaming Outputs**: Progressive outputs during agent execution
4. **Artifacts**: Additional data or files produced during execution
```
Agent Output HandlingAgentTool CallsFinal AnswerStreaming OutputArtifactsTool ExecutionUserUI UpdatesStorage/Display
```

Sources: docs/docs/how\_to/tool\_calling.ipynb, docs/docs/how\_to/tool\_artifacts.ipynb, docs/docs/how\_to/tool\_stream\_events.ipynb

## Migrating from Legacy Agents

LangChain provides a migration path from legacy `AgentExecutor` to modern LangGraph agents:

```
Migration PathAgentExecutor
with LLMChainAgentExecutor
with LCELLangGraph
Agent
```

Sources: docs/docs/how\_to/agent\_executor.ipynb, docs/docs/how\_to/migrate\_agent.ipynb

## Debugging and Monitoring

Tracing and debugging agents is crucial for development and production use:

```
Debugging ToolsLangSmith TracingCallback HandlersLoggingAgent ExecutionStep-by-Step TracesCustom MonitoringDebug Information
```

Sources: docs/docs/tutorials/agents.ipynb, docs/docs/tutorials/qa\_chat\_history.ipynb

## Code Structure Overview

The agent system is implemented across multiple files and packages:

```
Code Structurelangchain packageLegacy Agent Implementationslanggraph packageModern Agent Frameworklangchain-core packageCore Interfaces
Runnable, Tool, etc.
```

Sources: docs/docs/tutorials/agents.ipynb, docs/docs/how\_to/agent\_executor.ipynb

## Advanced Techniques

### Few-Shot Examples

Providing examples can improve agent performance:

```
Few-Shot ExamplesExample Use CasesAgent PromptImproved Tool Selection
```

Sources: docs/docs/how\_to/example\_selectors\_langsmith.ipynb, docs/docs/how\_to/extraction\_examples.ipynb

### Runtime Configuration

Agents can be configured at runtime with special values:

```
Runtime ConfigurationRunnableConfigTool BehaviorStreaming SettingsCallback Handlers
```

Sources: docs/docs/how\_to/tool\_runtime.ipynb, docs/docs/how\_to/configure.ipynb

## Common Challenges and Solutions

| Challenge | Solution |
| --- | --- |
| Agent calling incorrect tools | Improve tool descriptions and use few-shot examples |
| Agent not using tools when needed | Use tool\_choice parameter to force tool usage |
| Long-running tools | Implement streaming for tools with progress updates |
| Memory management for long conversations | Use appropriate trimming strategies |
| Handling tool failures | Implement error handling and fallback mechanisms |

Sources: docs/docs/how\_to/tool\_calling.ipynb, docs/docs/how\_to/streaming.mdx

## Conclusion

The Agent System in LangChain provides a flexible framework for building AI applications that can reason through problems and interact with external tools. By leveraging the power of LLMs for reasoning and decision-making, and combining it with the ability to access specialized tools, agents can solve complex tasks that would be difficult for either component alone.

Whether you're using the modern LangGraph-based approach or the legacy AgentExecutor, understanding the core patterns and components of the agent system will help you build more effective AI applications.


Express.js 是一个快速、简洁、极简的 Node.js Web 框架。本文档将介绍 Express.js、其核心理念和高级架构。它还将讲解 Express.js 的基本组件以及它们如何协同处理 HTTP 请求和响应。

有关特定组件的详细信息，请参阅更有针对性的页面，例如 [应用程序对象](https://deepwiki.com/expressjs/express/2.1-application-object) 、 [请求对象](https://deepwiki.com/expressjs/express/2.2-request-object) 、 [响应对象](https://deepwiki.com/expressjs/express/2.3-response-object) 和 [中间件](https://deepwiki.com/expressjs/express/3-middleware) 。

## 核心理念

Express.js 在设计时充分考虑了简单性和灵活性。官方文档中提到：

> Express 的理念是为 HTTP 服务器提供小型、强大的工具，使其成为单页应用程序、网站、混合应用程序或公共 HTTP API 的绝佳解决方案。

Express.js 不强制开发人员使用任何特定的 ORM 或模板引擎。它提供了一层薄薄的基础 Web 应用程序功能，同时又不会遮挡 Node.js 的功能。

定义 Express.js 的关键属性包括：

- **极简主义** ：专注于核心功能，没有不必要的抽象
- **不固执己见** ：不强制执行特定的模式或结构
- **灵活** ：轻松与其他模块和中间件集成
- **以性能为导向** ：在 Node.js HTTP 功能之上最小化开销

资料来源： [自述文件.md 3](https://github.com/expressjs/express/blob/f9954dd3/Readme.md#L3-L3) [自述文件.md 109-116](https://github.com/expressjs/express/blob/f9954dd3/Readme.md#L109-L116)

## Express.js 架构概述

### 核心组件及其关系

```
Main FunctionalitiesCore ObjectsExpress Application CreationcreateApplication()app functionEventEmitter methodsapplication prototypeapp.requestapp.responseapp.routerRequest prototypeResponse prototypehttp.IncomingMessagehttp.ServerResponseapp.handle(req, res, next)app.use(fn)app.listen()app.set(setting, val)router.handle(req, res, done)Routesres.send()res.json()res.render()req.paramsreq.query
```

Express.js 架构遵循模块化设计，关注点清晰分离。该框架通过原型继承和函数组合扩展了 Node.js 的 HTTP 功能。

主要建筑特征：

1. **函数作为应用程序** ：主应用程序既是一个 JavaScript 函数（传递给 HTTP 服务器），又是一个具有属性和方法的对象
2. **原型继承** ：请求和响应对象通过原型链从 Node.js HTTP 对象继承
3. **中间件管道** ：请求处理通过中间件功能遵循管道模式
4. **基于事件** ：利用 Node.js 的事件驱动架构

资料来源： [lib/express.js 15-56](https://github.com/expressjs/express/blob/f9954dd3/lib/express.js#L15-L56) [lib/application.js 39-41](https://github.com/expressjs/express/blob/f9954dd3/lib/application.js#L39-L41) [lib/request.js 29-31](https://github.com/expressjs/express/blob/f9954dd3/lib/request.js#L29-L31) [lib/response.js 39-41](https://github.com/expressjs/express/blob/f9954dd3/lib/response.js#L39-L41)

### 请求-响应生命周期


当 Express 应用程序收到请求时，它会经过一系列明确定义的步骤：

1. **应用程序调用** ：使用请求和响应对象调用 Express 应用程序函数（由 `createApplication()` 创建）
2. **请求/响应增强** ：原生 Node.js 请求和响应对象通过 Express 原型得到增强
3. **中间件处理** ：请求按顺序通过每个中间件功能
4. **路由匹配** ：路由器尝试将请求路径和方法与定义的路由进行匹配
5. **处理程序执行** ：如果路由匹配，则执行其处理程序函数
6. **响应生成** ：生成响应并发送回客户端

资料来源： [lib/application.js 152-178](https://github.com/expressjs/express/blob/f9954dd3/lib/application.js#L152-L178) [lib/express.js 36-39](https://github.com/expressjs/express/blob/f9954dd3/lib/express.js#L36-L39)

## 核心组件详情

### Application 对象

应用程序对象是 Express.js 应用程序的核心组件。它是通过调用 `express` 模块导出的 `express()` 函数创建的：

```
const express = require('express');
const app = express();
```

该对象具有多种作用：

1. **HTTP 请求处理程序** ：作为 Node.js HTTP 服务器的回调函数
2. **配置容器** ：通过 `app.set()` 存储应用程序设置
3. **中间件管理器** ：通过 `app.use()` 注册中间件
4. **路由器** ：通过 HTTP 方法函数定义路由（ `app.get()` 、 `app.post()` 等）
5. **服务器初始化程序** ：通过 `app.listen()` 启动 HTTP 服务器

应用程序对象继承自 Node.js 的 `EventEmitter` ，允许它处理事件，并从应用程序原型中获取其大部分功能 [lib/application.js](https://github.com/expressjs/express/blob/f9954dd3/lib/application.js)

主要使用方法：

- `app.set(name, value)` ：配置应用程序设置
- `app.get(name)` ：检索应用程序设置
- `app.use([path,] function)` ：添加中间件
- `app.METHOD(path, [callback...], callback)` ：定义 HTTP 方法的路由
- `app.listen([port][, host][, backlog][, callback])` ：启动 HTTP 服务器
- `app.render(view, [options], callback)` ：渲染模板

资料来源： [lib/express.js 36-56](https://github.com/expressjs/express/blob/f9954dd3/lib/express.js#L36-L56) [lib/application.js 59-141](https://github.com/expressjs/express/blob/f9954dd3/lib/application.js#L59-L141) [lib/application.js 598-606](https://github.com/expressjs/express/blob/f9954dd3/lib/application.js#L598-L606)

### 请求和响应对象

Express.js 使用附加属性和方法扩展了 Node.js 的本机 HTTP 请求和响应对象：

**请求对象（ `req` ）：**

- 从 `http.IncomingMessage` 扩展
- 提供对请求数据（如参数、查询字符串和标头）的访问
- 添加用于内容协商和请求检查的辅助方法

**响应对象（ `res` ）：**

- 从 `http.ServerResponse` 扩展
- 添加发送各种类型响应的方法
- 提供 Cookie、重定向和内容协商的实用程序

关键请求属性和方法：

- `req.params` ：路由参数
- `req.query` ：解析的查询字符串
- `req.body` ：解析的请求主体（需要中间件）
- `req.get(field)` ：获取 HTTP 标头
- `req.is(type)` ：检查内容类型
- `req.accepts(types)` ：内容协商

主要应对方法：

- `res.send(body)` ：发送带有自动内容类型的响应
- `res.json(obj)` ：发送 JSON 响应
- `res.render(view, [locals])` ：渲染模板
- `res.redirect([status,] path)` ：重定向请求
- `res.status(code)` ：设置 HTTP 状态代码
- `res.type(type)` ：设置内容类型

响应对象的 `send()` 方法特别重要，因为它处理不同的数据类型并设置适当的标头：

```
res.send(body)Determine body typestring?Buffer/Uint8Array?object?boolean/number?Set Content-Type: text/htmlEncode as UTF-8Set Content-Type: application/octet-streamCall res.json(body)Convert to stringGenerate ETag if enabledSend to clientCheck req.freshSend 304 if freshSend response body
```

资料来源： [lib/request.js 29-514](https://github.com/expressjs/express/blob/f9954dd3/lib/request.js#L29-L514) [lib/response.js 39-1039](https://github.com/expressjs/express/blob/f9954dd3/lib/response.js#L39-L1039) [lib/response.js 123-223](https://github.com/expressjs/express/blob/f9954dd3/lib/response.js#L123-L223)

### 中间件系统

中间件函数是 Express.js 中的一个基本概念。它们构成一个按顺序处理请求的管道，每个中间件都具有以下功能：

1. 执行代码
2. 修改请求和响应对象
3. 结束请求-响应周期
4. 调用链中的下一个中间件

中间件功能的形式如下：

```
function middleware(req, res, next) {
  // Process the request
  next(); // Call next middleware
}
```

Express 应用程序通过 `app.use()` 方法使用中间件：

```
app.use(middleware);          // Apply to all routes
app.use('/path', middleware); // Apply to specific path
```

Express 提供的内置中间件：

- `express.json()` ：解析 JSON 请求主体
- `express.urlencoded()` ：解析 URL 编码的表单数据
- `express.raw()` ：将请求主体解析为缓冲区
- `express.text()` ：将请求主体解析为字符串
- `express.static()` ：提供静态文件



## Routing System

Express.js provides a powerful routing system that maps HTTP methods and URL patterns to specific handler functions. Routes are defined using methods corresponding to HTTP verbs on the application object:

```
app.get('/users', function(req, res) { /* ... */ });
app.post('/users', function(req, res) { /* ... */ });
app.put('/users/:id', function(req, res) { /* ... */ });
app.delete('/users/:id', function(req, res) { /* ... */ });
```

Under the hood, Express.js uses the `router` module, which is created lazily when first accessed through the `app.router` property. The router is responsible for:

1. Matching request paths to defined routes
2. Extracting route parameters
3. Executing route handlers
4. Supporting middleware at the router level

Route paths can contain:

- Simple strings
- String patterns
- Regular expressions
- Parameters (`:paramName`)
- Optional segments (`?`)
- Wildcards (`*`)

For more detailed information about routing, see the [Routing System](https://deepwiki.com/expressjs/express/2.4-routing-system) page.

Sources: [lib/application.js 69-82](https://github.com/expressjs/express/blob/f9954dd3/lib/application.js#L69-L82) [lib/application.js 470-482](https://github.com/expressjs/express/blob/f9954dd3/lib/application.js#L470-L482)

## Basic Usage Example

Here's a minimal Express.js application that demonstrates the core concepts:

```
const express = require('express');
const app = express();

// Application-level middleware
app.use((req, res, next) => {
  console.log(\`${req.method} ${req.url}\`);
  next();
});

// Route definitions
app.get('/', (req, res) => {
  res.send('Hello World');
});

app.get('/api/data', (req, res) => {
  res.json({ message: 'This is JSON data' });
});

app.get('/users/:id', (req, res) => {
  res.send(\`User ID: ${req.params.id}\`);
});

// Start the server
app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

This example shows:

1. Creating an Express application
2. Adding application-level middleware
3. Defining routes with different response types
4. Using route parameters
5. Starting the HTTP server
