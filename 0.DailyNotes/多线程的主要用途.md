---
view-count: 5
---
# [[多线程的主要用途]]

## 1. 核心逻辑：并行计算模型 (Parallelism Paradigm)

**系统优化目标：**
- **吞吐量最大化**：利用多核 ($N_{core}$) 消除计算瓶颈。
- **响应延迟最小化**：将 I/O 与耗时计算从关键路径（如 UI 线程）剥离。

**分解策略：**
- **功能分解 (Functional)**：异构任务并行（例：Thread A = UI, Thread B = DB I/O）。
- **数据分解 (Data)**：同构任务分片（例：将 $10^9$ 数据拆分为 $N$ 份交给 $N$ 个线程并行处理）。

## 2. 性能参数矩阵 (Performance Parameters)

| 变量 | 影响因子 | 优化协议 |
| :--- | :--- | :--- |
| **任务粒度 (Granularity)** | 同步频率 / 调度开销 | 优先**粗粒度**；细粒度任务使用 SIMD 或指令级并行。 |
| **上下文切换 (Context Switch)** | $T_{slice}$ (10-30ms) | 线程数 $\leq$ 逻辑核心数 ($N_{logic}$)；避免过载。 |
| **同步成本 (Sync Overhead)** | Mutex / Semaphore | 最小化临界区；优先使用 `atomic` 或无锁算法。 |
| **亲和性 (Affinity)** | Cache Locality | 使用 `GetProcessAffinityMask` 绑定核心，减少 L3 扰动。 |

## 3. 硬件约束与缓存策略 (Hardware Constraints)

- **缓存行冲突 (False Sharing)**：不同线程修改同一 64-byte Cache Line 会导致缓存失效。
    - **Operator**：对齐数据结构至 64 字节；确保线程本地存储 (TLS)。
- **超线程 (SMT/HT)**：逻辑线程共享物理资源。
    - **Edge Case**：计算密集型任务（无 Cache Miss）开启 HT 可能导致性能下降；IO 密集型任务增益明显。
- **可见性保证**：声明 `volatile` 或使用 Memory Barriers，防止编译器将变量优化至寄存器。

## 4. 执行指南 (Execution Protocol)

### **线程安全准则**
- **Stateless**：函数不依赖 `static` 或全局变量。
- **Local Priority**：优先使用栈内存，减少堆竞争。
- **Async Pattern**：长耗时任务必须异步，防止阻塞调用链。

### **工具链选择**
- **C++**：`std::thread` / OpenMP (指令级并行)。
- **Go**：利用 Goroutine 配合 `context` 实现级联取消 [^1]。
- **High Perf**：直接调用 MKL 等硬件优化库。

## 关联笔记
- [[Go开发者实战指南]] (高效并发控制实践) [^1]
- [[思想工具模板库]] (Trade-off 决策矩阵应用) [^2]
- [[学习框架2.0]] (复杂系统抽象与模式识别) [^3]
