
**第10章 Multithreading（多线程）优化内容摘要：**

- **多线程的意义与方式**
    
    - 多线程用于让不同任务或同一任务的多个数据块“并行”执行，尤其是在多核、多CPU系统下大幅提升吞吐量。
        
    - 主要分为“功能分解”（不同线程做不同类型任务，比如UI和后台计算分开）与“数据分解”（同一任务分块给多个线程并行处理）。
        
- **划分任务粒度**
    
    - 粗粒度任务（每个线程可长时间独立运行），最适合多线程并行；细粒度任务（频繁同步），多线程收益较低，推荐用向量化或乱序执行机制优化。
        
- **编程与工具支持**
    
    - 手动创建线程分配任务适用于主流编译器。
        
    - 自动并行（GCC、Intel编译器可尝试自动多线程优化）。
        
    - OpenMP 指令集和 C++ 标准库 std::thread 为主流并行编程选择。
        
    - 部分高性能库（如 Intel MKL）内部支持多线程并行，直接调用。
        
- **硬件资源与线程分配**
    
    - 生效线程数不应超过 CPU 核心/逻辑处理器数（如用 GetProcessAffinityMask 查询）。
        
    - 多线程有助于后台计算、文件/网络/数据库IO与用户界面响应分隔，如后台低优先级线程做重计算，主线程专注快速响应输入。
        
- **缓存和数据冲突**
    
    - 多核心通常共享最后一级缓存，线程间如果访问和修改同一区域数据，会造成缓存争用和效率显著下降。
        
    - 推荐每个线程独立分配处理数据，只在最后汇总，数据结构按缓存行（通常64字节）对齐，避免多线程写同一缓存行。
        
- **通信与同步**
    
    - 线程间同步（如信号量、互斥锁、消息队列）成本高，应最小化通信。
        
    - 共享变量声明为 volatile，避免被编译器优化到寄存器。
        
- **线程安全**
    
    - 多线程环境下不要依赖 static 或全局变量，所有数据应声明在线程本地或以结构体分配。
        
    - 函数和类要保证“线程安全”，即不含可能共享的静态状态。
        
- **硬件超线程（simultaneous multithreading，SMT/Hyperthreading）**
    
    - 一个物理核心可跑多个逻辑线程（如4核可跑8线程），但资源必定竞争，无法完全倍增速度。若任务大量缓存miss或分支错误，有增益；否则效率反而下降。
        

**结论：**  
多线程优化需合理规划任务分解、线程数、数据布局、缓存和同步方式。思想上追求最小冲突、最大独立性和最优资源利用。在多核环境和大量后台任务场景效果显著，建议充分利用标准库、OpenMP及专用库并结合实际测量和调优。

1. [https://agner.org/optimize/optimizing_cpp.pdf](https://agner.org/optimize/optimizing_cpp.pdf)

**7.31 Threads 章节内容总结：**


- **多线程的主要用途**
  - 多线程用于让软件同时或伪同时执行多个任务，充分利用现代多核CPU资源。
  - 典型场景如：前台线程响应用户输入、后台低优先级线程做繁重计算或任务（如拼写检查、重排、文件/网络操作）。

- **线程调度与上下文切换成本**
  - 多线程会由操作系统分配时间片，每个线程轮流获得CPU，前台线程常 30ms，后台约10ms。
  - 每次上下文切换需刷新各类缓存，会造成显著性能损耗。
  - 减少上下文切换 (延长时间片) 可提速，但可能让输入响应变慢。

- **任务划分原则**
  - 功能分解（functional decomposition）：不同线程分别处理不同类型任务
  - 数据分解（data decomposition）：多线程并行处理数据块，适合高性能计算
  - 若一项耗时长，建议单独分出线程，避免拖慢主线程（如UI）。

- **线程创建与销毁成本**
  - 创建/销毁线程有较高开销，避免将短任务分配到独立线程。

- **线程数与CPU核心数**
  - 高效利用多核系统时，线程数不应超过逻辑核心数（系统API可查询，如 GetProcessAffinityMask）。
  - 支持自动并行（如GCC、Intel编译器可自动多线程）、OpenMP指令、C++标准库 std::thread。

- **多线程资源和缓存冲突**
  - 多核往往共享最后一级缓存，多线程处理不同区域数据会造成缓存竞争，影响效率。
  - 建议每个线程使用独立数据结构，数据合并工作在所有线程完成后进行。
  - 线程私有数据推荐本地声明于线程函数（即用栈），或按结构体分配并对齐到缓存行（通常64字节）。

- **线程同步与通信**
  - 线程间通信（如信号量、互斥锁、消息队列等）成本高，应最小化必需通信部分。
  - 多线程共享单一数据区会导致频繁等待和性能损失，推荐分块后最终合并结果。

- **线程安全准则**
  - 共享变量必须声明 volatile，防止编译器优化至寄存器（线程间不共享寄存器）。
  - 不要在多线程通用函数或类中依赖 static 或全局变量。应尽量将数据放到各自线程栈。

- **多线程环境下的技术建议**
  - 线程安全函数不能用 static 变量。
  - 线程需要独立栈，避免互相竞争缓存空间。
  - 对于需要大量并发任务，可评估是否采用 OpenMP、专用并行库或手动划分。

- **小结**
  多线程显著提升多核系统或有大量后台任务场景下的性能，但需注意线程启动、切换和同步成本，合理规划线程数、数据组织和资源。避免频繁同步和缓存竞争，充分利用线程本地存储和分块并行处理。

[1](https://agner.org/optimize/optimizing_cpp.pdf)