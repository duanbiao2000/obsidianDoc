---
aliases: null
date: 2025-12-07 13:31
tags: null
source: null
update: null
rating: null
related: null
---

<iframe src="https://claude.site/public/artifacts/5a86b344-56b4-44d5-8ec5-5462cf80811b/embed" title="Claude Artifact" width="100%" height="600" frameborder="0" allow="clipboard-write" allowfullscreen></iframe>

<iframe src="https://claude.site/public/artifacts/561285cf-0f2f-4507-a3df-145117cf0861/embed" title="Claude Artifact" width="100%" height="600" frameborder="0" allow="clipboard-write" allowfullscreen></iframe>

# 项目拆分实战检查表

> 使用场景：每当你接到一个新项目或需要重新组织现有项目时，用这份清单来指导你的拆分决策。

---

## 第一步：理解问题本质（拆分前必做）

### 问题1：这个系统解决什么核心问题？

```
例子（实时通知系统）：
核心问题 = "如何可靠地将消息投递到各种渠道"

例子（电商推荐系统）：
核心问题 = "如何根据用户行为快速计算个性化推荐"

例子（支付系统）：
核心问题 = "如何确保每笔交易恰好被处理一次"
```

**你的答案：**

```
核心问题 = _________________________
```

---

### 问题2：哪些部分是"易变的"，哪些是"稳定的"？

做这个表格：

| 组件    | 变化频率 | 为什么         |
| ----- | ---- | ----------- |
| 业务规则  | 高    | 产品需求经常改     |
| 通知渠道  | 中    | 每半年可能加一个新渠道 |
| 重试策略  | 低    | 技术债，很少改     |
| 数据库存储 | 低    | 架构基本不变      |

---

### 问题3：哪些部分会"一起改"，哪些"独立改"？

做一个矩阵，填"S"（一起改）或"I"（独立改）：

|             | 业务规则 | Email驱动 | SMS驱动 | 监控系统 |
| ----------- | ---- | ------- | ----- | ---- |
| **业务规则**    | S    | -       | -     | -    |
| **Email驱动** | I    | S       | I     | I    |
| **SMS驱动**   | I    | I       | S     | I    |
| **监控系统**    | I    | I       | I     | S    |

**含义：**

- 业务规则改了，Email和SMS驱动逻辑都要变（它们都使用业务规则）→ 说明业务规则和驱动应该分层
- Email和SMS驱动互相独立 → 说明不应该耦合

---

## 第二步：识别关键维度（拆分的方向）

### 维度1：时间维度（按变化频率）

```
┌─────────────────────────────────────┐
│  易变的 / 频繁变化（上层）          │
│  - 业务规则、产品逻辑              │
├─────────────────────────────────────┤
│  中等变化（中层）                  │
│  - 集成层、适配层                  │
├─────────────────────────────────────┤
│  稳定的 / 很少变（下层）           │
│  - 基础设施、核心算法              │
└─────────────────────────────────────┘
```

**检查：** 你的拆分是否做到了"稳定的在下，易变的在上"？

- [ ] 是
- [ ] 否（需要调整）

---

### 维度2：抽象层级（按职责层次）

```
应用层：处理业务用例
    ↓
协调层：调度和编排
    ↓
算法层：核心逻辑
    ↓
基础设施层：通用功能
    ↓
外部系统：第三方API
```

**检查：** 你的模块是否清楚地按抽象层级排列？

- [ ] 是
- [ ] 否，有些模块跨越多个层级

---

### 维度3：内聚性（按职责聚合）

对每个模块填这个表格：

```
模块名：__________________

相关的类/函数：
1. _____________ - 用一句话描述它做什么
2. _____________ - 用一句话描述它做什么
3. _____________ - 用一句话描述它做什么

这些职责的共同主题是什么？
_________________________________

如果需要一段话（超过一句）来描述模块职责，说明内聚性不够好。
```

**检查：** 每个模块能用一句话描述吗？

- [ ] 是（内聚性好）
- [ ] 否（需要进一步拆分）

---

## 第三步：拆分方案评估

### 评估标准1：代码重复指数

```
计算方式：
1. 列出所有模块
2. 数一下哪些代码片段在多个模块中出现
3. 计算：重复代码数 / 总代码行数

标准：
⭐⭐⭐ 好 = < 5%（允许少量重复，比如配置类）
⭐⭐   中 = 5-15%（有问题，需要提取）
⭐    差 = > 15%（严重问题，架构有缺陷）
```

**你的代码重复指数：** ______%

---

### 评估标准2：修改影响范围

对常见的修改做这个分析：

| 修改类型   | 涉及文件数 | 评分       |
| ------ | ----- | -------- |
| 修改重试策略 | ___   | ⭐ 1个最好   |
| 新增渠道   | ___   | ⭐ 1-2个最好 |
| 修改业务规则 | ___   | ⭐ 1-3个最好 |
| 修改日志格式 | ___   | ⭐ 1个最好   |

**平均评分：**

- [ ] 1-2个文件（很好）
- [ ] 3-5个文件（可以接受）
- [ ] > 5个文件（需要重新拆）

---

### 评估标准3：依赖关系

画出你的模块依赖图：

```
ModuleA → ModuleB → ModuleC
   ↓
ModuleD
```

**检查：**

- [ ] 没有循环依赖（A→B→A）
- [ ] 上层依赖下层（而不是反向）
- [ ] 兄弟模块之间最小化依赖

---

### 评估标准4：可独立测试性

对每个模块问自己：

```
模块：_________________

❓ 这个模块能单独编译吗？
   - [ ] 是
   - [ ] 否（原因：依赖太多）

❓ 这个模块能单独测试吗？
   - [ ] 是
   - [ ] 否（原因：___________）

❓ 如果另一个模块出问题，这个模块会被拖累吗？
   - [ ] 不会
   - [ ] 会（原因：___________）
```

**结论：** 如果有"否"，说明职责耦合过紧，需要拆散。

---

## 第四步：拆分方案（两个选择）

### 方案A：你觉得拆分没问题

那么开始实施：

- [ ] 第1周：搭建基础设施和公共层
- [ ] 第2周：开发业务层
- [ ] 第3周：开发驱动/适配器
- [ ] 第4周：集成和测试

**风险点：** （列出最容易踩的坑）

1. ---

2. ---

3. ---

---

### 方案B：你发现拆分还有问题

那就按这个优先级调整：

**优先级1（必须改）**

- [ ] 有重复代码 → 提取到共享层
- [ ] 有循环依赖 → 引入中间层打破
- [ ] 职责不清晰 → 进一步拆细

**优先级2（应该改）**

- [ ] 修改影响太多文件 → 重新组织
- [ ] 某个模块太大 → 拆成两个
- [ ] 跨层依赖 → 引入适配器

**优先级3（如果有时间）**

- [ ] 优化接口设计
- [ ] 改进命名
- [ ] 添加文档

---

## 第五步：文档化拆分决策

### 必写：架构决策记录（ADR）

```
标题：为什么通知系统采用分层+驱动架构

背景：
  初期用功能拆分（按Email/SMS/Push），导致代码重复、扩展困难

决策：
  采用分层拆分：
  - 第1层：编排层（业务规则）
  - 第2层：基础设施层（可靠投递）
  - 第3层：驱动层（各渠道实现）

优势：
  ✓ 代码重复从50%降到0%
  ✓ 新增渠道时间从3天降到8小时
  ✓ 测试覆盖率从60%提到85%

劣势：
  ✗ 初期设计时间长（需要1周深思熟虑）
  ✗ 需要规范驱动接口

权衡：
  初期投入 vs 长期收益，值得
```

---

## 第六步：团队沟通

### 给实习生解释拆分时的话术

```
"这个项目我们分成三层：

✅ 第1层（编排）：处理'什么时候发什么通知'
   → 改业务规则时只改这一层
   → 产品经理会经常来改这层

✅ 第2层（基础设施）：处理'如何可靠地发送'
   → 重试、限流、监控都在这
   → 很稳定，可能半年都不用改

✅ 第3层（驱动）：处理'如何调用各个API'
   → Email驱动、SMS驱动、Push驱动各自独立
   → 新增一个渠道就新增一个驱动

这样的好处是：
- 代码不重复
- 各自独立，容易测试
- 新人很容易理解

你先从驱动层开始，因为最简单。"
```

---

## 快速检查表（项目启动时）

在开始编码前，快速过一遍：

- [ ] 核心问题清晰吗？
- [ ] 易变/稳定部分分开了吗？
- [ ] 没有明显的代码重复吗？
- [ ] 修改一个需求不需要改 > 5 个文件吗？
- [ ] 依赖关系是单向的吗（下层不依赖上层）？
- [ ] 每个模块能用一句话描述吗？
- [ ] 新人看架构图能快速理解吗？
- [ ] 有测试计划吗？
- [ ] 团队都理解这个拆分吗？

**通过数：** ___ / 9

```
8-9：很好，可以开始
6-7：还可以，有小问题但不致命
< 6：建议停下来再想想
```

---

## 真实案例对照

**案例1：实时通知系统**

- 核心问题：可靠投递
- 拆分方式：分层 + 驱动
- 结果：成功 ✅

**案例2：推荐系统**

- 核心问题：快速计算个性化推荐
- 拆分方式：特征层 + 排序层 + 召回层
- 结果：成功 ✅

**案例3：支付系统**

- 核心问题：恰好一次语义
- 拆分方式：事务 + 异步确认 + 对账
- 结果：成功 ✅

**你的项目：**

- 核心问题：_________________
- 拆分方式：_________________
- 预期结果：_________________
