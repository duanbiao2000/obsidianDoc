---
aliases: null
date: 2025-11-05 10:13
tags: null
source: null
update: null
rating: null
related: null
---

# 用费曼教学法理解 CRDT 框架

| 类型                            | 数据模型   | 同步原则     | 冲突解决方式    | 应用场景        |
| ----------------------------- | ------ | -------- | --------- | ----------- |
| G-Counter                     | 只增计数   | 局部加，全局和  | 最大值合并     | 计数、点赞数      |
| PN-Counter                    | 增+减计数  | 独立存加减    | 各自合并相减    | 在线人数、库存等    |
| OR-Set                        | 集合（可删） | 唯一码+墓碑机制 | 去掉墓碑条目    | 在线协作删除、集合合并 |
| LWW-Register                  | 单值寄存器  | 时间戳比较    | 时间戳最大胜    | 配置/标志最终统一   |
| RGA                           | 序列/文本  | 基于位置插删   | 按拓扑因果订单重组 | 文本编辑、协作文档   |


- 你在上海编辑第3行文字，同事在北京同时修改第5行——如果没有特殊处理，很可能出现“你改的内容被覆盖”“文档乱码”的问题。
- 这就是 **分布式系统的“数据一致性”难题**：多设备/多节点同时改同一份数据，怎么保证最终结果统一，还不丢内容？

CRDT 就是专门解决这个问题的工具。它的全称是 **Conflict-free Replicated Data Type（无冲突复制数据类型）**，核心能力是：

> 让多个节点“随便改”数据，不用实时沟通谁改了什么，最后把所有修改合并时，自动得到一个一致、正确的结果，不会有冲突。

## 二、用“生活例子”拆懂核心逻辑

别被“数据类型”“分布式”这些词吓到，我们用“共享购物清单”来类比 CRDT 的工作方式：

### 1. 传统方式（容易冲突）

你和家人共用一个纸质购物清单：

- 你出门前加了“牛奶”，没拍照告诉家人；
- 家人同时加了“面包”，也没告诉你；
- 等你回家想更新清单时，发现家人写的清单里没有“牛奶”——你的修改被覆盖了，冲突了。

### 2. CRDT 方式（无冲突）

现在把清单换成 CRDT 格式，每个“待办项”都多了两个信息：

- **唯一标识**：比如“牛奶_你_20240520_1430”（谁加的、什么时候加的，确保全世界唯一）；
- **状态标记**：“已添加”“已删除”（而非直接划掉）。

这时你们同时修改：

- 你加了“牛奶_你_20240520_1430（已添加）”；
- 家人加了“面包_家人_20240520_1431（已添加）”；
- 等清单同步时，系统会自动合并：把两个带唯一标识的项都保留，最终清单是“牛奶+面包”——没有冲突。

如果后来你删了“牛奶”，家人没看到：

- 你这边标记“牛奶_你_20240520_1430（已删除）”；

- 同步后，系统看到“牛奶”的最新状态是“已删除”，就会在所有节点上删掉它——结果依然一致。

## 三、CRDT 框架：把“无冲突逻辑”打包成工具

你不用每次做分布式应用都自己写“唯一标识”“状态合并”的代码——CRDT 框架已经把这些逻辑封装好了，提供现成的“数据类型”和“合并算法”，让开发者直接用。

### 1. 核心组成（类比“工具箱”）

| 组成部分     | 作用（用“购物清单”类比）            | 技术层面解释                                                            |
| -------- | ------------------------ | ----------------------------------------------------------------- |
| 预定义数据类型  | 提供“能无冲突修改”的基础数据（如清单、计数器） | 比如 `GSet`（集合，只能加不能删）、`PNCounter`（计数器，可加可减）、`LWWMap`（键值对，按时间戳选最新值） |
| 合并算法     | 自动处理多节点修改，输出一致结果         | 基于“唯一标识”“时间戳”“状态优先级”等规则，确保合并结果唯一且正确                               |
| 持久化/同步工具 | 保存数据、同步多节点修改             | 对接数据库（如 Redis）、网络协议（如 WebSocket），负责数据存储和传输                        |

### 2. 常见 CRDT 框架（选几个“好用的工具箱”）

- **Yjs**：最流行的前端 CRDT 框架，专门用于在线文档（如协作编辑、共享白板），支持和 Vue/React 集成，合并速度快，兼容性好。

→ 例子：Notion、飞书文档的协作功能，很多基于 Yjs 改造。

- **Automerge**：适合全栈场景（前端+后端），API 简单，支持 JSON 格式数据，合并逻辑透明，适合新手入门。

→ 例子：小型协作工具（如共享任务板）常用它。

- **Riak DT**：后端专用框架，基于分布式数据库 Riak，适合大规模数据（如电商库存同步、多区域用户数据），支持高并发。

## 四、用“反例”加深理解：CRDT 不是万能的

费曼教学法强调“知道边界”——CRDT 有优点，但也有局限，比如：

1. **不适合“强实时要求”场景**：如果需要“改完立刻让所有人看到完全一致的结果”（如股票交易），CRDT 不如“中心化锁”（比如先申请修改权限，再改）快，因为它需要时间同步合并。

2. **数据量不能太大**：每个修改都要带“唯一标识”“状态”，数据量会比普通格式大（比如一个单词可能要带额外的时间戳和用户ID），不适合存超大文件（如视频）。

## 五、一句话总结（费曼终极测试）

CRDT 框架就是“给分布式应用的‘共享数据’装了一个‘智能合并器’”——多节点同时改数据时，不用实时商量，最后自动合并出一致结果，再也不怕改丢内容，适合做在线文档、共享任务等协作场景。
