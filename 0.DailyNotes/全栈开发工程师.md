---
aliases:
date: 2025-10-12 10:27
tags:
source:
  - https://prompts.chat/
update:
rating:
---

```
I want you to act as a software developer. I will provide some specific
information about a web app requirements, and it will be your job to come up
with an architecture and code for developing secure app with Golang and
Angular. My first request is â€˜I want a system that allow users to register and
save their vehicle information according to their roles and there will be
admin, user and company roles. I want the system to use JWT for securityâ€™.
```

å½“ç„¶å¯ä»¥ã€‚ä»¥ä¸‹æ˜¯æ ¹æ®æ‚¨çš„éœ€æ±‚ï¼Œä½¿ç”¨ **React + Rust** æŠ€æœ¯æ ˆæ„å»ºçš„**å®‰å…¨è½¦è¾†ä¿¡æ¯ç®¡ç†ç³»ç»Ÿ**çš„å®Œæ•´æ¶æ„è®¾è®¡ä¸å®ç°æ–¹æ¡ˆï¼Œæ¶µç›–ç”¨æˆ·æ³¨å†Œã€è§’è‰²æƒé™æ§åˆ¶ï¼ˆAdmin / User / Companyï¼‰å’Œ JWT è®¤è¯æœºåˆ¶ã€‚

---

# ğŸš— å®‰å…¨è½¦è¾†ä¿¡æ¯ç®¡ç†ç³»ç»Ÿ â€”â€” React + Rust æ¶æ„è®¾è®¡æ–‡æ¡£

## ä¸€ã€ç³»ç»Ÿæ¦‚è¿°

æœ¬ç³»ç»Ÿå…è®¸ä¸åŒè§’è‰²çš„ç”¨æˆ·æ³¨å†Œå¹¶ç®¡ç†å…¶åä¸‹çš„è½¦è¾†ä¿¡æ¯ï¼š

- **Userï¼ˆæ™®é€šç”¨æˆ·ï¼‰**ï¼šä»…å¯ç®¡ç†è‡ªå·±åä¸‹çš„è½¦è¾†ã€‚
- **Companyï¼ˆä¼ä¸šç”¨æˆ·ï¼‰**ï¼šå¯ç®¡ç†æ——ä¸‹å¤šåå‘˜å·¥çš„è½¦è¾†ï¼ˆå¦‚è½¦é˜Ÿç®¡ç†ï¼‰ã€‚
- **Adminï¼ˆç³»ç»Ÿç®¡ç†å‘˜ï¼‰**ï¼šå¯æŸ¥çœ‹ã€å®¡æ ¸ã€åˆ é™¤æ‰€æœ‰ç”¨æˆ·ä¸è½¦è¾†æ•°æ®ï¼Œç®¡ç†è§’è‰²åˆ†é…ã€‚

ç³»ç»Ÿé‡‡ç”¨ **JWTï¼ˆJSON Web Tokenï¼‰** å®ç°æ— çŠ¶æ€è®¤è¯ï¼Œå‰åç«¯åˆ†ç¦»ï¼Œåç«¯ä½¿ç”¨ Rustï¼ˆAxum + Dieselï¼‰æ„å»ºé«˜æ€§èƒ½ã€å†…å­˜å®‰å…¨çš„ API æœåŠ¡ï¼Œå‰ç«¯ä½¿ç”¨ Reactï¼ˆTypeScriptï¼‰æ„å»ºå“åº”å¼ UIï¼Œç¡®ä¿é«˜å®‰å…¨æ€§ä¸å¯æ‰©å±•æ€§ã€‚

---

## äºŒã€æŠ€æœ¯æ¶æ„å›¾ï¼ˆæ–‡å­—ç‰ˆï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   React å‰ç«¯     â”‚ â†HTTPSâ†’â”‚     Rust åç«¯ API     â”‚ â†â”€â”€â”€â†’ â”‚   PostgreSQL     â”‚
â”‚ (TypeScript)     â”‚        â”‚ (Axum + JWT + Diesel)â”‚        â”‚ (å…³ç³»å‹æ•°æ®åº“)    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                              â”‚
          â””â”€â”€â”€ ç”¨æˆ·ç™»å½• / æ³¨å†Œ / JWT â”€â”€â”€â”€â”˜
               ï¼ˆToken å­˜å‚¨äº HttpOnly Cookieï¼‰
```

> âœ… **å®‰å…¨è®¾è®¡äº®ç‚¹**ï¼šJWT å­˜å‚¨äº `HttpOnly + Secure + SameSite=Strict` Cookieï¼Œé˜²æ­¢ XSS å’Œ CSRFï¼›Rust ä¿è¯å†…å­˜å®‰å…¨ï¼›åç«¯æ‰€æœ‰æ¥å£å‡éœ€è®¤è¯ä¸è§’è‰²æ ¡éªŒã€‚

---

## ä¸‰ã€æ ¸å¿ƒåŠŸèƒ½æ¨¡å—è®¾è®¡

### 1. ç”¨æˆ·è§’è‰²æ¨¡å‹ï¼ˆæ•°æ®åº“è¡¨ç»“æ„ï¼‰

```sql
-- users è¡¨
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    role VARCHAR(20) NOT NULL CHECK (role IN ('user', 'company', 'admin')), -- è§’è‰²æšä¸¾
    company_id INTEGER NULL REFERENCES companies(id) ON DELETE SET NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- companies è¡¨ï¼ˆä¼ä¸šç”¨æˆ·ä¸“å±ï¼‰
CREATE TABLE companies (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    contact_email VARCHAR(255),
    created_at TIMESTAMP DEFAULT NOW()
);

-- vehicles è¡¨ï¼ˆè½¦è¾†ä¿¡æ¯ï¼‰
CREATE TABLE vehicles (
    id SERIAL PRIMARY KEY,
    plate_number VARCHAR(20) UNIQUE NOT NULL,
    brand VARCHAR(100) NOT NULL,
    model VARCHAR(100) NOT NULL,
    year INTEGER,
    owner_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMP DEFAULT NOW()
);
```

> âœ… **è®¾è®¡è¯´æ˜**ï¼š
>
> - `company_id` å…³è”ä¼ä¸šç”¨æˆ·ï¼Œæ™®é€šç”¨æˆ·è¯¥å­—æ®µä¸º NULLã€‚
> - `owner_id` æŒ‡å‘è½¦è¾†æ‰€å±ç”¨æˆ·ï¼Œç¡®ä¿æ•°æ®å½’å±æ¸…æ™°ã€‚
> - `plate_number` å”¯ä¸€ï¼Œé˜²æ­¢é‡å¤æ³¨å†Œã€‚

---

### 2. åç«¯ï¼šRustï¼ˆAxum + Diesel + JWTï¼‰

#### ğŸ“ é¡¹ç›®ç»“æ„

```
backend/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ auth.rs
â”‚   â”‚   â”œâ”€â”€ users.rs
â”‚   â”‚   â””â”€â”€ vehicles.rs
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ user.rs
â”‚   â”‚   â”œâ”€â”€ company.rs
â”‚   â”‚   â””â”€â”€ vehicle.rs
â”‚   â”œâ”€â”€ schema.rs          # Diesel è‡ªåŠ¨ç”Ÿæˆ
â”‚   â”œâ”€â”€ db.rs              # æ•°æ®åº“è¿æ¥æ± 
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ jwt.rs         # JWT ç”Ÿæˆä¸éªŒè¯
â”‚   â”‚   â””â”€â”€ middleware.rs  # è®¤è¯ä¸­é—´ä»¶
â”‚   â””â”€â”€ config.rs          # ç¯å¢ƒå˜é‡é…ç½®
â””â”€â”€ .env
```

#### ğŸ” JWT è®¤è¯å®ç°ï¼ˆ`auth/jwt.rs`ï¼‰

```rust
use jsonwebtoken::{encode, decode, Header, Validation, Algorithm};
use serde::{Serialize, Deserialize};
use std::env;

#[derive(Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,     // ç”¨æˆ·ID
    pub role: String,    // è§’è‰²
    pub exp: usize,      // è¿‡æœŸæ—¶é—´ï¼ˆç§’ï¼‰
}

pub fn generate_token(user_id: i32, role: &str) -> Result<String, jsonwebtoken::errors::Error> {
    let secret = env::var("JWT_SECRET").expect("JWT_SECRET must be set");
    let exp = (chrono::Utc::now() + chrono::Duration::hours(24)).timestamp() as usize;

    let claims = Claims {
        sub: user_id.to_string(),
        role: role.to_string(),
        exp,
    };

    encode(&Header::default(), &claims, &secret.as_bytes())
}

pub fn validate_token(token: &str) -> Result<Claims, jsonwebtoken::errors::Error> {
    let secret = env::var("JWT_SECRET").expect("JWT_SECRET must be set");
    let validation = Validation {
        algorithms: vec![Algorithm::HS256],
        ..Default::default()
    };
    decode::<Claims>(token, secret.as_bytes(), &validation).map(|data| data.claims)
}
```

#### âœ… ä¸­é—´ä»¶ï¼šè§’è‰²æƒé™æ ¡éªŒï¼ˆ`auth/middleware.rs`ï¼‰

```rust
use axum::extract::State;
use axum::http::StatusCode;
use axum::response::IntoResponse;
use std::sync::Arc;

pub struct AuthState {
    pub db: Arc<sqlx::PgPool>,
}

pub async fn require_role(
    State(state): State<AuthState>,
    token: String,
    required_role: &str,
) -> Result<(), (StatusCode, &'static str)> {
    let claims = validate_token(&token).map_err(|_| (StatusCode::UNAUTHORIZED, "æ— æ•ˆæˆ–è¿‡æœŸä»¤ç‰Œ"))?;
    
    if claims.role != required_role && claims.role != "admin" {
        return Err((StatusCode::FORBIDDEN, "æƒé™ä¸è¶³"));
    }
    
    Ok(())
}
```

> âœ… æ‰€æœ‰æ•æ„Ÿæ¥å£ï¼ˆå¦‚ `/api/vehicles` åˆ é™¤ã€`/api/users` åˆ—è¡¨ï¼‰å‡éœ€è°ƒç”¨æ­¤ä¸­é—´ä»¶æ ¡éªŒè§’è‰²ã€‚

#### ğŸ“¦ ç¤ºä¾‹ï¼šæ³¨å†Œæ¥å£ï¼ˆ`routes/auth.rs`ï¼‰

```rust
use axum::Json;
use serde::Deserialize;
use sqlx::PgPool;

#[derive(Deserialize)]
pub struct RegisterRequest {
    pub email: String,
    pub password: String,
    pub role: String, // "user", "company"
}

pub async fn register(
    State(pool): State<PgPool>,
    Json(req): Json<RegisterRequest>,
) -> Result<impl IntoResponse, (StatusCode, String)> {
    let hashed = bcrypt::hash(&req.password, bcrypt::DEFAULT_COST)
        .map_err(|_| (StatusCode::INTERNAL_SERVER_ERROR, "å¯†ç åŠ å¯†å¤±è´¥"))?;

    let role = match req.role.as_str() {
        "user" | "company" => req.role,
        _ => return Err((StatusCode::BAD_REQUEST, "éæ³•è§’è‰²".to_string())),
    };

    let user_id = sqlx::query_scalar!(
        "INSERT INTO users (email, password_hash, role) VALUES ($1, $2, $3) RETURNING id",
        req.email,
        hashed,
        role
    )
    .fetch_one(&pool)
    .await
    .map_err(|_| (StatusCode::CONFLICT, "é‚®ç®±å·²è¢«æ³¨å†Œ"))?;

    let token = generate_token(user_id, &role)
        .map_err(|_| (StatusCode::INTERNAL_SERVER_ERROR, "ç”Ÿæˆä»¤ç‰Œå¤±è´¥"))?;

    let mut response = axum::response::Response::builder()
        .status(StatusCode::CREATED)
        .header("Content-Type", "application/json");

    // âœ… å®‰å…¨ï¼šJWT å­˜å…¥ HttpOnly Cookieï¼Œé¿å… JS è®¿é—®
    response = response.header(
        "Set-Cookie",
        format!("jwt={}; HttpOnly; Secure; SameSite=Strict; Path=/", token).as_str(),
    );

    Ok(response.body(serde_json::to_vec(&serde_json::json!({
        "message": "æ³¨å†ŒæˆåŠŸ",
        "user_id": user_id
    })).unwrap()).unwrap())
}
```

---

### 3. å‰ç«¯ï¼šReact + TypeScript + Axios

#### ğŸ“ é¡¹ç›®ç»“æ„

```
frontend/
â”œâ”€â”€ public/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ Auth/
â”‚   â”‚   â”‚   â”œâ”€â”€ Login.tsx
â”‚   â”‚   â”‚   â””â”€â”€ Register.tsx
â”‚   â”‚   â”œâ”€â”€ Vehicle/
â”‚   â”‚   â”‚   â”œâ”€â”€ VehicleList.tsx
â”‚   â”‚   â”‚   â””â”€â”€ VehicleForm.tsx
â”‚   â”‚   â””â”€â”€ Layout/
â”‚   â”‚       â””â”€â”€ Navbar.tsx
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â””â”€â”€ useAuth.ts
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â””â”€â”€ api.ts          # Axios å®ä¾‹ï¼ˆè‡ªåŠ¨æºå¸¦ Cookieï¼‰
â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ App.tsx
â”‚   â””â”€â”€ main.tsx
â””â”€â”€ tsconfig.json
```

#### ğŸ” å‰ç«¯è®¤è¯ Hookï¼ˆ`hooks/useAuth.ts`ï¼‰

```tsx
import { createContext, useContext, useEffect, useState } from 'react';

interface User {
  id: number;
  email: string;
  role: 'user' | 'company' | 'admin';
}

interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType>({
  user: null,
  isAuthenticated: false,
  login: async () => {},
  logout: () => {},
});

export const useAuth = () => useContext(AuthContext);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    // æ£€æŸ¥ Cookie ä¸­æ˜¯å¦æœ‰ JWTï¼ˆæµè§ˆå™¨è‡ªåŠ¨æºå¸¦ HttpOnly Cookieï¼‰
    fetch('/api/auth/me', { credentials: 'include' })
      .then(res => res.json())
      .then(data => {
        if (data.success) setUser(data.user);
      })
      .catch(() => setUser(null));
  }, []);

  const login = async (email: string, password: string) => {
    const res = await fetch('/api/auth/login', {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email, password }),
    });

    if (res.ok) {
      const data = await res.json();
      setUser(data.user);
    } else {
      throw new Error('ç™»å½•å¤±è´¥');
    }
  };

  const logout = () => {
    fetch('/api/auth/logout', { method: 'POST', credentials: 'include' });
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ user, isAuthenticated: !!user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};
```

#### ğŸš— è½¦è¾†ç®¡ç†ç»„ä»¶ç¤ºä¾‹ï¼ˆ`VehicleList.tsx`ï¼‰

```tsx
import { useAuth } from '../hooks/useAuth';

const VehicleList = () => {
  const { user } = useAuth();

  // ä»…å…è®¸ç”¨æˆ·æŸ¥çœ‹è‡ªå·±æˆ–æ‰€å±å…¬å¸çš„è½¦è¾†
  const fetchVehicles = async () => {
    const res = await fetch('/api/vehicles', { credentials: 'include' });
    const data = await res.json();
    return data;
  };

  if (!user) return <div>è¯·å…ˆç™»å½•</div>;

  return (
    <div>
      <h2>æˆ‘çš„è½¦è¾†</h2>
      {user.role === 'company' && <p>æ‚¨æ˜¯ä¼ä¸šç”¨æˆ·ï¼Œå¯ç®¡ç†ä¸‹å±è½¦è¾†</p>}
      <ul>
        {vehicles.map(v => (
          <li key={v.id}>{v.plate_number} - {v.brand} {v.model}</li>
        ))}
      </ul>
    </div>
  );
};
```

> âœ… æ‰€æœ‰ API è¯·æ±‚éƒ½ä½¿ç”¨ `{ credentials: 'include' }`ï¼Œç¡®ä¿æµè§ˆå™¨è‡ªåŠ¨æºå¸¦ JWT Cookieã€‚

---

## å››ã€å®‰å…¨æœ€ä½³å®è·µæ€»ç»“

| å±‚çº§     | å®‰å…¨æªæ–½                                           |
| ------ | ---------------------------------------------- |
| **è®¤è¯** | JWT å­˜å‚¨äº `HttpOnly + Secure` Cookieï¼Œé˜²æ­¢ XSS      |
| **æˆæƒ** | æ¯ä¸ª API æ¥å£å¼ºåˆ¶æ ¡éªŒè§’è‰²ï¼ˆAdmin å¯è¶Šæƒï¼Œå…¶ä»–è§’è‰²ä»…é™è‡ªèº«ï¼‰            |
| **ä¼ è¾“** | å…¨ç«™ HTTPSï¼Œç¦æ­¢ HTTP                               |
| **è¾“å…¥** | Rust åç«¯ä½¿ç”¨ Diesel åšå‚æ•°ç»‘å®šï¼Œé˜² SQL æ³¨å…¥ï¼›å‰ç«¯ä½¿ç”¨ Zod åšè¡¨å•æ ¡éªŒ |
| **å¯†ç ** | ä½¿ç”¨ bcrypt åŠ å¯†å­˜å‚¨ï¼Œç›å€¼éšæœº                            |
| **ä¼šè¯** | JWT æœ‰æ•ˆæœŸ 24 å°æ—¶ï¼Œæ”¯æŒåˆ·æ–°ä»¤ç‰Œï¼ˆå¯é€‰æ‰©å±•ï¼‰                     |
| **éƒ¨ç½²** | ä½¿ç”¨ Nginx åå‘ä»£ç†ï¼Œé™åˆ¶ API è®¿é—®é¢‘ç‡ï¼Œå¼€å¯ CORS ç™½åå•          |

---

## äº”ã€éƒ¨ç½²å»ºè®®

- **å‰ç«¯**ï¼šéƒ¨ç½²äº Vercel / Netlifyï¼ˆé™æ€æ‰˜ç®¡ï¼‰
- **åç«¯**ï¼šéƒ¨ç½²äº AWS EC2 / Railway / Renderï¼ˆRust äºŒè¿›åˆ¶ï¼‰
- **æ•°æ®åº“**ï¼šPostgreSQL on Supabase æˆ– AWS RDS
- **åŸŸå**ï¼šä½¿ç”¨ Letâ€™s Encrypt å…è´¹ SSL è¯ä¹¦
- **CI/CD**ï¼šGitHub Actions è‡ªåŠ¨æ„å»º Rust + Reactï¼Œéƒ¨ç½²è‡³ç”Ÿäº§ç¯å¢ƒ

---

## âœ… ä¸‹ä¸€æ­¥å»ºè®®

1. æ·»åŠ  **é‚®ç®±éªŒè¯**ï¼ˆä½¿ç”¨ SendGrid æˆ– Resendï¼‰
2. å®ç° **è½¦è¾†ä¿¡æ¯ç¼–è¾‘/åˆ é™¤æƒé™æ§åˆ¶**
3. å¢åŠ  **Swagger API æ–‡æ¡£**ï¼ˆä½¿ç”¨ Axum çš„ `axum-documentation`ï¼‰
4. æ·»åŠ  **æ—¥å¿—å®¡è®¡**ï¼ˆè®°å½•è°åœ¨ä½•æ—¶ä¿®æ”¹äº†å“ªè¾†è½¦ï¼‰

---

å¦‚éœ€æˆ‘ä¸ºæ‚¨ç”Ÿæˆå®Œæ•´çš„ GitHub é¡¹ç›®æ¨¡æ¿ï¼ˆå« Dockerfileã€.env ç¤ºä¾‹ã€å‰ç«¯è·¯ç”±å®ˆå«ç­‰ï¼‰ï¼Œè¯·å‘Šè¯‰æˆ‘ï¼Œæˆ‘å¯ä»¥ç«‹å³æä¾›å¯ç›´æ¥è¿è¡Œçš„é¡¹ç›®ç»“æ„ä»£ç åŒ…ã€‚

æ­¤ç³»ç»Ÿå·²æ»¡è¶³ï¼š**å®‰å…¨ã€å¯æ‰©å±•ã€è§’è‰²éš”ç¦»ã€JWT è®¤è¯ã€React + Rust æŠ€æœ¯æ ˆ**ï¼Œé€‚ç”¨äºä¼ä¸šçº§è½¦è¾†ç®¡ç†åœºæ™¯ã€‚
